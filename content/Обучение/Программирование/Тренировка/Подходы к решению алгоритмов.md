## 1. Два указателя (Two Pointers)

**Когда использовать:** Работа с отсортированными массивами, строками, поиск пар элементов

**Примеры задач:**

- Найти два числа в отсортированном массиве, сумма которых равна target
- Проверить строку на палиндром
- Удалить дубликаты из отсортированного массива
- Найти контейнер с максимальным объемом воды
- Слияние двух отсортированных массивов

```csharp
// Пример: Two Sum в отсортированном массиве
public int[] TwoSum(int[] nums, int target)
{
    int left = 0, right = nums.Length - 1;
    
    while (left < right)
    {
        int sum = nums[left] + nums[right];
        if (sum == target) return new int[] { left, right };
        else if (sum < target) left++;
        else right--;
    }
    
    return new int[0];
}
```

## 2. Скользящее окно (Sliding Window)

**Когда использовать:** Поиск подмассивов/подстрок с определенными свойствами

**Примеры задач:**

- Максимальная сумма подмассива фиксированной длины
- Самая длинная подстрока без повторяющихся символов
- Минимальное окно, содержащее все символы из pattern
- Подмассив с максимальным средним значением

```csharp
// Пример: Максимальная сумма подмассива длины k
public int MaxSumSubarray(int[] nums, int k)
{
    int windowSum = 0;
    for (int i = 0; i < k; i++)
        windowSum += nums[i];
    
    int maxSum = windowSum;
    
    for (int i = k; i < nums.Length; i++)
    {
        windowSum += nums[i] - nums[i - k];
        maxSum = Math.Max(maxSum, windowSum);
    }
    
    return maxSum;
}
```

## 3. Быстрый и медленный указатели (Fast & Slow Pointers / Floyd's Cycle)

**Когда использовать:** Обнаружение циклов, поиск средних элементов

**Примеры задач:**

- Найти цикл в связном списке
- Найти средний элемент списка
- Найти начало цикла в списке
- Happy Number problem

```csharp
// Пример: Обнаружение цикла в связном списке
public bool HasCycle(ListNode head)
{
    if (head == null) return false;
    
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null)
    {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) return true;
    }
    
    return false;
}
```

## 4. Разделяй и властвуй (Divide and Conquer)

**Когда использовать:** Рекурсивное разбиение задачи на подзадачи

**Примеры задач:**

- Merge Sort, Quick Sort
- Binary Search
- Maximum Subarray (Kadane's algorithm)
- Умножение больших чисел

```csharp
// Пример: Binary Search
public int BinarySearch(int[] nums, int target)
{
    int left = 0, right = nums.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return -1;
}
```

## 5. Динамическое программирование (Dynamic Programming)

**Когда использовать:** Оптимизационные задачи с перекрывающимися подзадачами

**Примеры задач:**

- Числа Фибоначчи
- Longest Common Subsequence
- 0/1 Knapsack Problem
- Coin Change Problem
- Максимальная сумма в массиве без соседних элементов

```csharp
// Пример: Coin Change
public int CoinChange(int[] coins, int amount)
{
    int[] dp = new int[amount + 1];
    Array.Fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++)
    {
        foreach (int coin in coins)
        {
            if (coin <= i)
                dp[i] = Math.Min(dp[i], dp[i - coin] + 1);
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```

## 6. Поиск в глубину/ширину (DFS/BFS)

**Когда использовать:** Обход графов, деревьев, поиск путей

**Примеры задач:**

- Обход дерева (inorder, preorder, postorder)
- Поиск островов в матрице
- Проверка валидности бинарного дерева поиска
- Кратчайший путь в лабиринте

```csharp
// Пример: DFS для подсчета островов
public int NumIslands(char[][] grid)
{
    int count = 0;
    
    for (int i = 0; i < grid.Length; i++)
    {
        for (int j = 0; j < grid[i].Length; j++)
        {
            if (grid[i][j] == '1')
            {
                DFS(grid, i, j);
                count++;
            }
        }
    }
    
    return count;
}

private void DFS(char[][] grid, int i, int j)
{
    if (i < 0 || i >= grid.Length || j < 0 || j >= grid[i].Length || grid[i][j] != '1')
        return;
    
    grid[i][j] = '0';
    DFS(grid, i + 1, j);
    DFS(grid, i - 1, j);
    DFS(grid, i, j + 1);
    DFS(grid, i, j - 1);
}
```

## 7. Жадные алгоритмы (Greedy)

**Когда использовать:** Задачи, где локально оптимальный выбор ведет к глобальному оптимуму

**Примеры задач:**

- Activity Selection Problem
- Jump Game
- Gas Station Problem
- Минимальное количество интервалов для покрытия

```csharp
// Пример: Jump Game
public bool CanJump(int[] nums)
{
    int maxReach = 0;
    
    for (int i = 0; i < nums.Length; i++)
    {
        if (i > maxReach) return false;
        maxReach = Math.Max(maxReach, i + nums[i]);
    }
    
    return true;
}
```

## 8. Backtracking (Возврат с откатом)

**Когда использовать:** Поиск всех возможных решений, перебор с ограничениями

**Примеры задач:**

- N-Queens Problem
- Sudoku Solver
- Generate Parentheses
- Permutations/Combinations

```csharp
// Пример: Generate Parentheses
public IList<string> GenerateParenthesis(int n)
{
    var result = new List<string>();
    Backtrack(result, "", 0, 0, n);
    return result;
}

private void Backtrack(List<string> result, string current, int open, int close, int max)
{
    if (current.Length == max * 2)
    {
        result.Add(current);
        return;
    }
    
    if (open < max)
        Backtrack(result, current + "(", open + 1, close, max);
    
    if (close < open)
        Backtrack(result, current + ")", open, close + 1, max);
}
```

Эти паттерны покрывают около 80% задач на собеседованиях. Главное - научиться распознавать, какой подход применить к конкретной задаче.