–í–æ—Ç 8 –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á —Ä–∞–∑–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏! –û–Ω–∏ –ø–æ–∫—Ä—ã–≤–∞—é—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –≤ —Ä–µ–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö:

## üéØ **–†–µ–∫–æ–º–µ–Ω–¥—É—é –Ω–∞—á–∞—Ç—å —Å:**

**–ó–∞–¥–∞—á–∞ 1 (Email Batch)** - –ø–æ—Ö–æ–∂–∞ –Ω–∞ –≤–∞—à—É –∏—Å—Ö–æ–¥–Ω—É—é, –Ω–æ —Å retry –º–µ—Ö–∞–Ω–∏–∑–º–æ–º  
**–ó–∞–¥–∞—á–∞ 2 (File Processing)** - –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π pipeline –ø–∞—Ç—Ç–µ—Ä–Ω

## üìà **–£—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏:**

**Beginner:** –ó–∞–¥–∞—á–∏ 1-2  
**Intermediate:** –ó–∞–¥–∞—á–∏ 3-5  
**Advanced:** –ó–∞–¥–∞—á–∏ 6-8

## üîß **–ß—Ç–æ –ø–æ—Ç—Ä–µ–Ω–∏—Ä—É–µ—Ç–µ:**

- **SemaphoreSlim** - –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞
- **Producer-Consumer** - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–µ–π
- **Rate Limiting** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–æ–π –Ω–∞ API
- **Caching** - –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å
- **Circuit Breaker** - —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –∫ —Å–±–æ—è–º
- **Background processing** - —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏

## üí° **–ü–æ–¥—Ö–æ–¥—ã –∫ —Ä–µ—à–µ–Ω–∏—é:**

1. **–ù–∞—á–Ω–∏—Ç–µ —Å –ø—Ä–æ—Å—Ç–æ–π –≤–µ—Ä—Å–∏–∏** - –∑–∞—Å—Ç–∞–≤—å—Ç–µ —Ä–∞–±–æ—Ç–∞—Ç—å
2. **–î–æ–±–∞–≤—å—Ç–µ –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫** - —á—Ç–æ –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ–π–¥–µ—Ç –Ω–µ —Ç–∞–∫?
3. **–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –≥–¥–µ —É–∑–∫–∏–µ –º–µ—Å—Ç–∞?
4. **–ù–∞–ø–∏—à–∏—Ç–µ —Ç–µ—Å—Ç—ã** - –∫–∞–∫ —É–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ?

## üöÄ **–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —á–µ–ª–ª–µ–Ω–¥–∂–∏:**

–ü–æ—Å–ª–µ —Ä–µ—à–µ–Ω–∏—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –∑–∞–¥–∞—á –º–æ–∂–µ—Ç–µ:

- –î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
- –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å graceful shutdown
- –î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä—É–µ–º–æ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
- –°–æ–∑–¥–∞—Ç—å fluent API –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
- 
```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

// =====================================================
// –ó–ê–î–ê–ß–ê 1: Batch Processing —Å retry –º–µ—Ö–∞–Ω–∏–∑–º–æ–º
// =====================================================

public interface IEmailService
{
    Task<bool> SendEmailAsync(string email, string subject, string body);
}

public class EmailRequest
{
    public string Email { get; set; }
    public string Subject { get; set; }
    public string Body { get; set; }
}

public static class EmailExtensions
{
    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –º–Ω–æ–∂–µ—Å—Ç–≤–∞ email'–æ–≤ —Å:
    // - –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞ (maxConcurrency)
    // - Retry –º–µ—Ö–∞–Ω–∏–∑–º–æ–º (maxRetries)
    // - –í–æ–∑–≤—Ä–∞—â–∞—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–µ—É—Å–ø–µ—à–Ω—ã—Ö –æ—Ç–ø—Ä–∞–≤–æ–∫
    public static async Task<List<EmailRequest>> SendBatchAsync(
        this IEmailService emailService,
        List<EmailRequest> requests,
        int maxConcurrency,
        int maxRetries = 3)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }
}

// =====================================================
// –ó–ê–î–ê–ß–ê 2: File Processing Pipeline
// =====================================================

public interface IFileProcessor
{
    Task<string> ReadFileAsync(string filePath);
    Task<string> TransformAsync(string content);
    Task WriteFileAsync(string filePath, string content);
}

public static class FileProcessingExtensions
{
    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–∞–π–ø–ª–∞–π–Ω –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–æ–≤:
    // - –ß—Ç–µ–Ω–∏–µ ‚Üí –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è ‚Üí –ó–∞–ø–∏—Å—å
    // - –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã—Ö —Ñ–∞–π–ª–æ–≤
    // - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    // - –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫–∏ (–µ—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å, –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –µ–≥–æ)
    public static async Task<string[]> ProcessFilesAsync(
        this IFileProcessor processor,
        string[] inputPaths,
        string[] outputPaths,
        int maxConcurrency)
    {
        // –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å –º–∞—Å—Å–∏–≤ –ø—É—Ç–µ–π —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }
}

// =====================================================
// –ó–ê–î–ê–ß–ê 3: API Rate Limited Client
// =====================================================

public interface IApiClient
{
    Task<T> GetAsync<T>(string endpoint);
}

public class RateLimitedApiClient
{
    private readonly IApiClient _client;
    
    public RateLimitedApiClient(IApiClient client)
    {
        _client = client;
    }

    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫–ª–∏–µ–Ω—Ç —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —á–∞—Å—Ç–æ—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤:
    // - –ú–∞–∫—Å–∏–º—É–º requestsPerSecond –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
    // - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å sliding window –∏–ª–∏ token bucket –∞–ª–≥–æ—Ä–∏—Ç–º
    // - –ï—Å–ª–∏ –ª–∏–º–∏—Ç –ø—Ä–µ–≤—ã—à–µ–Ω, –∂–¥–∞—Ç—å –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ —Å–ª–æ—Ç–∞
    public async Task<T> GetAsync<T>(string endpoint, int requestsPerSecond)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }

    // TODO: Batch –≤–µ—Ä—Å–∏—è —Å –ª–∏–º–∏—Ç–æ–º
    public async Task<T[]> GetBatchAsync<T>(string[] endpoints, int requestsPerSecond)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }
}

// =====================================================
// –ó–ê–î–ê–ß–ê 4: Cache with Timeout –∏ Background Refresh
// =====================================================

public interface IDataService
{
    Task<string> GetDataAsync(string key);
}

public class CachedDataService
{
    private readonly IDataService _dataService;
    private readonly Dictionary<string, (string value, DateTime expiry)> _cache = new();
    
    public CachedDataService(IDataService dataService)
    {
        _dataService = dataService;
    }

    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫—ç—à —Å:
    // - TTL (–≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∑–∞–ø–∏—Å–∏)
    // - Background refresh (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ —Ñ–æ–Ω–µ –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è TTL)
    // - –ó–∞—â–∏—Ç–∞ –æ—Ç multiple concurrent requests –¥–ª—è –æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞
    // - Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ refresh —É–ø–∞–ª
    public async Task<string> GetAsync(string key, TimeSpan ttl, TimeSpan refreshBeforeExpiry)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }
}

// =====================================================
// –ó–ê–î–ê–ß–ê 5: Producer-Consumer —Å Backpressure
// =====================================================

public class WorkItem
{
    public int Id { get; set; }
    public string Data { get; set; }
}

public interface IWorkProcessor
{
    Task ProcessAsync(WorkItem item);
}

public class WorkQueue
{
    private readonly IWorkProcessor _processor;
    
    public WorkQueue(IWorkProcessor processor)
    {
        _processor = processor;
    }

    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥—å —Ä–∞–±–æ—Ç —Å:
    // - –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º –æ—á–µ—Ä–µ–¥–∏ (maxQueueSize)
    // - Backpressure: –µ—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø–æ–ª–Ω–∞—è, –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å AddWork
    // - –ù–µ—Å–∫–æ–ª—å–∫–æ consumer'–æ–≤ (workerCount)
    // - Graceful shutdown —Å CancellationToken
    // - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: —Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ/–≤ –æ—á–µ—Ä–µ–¥–∏
    public async Task StartAsync(int maxQueueSize, int workerCount, CancellationToken cancellationToken)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }

    public async Task AddWorkAsync(WorkItem item, CancellationToken cancellationToken)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }

    public (int processed, int queued) GetStats()
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }
}

// =====================================================
// –ó–ê–î–ê–ß–ê 6: Circuit Breaker Pattern
// =====================================================

public enum CircuitState
{
    Closed,    // –ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    Open,      // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤—ã–∑–æ–≤—ã
    HalfOpen   // –ü—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
}

public class CircuitBreaker<T>
{
    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Circuit Breaker:
    // - –°—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫ –≤ —Å–∫–æ–ª—å–∑—è—â–µ–º –æ–∫–Ω–µ –≤—Ä–µ–º–µ–Ω–∏
    // - –ï—Å–ª–∏ –æ—à–∏–±–æ–∫ –±–æ–ª—å—à–µ –ø–æ—Ä–æ–≥–∞, –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –≤ Open —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    // - –í Open —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Å—Ä–∞–∑—É –∫–∏–¥–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –±–µ–∑ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏
    // - –ß–µ—Ä–µ–∑ timeout –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –≤ HalfOpen
    // - –í HalfOpen –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å –æ–¥–∏–Ω –≤—ã–∑–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    // - –ï—Å–ª–∏ –≤—ã–∑–æ–≤ —É—Å–ø–µ—à–µ–Ω, –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –≤ Closed, –∏–Ω–∞—á–µ –æ–±—Ä–∞—Ç–Ω–æ –≤ Open
    
    public async Task<T> ExecuteAsync(Func<Task<T>> operation, 
        int failureThreshold,           // –°–∫–æ–ª—å–∫–æ –æ—à–∏–±–æ–∫ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è
        TimeSpan timeout,               // –í—Ä–µ–º—è –¥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ HalfOpen
        TimeSpan samplingDuration)      // –û–∫–Ω–æ –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –æ—à–∏–±–æ–∫
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }

    public CircuitState State { get; private set; }
}

// =====================================================
// –ó–ê–î–ê–ß–ê 7: Parallel Web Scraper
// =====================================================

public class WebPage
{
    public string Url { get; set; }
    public string Content { get; set; }
    public List<string> Links { get; set; } = new();
    public Exception Error { get; set; }
}

public interface IWebClient
{
    Task<string> DownloadAsync(string url);
}

public class WebScraper
{
    private readonly IWebClient _webClient;
    
    public WebScraper(IWebClient webClient)
    {
        _webClient = webClient;
    }

    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤–µ–±-—Å–∫—Ä–∞–ø–µ—Ä:
    // - –°–∫–∞—á–∞—Ç—å —Å—Ç–∞—Ä—Ç–æ–≤—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    // - –ò–∑–≤–ª–µ—á—å —Å—Å—ã–ª–∫–∏ —Å –∫–∞–∂–¥–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    // - –°–∫–∞—á–∞—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–¥–æ maxDepth —É—Ä–æ–≤–Ω–µ–π)
    // - –ù–µ —Å–∫–∞—á–∏–≤–∞—Ç—å –æ–¥–Ω—É —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–≤–∞–∂–¥—ã
    // - –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º (—á—Ç–æ–±—ã –Ω–µ DDos'–∏—Ç—å —Å–∞–π—Ç)
    // - –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ –∫ –æ–¥–Ω–æ–º—É –¥–æ–º–µ–Ω—É
    public async Task<List<WebPage>> ScrapeAsync(
        string[] startUrls,
        int maxDepth,
        int maxConcurrency,
        TimeSpan delayBetweenRequests)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }

    private List<string> ExtractLinks(string content, string baseUrl)
    {
        // –ü—Ä–æ—Å—Ç–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –±—ã HtmlAgilityPack –∏–ª–∏ AngleSharp
        return new List<string>();
    }
}

// =====================================================
// –ë–û–ù–£–°–ù–ê–Ø –ó–ê–î–ê–ß–ê 8: Async Lock —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏
// =====================================================

public enum Priority
{
    Low = 0,
    Normal = 1, 
    High = 2,
    Critical = 3
}

public class PriorityAsyncLock
{
    // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π lock —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏:
    // - –í—ã—Å–æ–∫–æ–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏ –ø–æ–ª—É—á–∞—é—Ç –¥–æ—Å—Ç—É–ø —Ä–∞–Ω—å—à–µ
    // - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ timeout'–æ–≤
    // - Cancellation support
    // - –ó–∞—â–∏—Ç–∞ –æ—Ç starvation (–Ω–∏–∑–∫–æ–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏ —Ç–æ–∂–µ –¥–æ–ª–∂–Ω—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è)
    
    public async Task<IDisposable> AcquireAsync(
        Priority priority = Priority.Normal,
        TimeSpan timeout = default,
        CancellationToken cancellationToken = default)
    {
        // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–¥–µ—Å—å
        throw new NotImplementedException();
    }
}

// =====================================================
// –ü–û–î–°–ö–ê–ó–ö–ò –î–õ–Ø –†–ï–®–ï–ù–ò–Ø:
// =====================================================

/*
–ó–ê–î–ê–ß–ê 1 (Email Batch):
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ SemaphoreSlim –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞  
- –î–ª—è retry –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ü–∏–∫–ª —Å await Task.Delay –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏
- –°–æ–±–∏—Ä–∞–π—Ç–µ –Ω–µ—É—Å–ø–µ—à–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ ConcurrentBag

–ó–ê–î–ê–ß–ê 2 (File Processing):
- –°–æ–∑–¥–∞–π—Ç–µ pipeline: read ‚Üí transform ‚Üí write
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Task.WhenAll —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —á–µ—Ä–µ–∑ SemaphoreSlim
- –î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –æ–±–µ—Ä–Ω–∏—Ç–µ –∫–∞–∂–¥—É—é –æ–ø–µ—Ä–∞—Ü–∏—é –≤ try-catch

–ó–ê–î–ê–ß–ê 3 (Rate Limiting):
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ SemaphoreSlim + Timer –¥–ª—è token bucket
- –ò–ª–∏ –≤–µ–¥–∏—Ç–µ —Å–ø–∏—Å–æ–∫ timestamp'–æ–≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
- DateTime.UtcNow –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏

–ó–ê–î–ê–ß–ê 4 (Cache):
- Dictionary + SemaphoreSlim –¥–ª—è thread-safety
- Task.Run –¥–ª—è background refresh
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ TaskCompletionSource –¥–ª—è –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤

–ó–ê–î–ê–ß–ê 5 (Producer-Consumer):
- Channel<T> –∏–ª–∏ BlockingCollection<T>
- Task.Run –¥–ª—è –∫–∞–∂–¥–æ–≥–æ worker'–∞
- CancellationToken.Register –¥–ª—è graceful shutdown

–ó–ê–î–ê–ß–ê 6 (Circuit Breaker):
- –í–µ–¥–∏—Ç–µ —Å–ø–∏—Å–æ–∫ timestamp'–æ–≤ –æ—à–∏–±–æ–∫
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ + DateTime –¥–ª—è timeout'–æ–≤
- lock –¥–ª—è thread-safety —Å–æ—Å—Ç–æ—è–Ω–∏—è

–ó–ê–î–ê–ß–ê 7 (Web Scraper):
- HashSet –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö URL
- SemaphoreSlim + Dictionary<domain, DateTime> –¥–ª—è rate limiting –ø–æ –¥–æ–º–µ–Ω–∞–º
- Queue<(url, depth)> –¥–ª—è BFS –æ–±—Ö–æ–¥–∞

–ó–ê–î–ê–ß–ê 8 (Priority Lock):
- SortedDictionary –∏–ª–∏ PriorityQueue –¥–ª—è –æ—á–µ—Ä–µ–¥–∏ –æ–∂–∏–¥–∞–Ω–∏—è
- TaskCompletionSource –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–∂–∏–¥–∞—é—â–µ–≥–æ
- –ú–µ—Ö–∞–Ω–∏–∑–º anti-starvation (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤—Ä–µ–º–µ–Ω–Ω–æ–µ –ø–æ–≤—ã—à–µ–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞)
*/
```

# Task 2

```csharp
public static class FileProcessingExtensions
{
    public static async Task<string[]> ProcessFilesAsync(
        this IFileProcessor processor,
        string[] inputPaths,
        string[] outputPaths,
        int maxConcurrency)
    {
        if (inputPaths.Length != outputPaths.Length)
            throw new ArgumentException("Input and output paths arrays must have the same length");

        var semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency);
        var successfulPaths = new List<string>();
        var lockObject = new object();

        // –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞
        var tasks = inputPaths.Select(async (inputPath, index) =>
        {
            await semaphore.WaitAsync();
            try
            {
                // Pipeline: Read ‚Üí Transform ‚Üí Write
                var content = await processor.ReadFileAsync(inputPath);
                var transformedContent = await processor.TransformAsync(content);
                await processor.WriteFileAsync(outputPaths[index], transformedContent);

                // –î–æ–±–∞–≤–ª—è–µ–º —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –ø—É—Ç—å
                lock (lockObject)
                {
                    successfulPaths.Add(outputPaths[index]);
                }
            }
            catch (Exception ex)
            {
                // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –∏–ª–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
                // –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ–∞–π–ª
                Console.WriteLine($"Failed to process {inputPath}: {ex.Message}");
            }
            finally
            {
                semaphore.Release();
            }
        });

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
        await Task.WhenAll(tasks);

        return successfulPaths.ToArray();
    }
}

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –ø–æ—Ä—è–¥–∫–∞
public static class FileProcessingExtensionsV2
{
    public static async Task<string[]> ProcessFilesAsync(
        this IFileProcessor processor,
        string[] inputPaths,
        string[] outputPaths,
        int maxConcurrency)
    {
        if (inputPaths.Length != outputPaths.Length)
            throw new ArgumentException("Input and output paths arrays must have the same length");

        var semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency);
        var results = new bool[inputPaths.Length];

        // –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞ —Å –∏–Ω–¥–µ–∫—Å–æ–º
        var tasks = inputPaths.Select(async (inputPath, index) =>
        {
            await semaphore.WaitAsync();
            try
            {
                // Pipeline: Read ‚Üí Transform ‚Üí Write
                var content = await processor.ReadFileAsync(inputPath);
                var transformedContent = await processor.TransformAsync(content);
                await processor.WriteFileAsync(outputPaths[index], transformedContent);

                results[index] = true; // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ —É—Å–ø–µ—à–Ω—ã–π
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to process {inputPath}: {ex.Message}");
                results[index] = false; // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –Ω–µ—É—Å–ø–µ—à–Ω—ã–π
            }
            finally
            {
                semaphore.Release();
            }
        });

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
        await Task.WhenAll(tasks);

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –ø—É—Ç–∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        return outputPaths
            .Where((path, index) => results[index])
            .ToArray();
    }
}
```