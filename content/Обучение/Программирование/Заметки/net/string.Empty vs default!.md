Обе записи:

```csharp
public string Text { get; set; } = default!;
```

и

```csharp
public string Text { get; set; } = string.Empty;
```

**на первый взгляд делают похожее** — задают начальное значение для строки и "успокаивают" компилятор, но есть **ключевые отличия**:

---

### ✅ `string.Empty`

```csharp
public string Text { get; set; } = string.Empty;
```

- Присваивает **пустую строку** (`""`) по умолчанию.
    
- Безопасно — это реальное значение.
    
- Полезно, если ты хочешь, чтобы строка точно не была `null` и уже готова к использованию (например, в валидации, сериализации и т.д.).
    
- Подходит для DTO, ViewModel, где строка часто сразу используется или сериализуется.
    

---

### ⚠ `default!`

```csharp
public string Text { get; set; } = default!;
```

- Присваивает **`null`**, но с помощью `!` говорит компилятору **"я ручаюсь, что значение будет присвоено до использования"**.
    
- Это **null-forgiving operator**: подавляет предупреждение nullable-анализатора.
    
- Используется в основном в Entity-классах (например, EF Core), где значения будут установлены **позже** — например, при загрузке из базы.
    

```csharp
// EF Core под капотом вызовет конструктор без параметров и сам присвоит значение
public class Entity
{
    public string Name { get; set; } = default!;
}
```

---

### Когда использовать:

|Сценарий|Рекомендуемый вариант|
|---|---|
|DTO, ViewModel, UI-модель|`string.Empty`|
|Entity EF Core|`default!`|
|Хотите инициализировать явно|`string.Empty`|
|Надо отключить warning от компилятора, но значение будет позже|`default!`|

---

### Резюме:

- `string.Empty` — безопаснее, потому что это пустая строка.
    
- `default!` — используется, чтобы подавить warning, если ты точно знаешь, что поле будет заполнено позже (например, EF Core при загрузке сущностей).
    

Если работаешь с **nullable reference types** (`#nullable enable`), это особенно важно.