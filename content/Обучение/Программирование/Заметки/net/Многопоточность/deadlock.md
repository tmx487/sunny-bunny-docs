**Deadlock (взаимная блокировка)** — ситуация в многопоточном программировании, когда два или более потока блокируются навсегда, ожидая ресурсы, которые удерживаются друг другом.

**Необходимые условия для возникновения deadlock:**

1. **Взаимное исключение** — ресурс может использоваться только одним потоком одновременно
2. **Удержание и ожидание** — поток, удерживающий ресурс, может запросить дополнительные ресурсы
3. **Отсутствие перехвата** — ресурсы не могут быть принудительно изъяты у потока
4. **Циклическое ожидание** — существует циклическая цепь потоков, где каждый ждет ресурс, удерживаемый следующим потоком в цепи

**Классический пример deadlock:**

```csharp
// Поток 1
lock (resourceA)
{
    Thread.Sleep(100); // Увеличивает вероятность deadlock
    lock (resourceB)
    {
        // Действия с обоими ресурсами
    }
}

// Поток 2
lock (resourceB)
{
    Thread.Sleep(100);
    lock (resourceA)
    {
        // Действия с обоими ресурсами
    }
}
```

**Почему возникает deadlock:**

1. Поток 1 получает блокировку resourceA
2. Поток 2 получает блокировку resourceB
3. Поток 1 пытается получить блокировку resourceB, но ждёт, потому что она удерживается потоком 2
4. Поток 2 пытается получить блокировку resourceA, но ждёт, потому что она удерживается потоком 1
5. Образуется циклическое ожидание, система "застревает"

**Стратегии предотвращения deadlock:**

1. **Порядок блокировок** — всегда запрашивайте блокировки в одинаковом порядке
2. **Таймауты** — используйте `Monitor.TryEnter` с таймаутом вместо бесконечного ожидания
3. **Избегайте вложенных блокировок** — переструктурируйте код, чтобы избежать необходимости во вложенных блокировках
4. **Используйте высокоуровневые механизмы синхронизации** — например, `ReaderWriterLockSlim`, `SemaphoreSlim` или TPL с `Task.WhenAll`

Deadlock — одна из самых сложных проблем в многопоточном программировании, поскольку она может возникать нерегулярно и трудно воспроизводима в отладочном режиме.