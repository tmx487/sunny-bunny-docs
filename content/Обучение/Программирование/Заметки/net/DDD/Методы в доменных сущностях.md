В **Domain Driven Design (DDD)** класс-сущность в **Domain слое** не содержит бизнес-логики, которая напрямую управляет процессами (такими как создание, обновление, удаление), а скорее **представляет состояние** и инварианты бизнес-объекта. Основная цель сущности в DDD — это **сохранение состояния и соблюдение инвариантов** бизнес-логики. Основные методы, которые могут быть в классе сущности в Domain слое, это те, которые связаны с соблюдением этих инвариантов и изменением состояния объекта.

### Разделение ответственности между Domain и Application слоями:

- **Domain слой**:
    
    - Содержит **сущности** (Entities), **значимые объекты** (Value Objects), **агрегаты** (Aggregates), **службы домена** (Domain Services), и **репозитории** (Repositories).
    - Содержит **бизнес-правила** и **инварианты**. Например, методы для проверки условий, которые должны быть выполнены для того, чтобы объект оставался в допустимом состоянии.
- **Application слой**:
    
    - **Координирует выполнение действий**, но не содержит бизнес-логики. Он использует методы, определенные в Domain слое, чтобы выполнить необходимые операции.
    - Включает **сервисы** (Application Services), которые инкапсулируют конкретные бизнес-процессы и операции, используя объекты из Domain слоя.

### Как это выглядит на практике:

#### 1. **Методы в классе-сущности (Domain слой)**

Методы в классе сущности должны быть сконцентрированы на **инвариантах** и **манипуляциях состоянием** сущности, но не на сложной логике бизнес-процессов. Например:

```csharp
public class Order
{
    public int Id { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public decimal TotalAmount { get; private set; }
    public OrderStatus Status { get; private set; }

    public Order(decimal totalAmount)
    {
        CreatedAt = DateTime.UtcNow;
        TotalAmount = totalAmount;
        Status = OrderStatus.New;
    }

    // Метод для изменения состояния заказа
    public void Cancel()
    {
        if (Status == OrderStatus.Shipped)
        {
            throw new InvalidOperationException("Cannot cancel a shipped order.");
        }

        Status = OrderStatus.Canceled;
    }

    // Другие методы, связанные с состоянием объекта и его инвариантами
}
```

- В этом примере метод `Cancel` гарантирует, что заказ не может быть отменен, если он уже отправлен, что является бизнес-правилом для этого заказа.

#### 2. **Методы в классе-сервисе (Application слой)**

Классы-сервисы в Application слое содержат более **высокоуровневую логику** и координируют выполнение операций, используя объекты из Domain слоя. Здесь обычно происходит **взаимодействие с репозиториями**, **вызов методов сущностей** и **композиция операций**.

```csharp
public class OrderService
{
    private readonly IOrderRepository _orderRepository;

    public OrderService(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    // Реализуем функциональность в Application слое
    public void CancelOrder(int orderId)
    {
        var order = _orderRepository.GetById(orderId);
        if (order == null)
        {
            throw new ArgumentException("Order not found.");
        }

        // Вызов метода сущности
        order.Cancel();
        
        _orderRepository.Save(order);
    }
}
```

- В `OrderService` вы координируете работу с репозиторием и выстраиваете логику (например, проверку наличия заказа), а затем вызываете метод `Cancel` на сущности `Order`, чтобы применить бизнес-логику.

#### 3. **Когда использовать методы в Domain и Application слоях:**

- В **Domain слое** методы должны касаться **изменения состояния сущности** и обеспечения её **инвариантности**.
- В **Application слое** методы должны координировать операции между различными частями системы, такие как **сервисы** и **репозитории**, и обеспечивать **бизнес-процессы** (например, заказ, подтверждение, обработка событий).

### Пример:

Предположим, у вас есть заказ, который может быть **оплачен** или **отменен**.

1. **Domain слой**:
    - В сущности `Order` будут методы для **отмены** заказа (`Cancel`), **платежа** и **проверки состояния**.

```csharp
public class Order
{
    public void Pay()
    {
        if (Status != OrderStatus.New)
        {
            throw new InvalidOperationException("Only new orders can be paid.");
        }

        Status = OrderStatus.Paid;
    }
    
    public void Cancel()
    {
        if (Status == OrderStatus.Paid)
        {
            throw new InvalidOperationException("Paid orders cannot be canceled.");
        }

        Status = OrderStatus.Canceled;
    }
}
```

2. **Application слой**:
    - В сервисе `OrderService` можно объединить несколько бизнес-операций, например, **оплату и отмену** заказа, и использовать методы из сущности `Order`.

```csharp
public class OrderService
{
    private readonly IOrderRepository _orderRepository;

    public OrderService(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public void ProcessOrderPayment(int orderId)
    {
        var order = _orderRepository.GetById(orderId);
        if (order == null)
        {
            throw new ArgumentException("Order not found.");
        }

        // Вызов метода сущности для выполнения действия
        order.Pay();
        _orderRepository.Save(order);
    }

    public void CancelOrder(int orderId)
    {
        var order = _orderRepository.GetById(orderId);
        if (order == null)
        {
            throw new ArgumentException("Order not found.");
        }

        // Вызов метода сущности для отмены заказа
        order.Cancel();
        _orderRepository.Save(order);
    }
}
```

### Заключение:

- В **Domain слое** находятся методы, которые отвечают за **состояние** и **бизнес-правила** сущности.
- В **Application слое** находятся более **высокоуровневые операции**, которые координируют использование этих методов и работу с внешними ресурсами (например, репозиториями).

Таким образом, **сущности** отвечают за соблюдение инвариантов и изменения состояния, а **сервисы** — за выполнение бизнес-процессов и координацию между различными компонентами системы.