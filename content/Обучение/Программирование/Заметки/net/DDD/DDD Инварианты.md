**Инвариант** — это условие или правило, которое **всегда должно быть истинным** для объекта или системы в любой момент времени, когда она находится в корректном состоянии. В контексте программирования и DDD инварианты помогают гарантировать, что состояние объекта или агрегата остается **валидным и согласованным** независимо от выполняемых операций.

---

### Примеры инвариантов

1. **Бизнес-правило**: У объекта заказа общая сумма должна быть равна сумме всех позиций заказа.
2. **Физическое ограничение**: Вес посылки не может быть отрицательным.
3. **Логическое правило**: У предмета должно быть непустое имя и описание.
4. **Отношения между объектами**: Дата окончания задачи не может быть раньше даты начала.

---

### Как инварианты реализуются в DDD?

В DDD инварианты гарантируются через методы и конструкторы агрегатов. Доступ к данным (например, через публичные свойства) ограничивается, чтобы нельзя было напрямую нарушить состояние объекта. Все изменения проходят через **методы**, которые проверяют инварианты.

---

#### Пример инварианта в DDD

**Сущность `Order`**:
```csharp
public class Order
{
    public Guid Id { get; private set; }
    public List<OrderItem> Items { get; private set; } = new();
    public decimal TotalPrice { get; private set; }

    public Order()
    {
        Id = Guid.NewGuid();
    }

    public void AddItem(OrderItem item)
    {
        if (item == null)
            throw new ArgumentNullException(nameof(item));

        Items.Add(item);
        RecalculateTotalPrice(); // Обеспечение инварианта
    }

    public void RemoveItem(OrderItem item)
    {
        if (item == null || !Items.Contains(item))
            throw new ArgumentException("Item not found in order.");

        Items.Remove(item);
        RecalculateTotalPrice(); // Обеспечение инварианта
    }

    private void RecalculateTotalPrice()
    {
        TotalPrice = Items.Sum(i => i.Price * i.Quantity);

        if (TotalPrice < 0)
            throw new InvalidOperationException("Total price cannot be negative."); // Инвариант
    }
}
```

##### Инварианты:
1. Общая сумма заказа (`TotalPrice`) всегда корректна и соответствует сумме всех позиций.
2. Общая сумма никогда не может быть отрицательной.

---

### Почему инварианты важны?

1. **Поддержание корректного состояния**:
   - Инварианты гарантируют, что объекты находятся в валидном состоянии, даже если бизнес-логика сложна.

2. **Снижение количества ошибок**:
   - Если объект всегда находится в валидном состоянии, риск неожиданных ошибок уменьшается.

3. **Читабельность и удобство сопровождения**:
   - Инварианты делают код более понятным. Любой, кто видит объект, знает, что его состояние всегда соответствует правилам.

---

### Где определяются инварианты?

- **В конструкторе**: Чтобы гарантировать валидное состояние сразу после создания объекта.
- **В методах**: Чтобы проверить состояние при каждом изменении объекта.
- **В доменных событиях (если используются)**: Чтобы реакции на события не нарушали инварианты.

Пример: Создание объекта `Subject` с инвариантами.
```csharp
public class Subject
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public string Description { get; private set; }

    public Subject(string name, string description)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name cannot be empty.");
        
        if (string.IsNullOrWhiteSpace(description))
            throw new ArgumentException("Description cannot be empty.");
        
        Id = Guid.NewGuid();
        Name = name;
        Description = description;
    }
}
```

Здесь инварианты гарантируют, что:
- `Name` и `Description` никогда не будут пустыми.
- `Id` всегда уникален.

---

### Что происходит, если инварианты нарушены?

1. **Ошибка в работе приложения**:
   - Нарушение инварианта может привести к некорректным расчетам, багам или даже падению приложения.

2. **Технический долг**:
   - Если инварианты не определены, может быть сложно найти и устранить источник проблемы.

3. **Сложность сопровождения**:
   - Состояние объектов становится непредсказуемым, что затрудняет разработку новых функций.

---