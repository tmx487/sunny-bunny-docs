Да, в приложении **Телефонная книга** можно использовать [[DDD Агрегат|агрегаты]], в зависимости от того, как ты структурируешь доменную модель и какие бизнес-правила и инварианты тебе нужно будет поддерживать. Давайте разберемся, как это может выглядеть и в каких случаях агрегаты могут быть полезны.

### Пример предметной области "Телефонная книга"

Предположим, что в твоем приложении для телефонной книги будут такие сущности, как **Контакт** и **Группа контактов**.

---

### Возможные агрегаты

#### 1. **Агрегат: Контакт (Contact)**

Контакт может быть главным объектом, через который осуществляется работа с телефонной книгой. Этот объект будет хранить информацию о человеке: имя, телефон, email, адрес и т.д.

**Корневой объект**: `Contact`

Составляющие части (дочерние объекты) — это все данные о контакте, например, телефонный номер или email.

```csharp
public class Contact
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public List<PhoneNumber> PhoneNumbers { get; private set; } = new();
    public List<Email> Emails { get; private set; } = new();

    public Contact(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name cannot be empty.");

        Id = Guid.NewGuid();
        Name = name;
    }

    public void AddPhoneNumber(string phoneNumber)
    {
        if (string.IsNullOrWhiteSpace(phoneNumber))
            throw new ArgumentException("Phone number cannot be empty.");

        // Инвариант: телефонный номер должен быть уникальным для контакта
        if (PhoneNumbers.Any(p => p.Number == phoneNumber))
            throw new InvalidOperationException("Phone number already exists for this contact.");

        PhoneNumbers.Add(new PhoneNumber(phoneNumber));
    }

    public void AddEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            throw new ArgumentException("Email cannot be empty.");

        // Инвариант: email должен быть уникальным для контакта
        if (Emails.Any(e => e.Address == email))
            throw new InvalidOperationException("Email already exists for this contact.");

        Emails.Add(new Email(email));
    }

    public void RemovePhoneNumber(string phoneNumber)
    {
        var phone = PhoneNumbers.SingleOrDefault(p => p.Number == phoneNumber);
        if (phone == null)
            throw new ArgumentException("Phone number not found.");
        
        PhoneNumbers.Remove(phone);
    }

    public void RemoveEmail(string email)
    {
        var emailObj = Emails.SingleOrDefault(e => e.Address == email);
        if (emailObj == null)
            throw new ArgumentException("Email not found.");
        
        Emails.Remove(emailObj);
    }
}

public class PhoneNumber
{
    public string Number { get; private set; }

    public PhoneNumber(string number)
    {
        Number = number;
    }
}

public class Email
{
    public string Address { get; private set; }

    public Email(string address)
    {
        Address = address;
    }
}
```

**Инварианты**:
- Контакт может иметь несколько телефонов или email-адресов.
- Каждый телефонный номер и email должны быть уникальными для каждого контакта.

---

#### 2. **Агрегат: Группа контактов (ContactGroup)**

Ты можешь создать агрегат для группировки контактов, например, для "Рабочих" или "Друзей". Группа контактов может содержать несколько контактов, и она будет отвечать за управление группами, добавление и удаление контактов из группы.

**Корневой объект**: `ContactGroup`

```csharp
public class ContactGroup
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public List<Contact> Contacts { get; private set; } = new List<Contact>();

    public ContactGroup(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name cannot be empty.");

        Id = Guid.NewGuid();
        Name = name;
    }

    public void AddContact(Contact contact)
    {
        if (contact == null)
            throw new ArgumentNullException(nameof(contact));

        // Инвариант: контакт не может быть добавлен дважды в группу
        if (Contacts.Contains(contact))
            throw new InvalidOperationException("Contact already exists in the group.");

        Contacts.Add(contact);
    }

    public void RemoveContact(Guid contactId)
    {
        var contact = Contacts.SingleOrDefault(c => c.Id == contactId);
        if (contact == null)
            throw new ArgumentException("Contact not found in the group.");

        Contacts.Remove(contact);
    }
}
```

**Инварианты**:
- Контакт не может быть добавлен дважды в одну группу.
- Группа может содержать несколько контактов, и добавление или удаление контактов происходит через методы агрегата.

---

### Преимущества использования агрегатов в "Телефонной книге"

1. **Гарантия согласованности данных**: 
   - Все изменения происходят через корневой объект (например, `Contact` или `ContactGroup`), что позволяет гарантировать, что данные остаются согласованными и инварианты соблюдаются.
   - Например, телефонные номера и email-адреса для контакта уникальны, и это проверяется внутри метода `AddPhoneNumber()` или `AddEmail()`.

2. **Единица транзакции**:
   - Изменения происходят внутри агрегата атомарно. То есть, если мы добавляем несколько контактов в группу, то все изменения происходят в рамках одной транзакции.

3. **Простота и изоляция бизнес-логики**:
   - Агрегаты обеспечивают изоляцию бизнес-логики и инвариантов. Весь код, который нарушает правила работы с данными (например, добавление одинакового номера телефона), находится внутри методов агрегата.

4. **Чистота архитектуры**:
   - Использование агрегатов помогает следовать принципам **Clean Architecture** и **DDD**, изолируя бизнес-логику в модели и минимизируя прямые зависимости между слоями.

---

### Когда агрегаты не нужны?

Если ты решишь, что бизнес-логика в твоем приложении "Телефонная книга" достаточно проста, то агрегаты могут быть избыточными. Например, если телефонная книга — это просто список контактов, и бизнес-правила минимальны (например, контакт может содержать любое количество телефонов и email-адресов), то можно обойтись без сложной структуры агрегатов. Однако при расширении функциональности, например, с добавлением групп контактов или дополнительных бизнес-правил, использование агрегатов будет более полезным.

---

### Пример использования

```csharp
public class PhoneBookExample
{
    public void Execute()
    {
        // Создание контактов
        var contact1 = new Contact("John Doe");
        contact1.AddPhoneNumber("+1-800-555-1234");
        contact1.AddEmail("john.doe@example.com");

        var contact2 = new Contact("Jane Smith");
        contact2.AddPhoneNumber("+1-800-555-5678");
        contact2.AddEmail("jane.smith@example.com");

        // Создание группы
        var friendsGroup = new ContactGroup("Friends");
        friendsGroup.AddContact(contact1);
        friendsGroup.AddContact(contact2);

        // Попытка добавить контакт дважды
        try
        {
            friendsGroup.AddContact(contact1); // Исключение: "Contact already exists in the group."
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        // Удаление контакта из группы
        friendsGroup.RemoveContact(contact1.Id);
    }
}
```

---

### Заключение

В твоем приложении "Телефонная книга" можно использовать агрегаты для **Контактов** и **Групп контактов**. Это помогает управлять бизнес-правилами, такими как уникальность телефонных номеров или email-адресов и предотвращение ошибок при добавлении контактов в группы. Если бизнес-логика усложняется (например, добавление тегов к контактам, история звонков и т.д.), использование агрегатов станет особенно полезным.