**

Министерство образования Республики Беларусь

Учреждение образования  
БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ  
ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ

Факультет компьютерного проектирования

Кафедра проектирования информационно-компьютерных систем

Рефакторинг и оптимизация программного кода

Отчет

по результатам выполнения задания к практическому занятию №1

на тему:

ОСНОВНЫЕ ПРОБЛЕМЫ И ОШИБКИ  
ПРИ НАПИСАНИИ ПРОГРАММНОГО КОДА

  
  
  
  
  
  
  
  
  
  

|   |   |   |
|---|---|---|
|Проверил||А.В. Шелест|
||(подпись)||
|зачтено|||
||(дата защиты)||
||||
|Выполнил|![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeVacq6VwWi8cIh0WlVMufCIXK6vDfjeOFhfuhP3-F3ZiTySA1hlueJxXtOm3hQF_O2qQCI50o0QXgZREPIzVQrVVtCQ1Xjpnsaq-ik7znh_pTESEeeYTPQCV_WY5bdnMd0QV76TTZlCE606ypVqAe89wg?key=VfXu5Z74bhNu7ogFtOGZlQ)|П.С. Лесак<br><br>гр. 114301|
||(подпись)||

  

Ссылка на репозиторий gitHub [https://github.com/polinaLesak/AstHelp](https://github.com/polinaLesak/AstHelp) 

При разработке программного обеспечения на C# с использованием DDD (Domain-Driven Design) и CQRS (Command Query Responsibility Segregation) могут возникать конкретные ошибки. Приведенные ниже примеры иллюстрируют частые проблемы и их потенциальные решения.

  

### 1. Неправильное моделирование доменной области

Неправильное определение агрегатов и границ контекста: В DDD агрегаты должны быть четко определены и инкапсулировать бизнес-логику. Ошибка может заключаться в объединении нескольких агрегатов в один, что приведет к нарушениям инвариантов и увеличению сложности транзакций. Также неверное определение границ контекста может привести к чрезмерной связанности между различными частями системы.

Игнорирование бизнес-правил: Важно, чтобы доменные модели точно отражали бизнес-правила и логику. Ошибки могут включать игнорирование специфичных бизнес-правил при разработке моделей или неправильную реализацию бизнес-логики в коде. Это может привести к несоответствию между реальными бизнес-процессами и их реализацией в системе.

  

Ошибка: Неправильное использование агрегатов

Пример:

public class Order

{

    public Guid Id { get; set; }

    public List<OrderItem> Items { get; set; }

    public decimal TotalAmount { get; set; }

  

    public void AddItem(OrderItem item)

    {

        Items.Add(item);

        TotalAmount += item.Price;

    }

}

  

В этом примере Order агрегирует список OrderItem, но OrderItem может изменяться независимо от Order, что нарушает инварианты агрегата.

Решение:

  

public class Order

{

    private List<OrderItem> _items = new List<OrderItem>();

    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();

    public decimal TotalAmount { get; private set; }

  

    public void AddItem(OrderItem item)

    {

        _items.Add(item);

        TotalAmount += item.Price;

    }

}

  

В этом исправленном коде Order управляет изменениями своих элементов через инкапсуляцию, что сохраняет целостность агрегата.

  

### 2. Неправильное применение CQRS

Избыточная сложность реализации: CQRS предполагает разделение команд и запросов, но это может привести к излишней сложности, если не обосновано. Примером может служить создание отдельного хранилища данных для команд и запросов, когда это не требуется. Это усложняет систему без реальной необходимости, что может увеличить время разработки и затруднить поддержку.

Неэффективная синхронизация данных: В CQRS, когда используется отдельное хранилище для команд и запросов, важно обеспечить синхронизацию данных между этими хранилищами. Ошибки могут возникнуть, если данные не синхронизируются корректно, что приведет к расхождению данных и несогласованности информации в системе.

Ошибка: Перемешивание команд и запросов

Пример:

public class OrderService

{

    private readonly ApplicationDbContext _context;

  

    public OrderService(ApplicationDbContext context)

    {

        _context = context;

    }

  

    public void CreateOrder(OrderDto orderDto)

    {

        var order = new Order { /* mapping from orderDto */ };

        _context.Orders.Add(order);

        _context.SaveChanges();

    }

  

    public OrderDto GetOrder(Guid id)

    {

        var order = _context.Orders.Find(id);

        return new OrderDto { /* mapping from order */ };

    }

}

  

В этом примере сервис выполняет как команды, так и запросы, что нарушает принципы CQRS.

Решение:

  

public class OrderCommandService

{

    private readonly ApplicationDbContext _context;

  

    public OrderCommandService(ApplicationDbContext context)

    {

        _context = context;

    }

  

    public void CreateOrder(Order order)

    {

        _context.Orders.Add(order);

        _context.SaveChanges();

    }

}

  

public class OrderQueryService

{

    private readonly ApplicationDbContext _context;

  

    public OrderQueryService(ApplicationDbContext context)

    {

        _context = context;

    }

  

    public OrderDto GetOrder(Guid id)

    {

        var order = _context.Orders.Find(id);

        return new OrderDto { /* mapping from order */ };

    }

}

  

Разделение команд и запросов на разные сервисы улучшает читаемость и поддержку кода.

  

### 3. Проблемы с производительностью и масштабируемостью 

### Неоптимизированные запросы и команды: Ошибки могут включать неоптимизированные запросы, которые избыточно нагружают базу данных. Например, выполнение сложных запросов с несколькими соединениями таблиц может замедлить выполнение. Также ошибки могут возникать, если команды выполняют слишком много логики в одном вызове, что приводит к долгому времени обработки.

### Избыточное использование ресурсов: Проблемы могут возникнуть из-за неэффективного использования ресурсов, например, частые обращения к базе данных или создание большого количества объектов в памяти. Это может привести к ухудшению производительности и увеличению времени отклика системы.

  

Ошибка: Неправильная обработка запросов в больших объемах данных

Пример:

public List<OrderDto> GetAllOrders()

{

    return _context.Orders.ToList().Select(o => new OrderDto { /* mapping */ }).ToList();

}

  

Этот код загружает все заказы в память, что может привести к проблемам с производительностью при большом объеме данных.

Решение:

  

public IEnumerable<OrderDto> GetAllOrders()

{

    return _context.Orders.AsNoTracking()

                          .Select(o => new OrderDto { /* mapping */ });

}

  

Использование AsNoTracking и возврат IEnumerable для ленивой загрузки данных помогает улучшить производительность.

  

### 4. Отсутствие четкой документации и тестирования

### Отсутствие документации по бизнес-логике и архитектуре: Недостаточная документация может затруднить понимание системы другими разработчиками и поддержание кода. Примером является отсутствие подробного описания взаимодействия между командами и запросами или неясное определение границ контекста.

### Неадекватное тестирование: Ошибки могут включать недостаточное тестирование как командных, так и запросных моделей. Например, если тестируются только успешные сценарии и не учитываются пограничные случаи или ошибки, это может привести к непредсказуемому поведению системы в реальных условиях.

  

Ошибка: Отсутствие тестов для бизнес-логики

Пример:

  

public class OrderService

{

    public void AddItemToOrder(Order order, OrderItem item)

    {

        order.AddItem(item);

        // Business logic here

    }

}

  

Если в коде нет тестов, это может привести к тому, что ошибки бизнес-логики будут обнаружены только на этапе эксплуатации.

Решение:

  

[TestClass]

public class OrderServiceTests

{

    [TestMethod]

    public void AddItemToOrder_ShouldUpdateOrderTotal()

    {

        // Arrange

        var order = new Order();

        var item = new OrderItem { Price = 100 };

        var service = new OrderService();

  

        // Act

        service.AddItemToOrder(order, item);

  

        // Assert

        Assert.AreEqual(100, order.TotalAmount);

    }

}

  

Написание тестов для проверки бизнес-логики помогает избежать ошибок и улучшает качество кода.

  

5. Проблемы с управлением состоянием и синхронизацией

Неверное управление состоянием: В системах с использованием CQRS важно правильно управлять состоянием моделей команд и запросов. Ошибки могут включать некорректное обновление состояния, что приводит к несогласованности между разными частями системы.

Ошибки в асинхронной обработке сообщений: При использовании брокеров сообщений, таких как ActiveMQ, могут возникнуть ошибки, связанные с асинхронной обработкой сообщений. Проблемы могут включать потерю сообщений, задержки или некорректную обработку сообщений, что приводит к нарушению функциональности системы.

  

Ошибка: Неправильное обновление состояния

Пример:

  

public void UpdateOrderStatus(Guid orderId, OrderStatus newStatus)

{

    var order = _context.Orders.Find(orderId);

    order.Status = newStatus;

    _context.SaveChanges();

}

  

Если состояние обновляется непосредственно в базе данных, могут возникать проблемы с согласованностью данных, особенно в распределенных системах.

Решение:

  

public void UpdateOrderStatus(Guid orderId, OrderStatus newStatus)

{

    var order = _context.Orders.Find(orderId);

    if (order.Status != newStatus)

    {

        order.Status = newStatus;

        _context.SaveChanges();

    }

}

  

Добавление проверки состояния перед обновлением помогает избежать ненужных операций и потенциальных проблем с согласованностью данных.

  

В заключение, правильное применение DDD и CQRS в C# требует тщательного проектирования и внимательного подхода к реализации. Избегание распространенных ошибок, таких как неправильное моделирование доменной области, неправильное применение CQRS, проблемы с производительностью и масштабируемостью, отсутствие тестирования и управление состоянием, поможет создать надежную и эффективную систему.

**