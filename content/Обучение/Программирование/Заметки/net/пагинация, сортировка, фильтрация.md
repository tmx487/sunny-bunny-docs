Для реализации пагинации, фильтрации и сортировки на сервере в .NET существуют проверенные подходы и паттерны, которые позволяют достичь высокой производительности и гибкости. Вот несколько рекомендаций и best practices, которые используют профессиональные разработчики:

### 1. Пагинация

#### Простая пагинация

Для простой пагинации обычно передаются два параметра: `page` и `pageSize`.

**Пример**:

```csharp
public class PagedResult<T>
{
    public IEnumerable<T> Items { get; set; }
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
}

public class PaginationParams
{
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 10;
}

public static class IQueryableExtensions
{
    public static async Task<PagedResult<T>> ToPagedResultAsync<T>(this IQueryable<T> query, PaginationParams paginationParams)
    {
        var totalCount = await query.CountAsync();
        var items = await query.Skip((paginationParams.Page - 1) * paginationParams.PageSize)
                                .Take(paginationParams.PageSize)
                                .ToListAsync();

        return new PagedResult<T>
        {
            Items = items,
            TotalCount = totalCount,
            Page = paginationParams.Page,
            PageSize = paginationParams.PageSize
        };
    }
}
```

#### Использование в контроллере

```csharp
[HttpGet]
public async Task<IActionResult> GetProducts([FromQuery] PaginationParams paginationParams)
{
    var query = _context.Products.AsQueryable();
    var pagedResult = await query.ToPagedResultAsync(paginationParams);
    return Ok(pagedResult);
}
```

### 2. Фильтрация

Фильтрация данных обычно осуществляется через передачу параметров фильтрации в запросе.

**Пример**:

```csharp
public class ProductFilterParams
{
    public string Name { get; set; }
    public decimal? MinPrice { get; set; }
    public decimal? MaxPrice { get; set; }
}

public static class IQueryableExtensions
{
    public static IQueryable<Product> ApplyFilter(this IQueryable<Product> query, ProductFilterParams filterParams)
    {
        if (!string.IsNullOrEmpty(filterParams.Name))
        {
            query = query.Where(p => p.Name.Contains(filterParams.Name));
        }

        if (filterParams.MinPrice.HasValue)
        {
            query = query.Where(p => p.Price >= filterParams.MinPrice.Value);
        }

        if (filterParams.MaxPrice.HasValue)
        {
            query = query.Where(p => p.Price <= filterParams.MaxPrice.Value);
        }

        return query;
    }
}
```

#### Использование в контроллере

```csharp
[HttpGet]
public async Task<IActionResult> GetProducts([FromQuery] ProductFilterParams filterParams, [FromQuery] PaginationParams paginationParams)
{
    var query = _context.Products.AsQueryable();
    query = query.ApplyFilter(filterParams);
    var pagedResult = await query.ToPagedResultAsync(paginationParams);
    return Ok(pagedResult);
}
```

### 3. Сортировка

Сортировка данных обычно осуществляется через передачу параметра `sortBy` и опционального параметра `sortOrder`.

**Пример**:

```csharp
public class SortParams
{
    public string SortBy { get; set; }
    public string SortOrder { get; set; } = "asc";
}

public static class IQueryableExtensions
{
    public static IQueryable<T> ApplySort<T>(this IQueryable<T> query, SortParams sortParams)
    {
        if (!string.IsNullOrEmpty(sortParams.SortBy))
        {
            var propertyInfo = typeof(T).GetProperty(sortParams.SortBy, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance);
            if (propertyInfo != null)
            {
                query = sortParams.SortOrder.ToLower() == "desc"
                    ? query.OrderByDescending(e => propertyInfo.GetValue(e, null))
                    : query.OrderBy(e => propertyInfo.GetValue(e, null));
            }
        }

        return query;
    }
}
```

#### Использование в контроллере

```csharp
[HttpGet]
public async Task<IActionResult> GetProducts([FromQuery] ProductFilterParams filterParams, [FromQuery] PaginationParams paginationParams, [FromQuery] SortParams sortParams)
{
    var query = _context.Products.AsQueryable();
    query = query.ApplyFilter(filterParams);
    query = query.ApplySort(sortParams);
    var pagedResult = await query.ToPagedResultAsync(paginationParams);
    return Ok(pagedResult);
}
```

### 4. Комбинирование всех трех аспектов

Чтобы сделать код более чистым и избежать повторения, можно объединить все расширения в один метод.

```csharp
public static class IQueryableExtensions
{
    public static async Task<PagedResult<T>> ApplyPaginationFilterSort<T>(this IQueryable<T> query, ProductFilterParams filterParams, PaginationParams paginationParams, SortParams sortParams)
    {
        query = query.ApplyFilter(filterParams);
        query = query.ApplySort(sortParams);

        var totalCount = await query.CountAsync();
        var items = await query.Skip((paginationParams.Page - 1) * paginationParams.PageSize)
                                .Take(paginationParams.PageSize)
                                .ToListAsync();

        return new PagedResult<T>
        {
            Items = items,
            TotalCount = totalCount,
            Page = paginationParams.Page,
            PageSize = paginationParams.PageSize
        };
    }
}
```

#### Использование в контроллере

```csharp
[HttpGet]
public async Task<IActionResult> GetProducts([FromQuery] ProductFilterParams filterParams, [FromQuery] PaginationParams paginationParams, [FromQuery] SortParams sortParams)
{
    var query = _context.Products.AsQueryable();
    var pagedResult = await query.ApplyPaginationFilterSort(filterParams, paginationParams, sortParams);
    return Ok(pagedResult);
}
```

### Заключение

Этот подход позволяет легко реализовать пагинацию, фильтрацию и сортировку данных на сервере. Он гибкий и расширяемый, что делает его идеальным для использования в RESTful API.