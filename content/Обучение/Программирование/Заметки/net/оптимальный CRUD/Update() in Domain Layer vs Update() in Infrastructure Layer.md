### **1. Что делает метод `Update()` в агрегате (доменном объекте)?**

Метод `Update()` внутри доменного объекта отвечает **только за бизнес-логику** и изменение **состояния объекта в памяти**. Это важно, так как:

- Доменные сущности не знают о базах данных, API или другой инфраструктуре. Они просто представляют бизнес-сущности и правила, которые к ним применимы.
- Состояние агрегата (например, свойства `Name` и `Description`) изменяется в процессе выполнения бизнес-логики. Однако само изменение еще не зафиксировано в базе данных.

> **Пример**: Ты обновляешь имя и описание объекта `Subject` в оперативной памяти, но еще не сохраняешь это в базе данных.

---

### **2. Что делает метод `Update()` в репозитории?**

Метод `Update()` в репозитории отвечает за взаимодействие с базой данных или другой инфраструктурой для сохранения изменений.

- Он берет **уже измененный объект**, который был модифицирован на уровне доменной логики, и отправляет эти изменения в базу данных.
- Репозиторий сам по себе **не должен менять состояние объекта**. Он только отвечает за его извлечение и сохранение.

> **Пример**: Ты вызываешь `repo.Update(subject)`, чтобы сохранить изменения объекта `Subject` в базе данных.

---

### **3. Почему метод `Update()` в агрегате и в репозитории — это не одно и то же?**

#### **Метод в агрегате (`Subject`)**:

- Работает **внутри доменного слоя**.
- Меняет состояние объекта **в оперативной памяти**.
- Проверяет инварианты (например, нельзя установить пустое имя).
- Добавляет доменные события (если нужно).

#### **Метод в репозитории**:

- Работает **на уровне инфраструктуры**.
- Сохраняет изменения в **базе данных** или другой системе хранения.
- Знает, как преобразовать доменные объекты в формат, подходящий для базы данных.


# Answer #2

Хороший вопрос! Давай разберем, в чем разница между методом `Update()` в агрегате (`Subject`) и методом `Update()` в репозитории.

---

### Различие между `Update()` в агрегате и репозитории

1. **`Update()` в агрегате (например, `Subject`)**
   - Это **бизнес-операция**: метод, который изменяет состояние объекта в памяти, а не в базе данных.
   - Он предназначен для соблюдения инвариантов агрегата и применения бизнес-логики.
   - Пример: изменение имени или описания предмета с проверкой на корректность.

2. **`Update()` в репозитории**
   - Это **операция на уровне инфраструктуры**: метод, который отвечает за сохранение (или обновление) агрегата в базе данных.
   - Репозиторий никак не связан с бизнес-логикой агрегата, он просто переносит текущее состояние объекта в базу данных.

---

### Пример: Разница в действиях

#### **1. Метод `Update()` в агрегате**

Этот метод отвечает только за изменение состояния объекта в памяти.

```csharp
public class Subject : AggregateRoot
{
    public string Name { get; private set; }
    public string Description { get; private set; }

    public void Update(string name, string description)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name cannot be empty.");

        if (string.IsNullOrWhiteSpace(description))
            throw new ArgumentException("Description cannot be empty.");

        Name = name;
        Description = description;

        AddDomainEvent(new SubjectUpdatedEvent(this.Id));
    }
}
```

- Этот метод:
  - Проверяет бизнес-правила (например, имя не может быть пустым).
  - Обновляет свойства объекта.
  - Добавляет доменное событие, чтобы другие части системы могли узнать о произошедшем.

Однако **данные в базе данных не обновляются** — объект просто модифицируется в оперативной памяти.

---

#### **2. Метод `Update()` в репозитории**

Этот метод отвечает за сохранение изменений объекта в базу данных.

```csharp
public class SubjectRepository : ISubjectRepository
{
    private readonly AppDbContext _context;

    public SubjectRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task UpdateAsync(Subject subject)
    {
        _context.Subjects.Update(subject);
        await _context.SaveChangesAsync();
    }
}
```

- Этот метод:
  - Получает агрегат (например, `Subject`), у которого уже изменены свойства.
  - Сохраняет эти изменения в базе данных, используя ORM (например, EF Core).
  - **Не проверяет бизнес-правила**, так как это задача агрегата.

---

### Как они работают вместе?

1. **Бизнес-логика:**
   - Клиент (например, Use Case) вызывает метод `Update()` на объекте `Subject`, чтобы изменить его состояние, проверяя бизнес-правила.

2. **Сохранение изменений:**
   - После выполнения бизнес-логики клиент передает агрегат в репозиторий, чтобы изменения были зафиксированы в базе данных.

Пример:
```csharp
public class UpdateSubjectUseCase
{
    private readonly ISubjectRepository _repository;

    public UpdateSubjectUseCase(ISubjectRepository repository)
    {
        _repository = repository;
    }

    public async Task ExecuteAsync(Guid subjectId, string newName, string newDescription)
    {
        // 1. Получаем агрегат
        var subject = await _repository.GetByIdAsync(subjectId);
        if (subject == null)
            throw new NotFoundException("Subject not found.");

        // 2. Обновляем состояние агрегата
        subject.Update(newName, newDescription);

        // 3. Сохраняем изменения через репозиторий
        await _repository.UpdateAsync(subject);
    }
}
```

---

### Почему разделение важно?

1. **SRP (Принцип единственной ответственности)**:
   - Агрегат отвечает за бизнес-логику и состояние.
   - Репозиторий отвечает за взаимодействие с базой данных.

2. **Изоляция бизнес-логики**:
   - Агрегат можно использовать независимо от способа сохранения данных (например, в памяти, в БД, в файле).

3. **Тестируемость**:
   - Вы можете тестировать метод `Update()` агрегата без зависимости от базы данных.

---

### А как это связано с DDD?

В **DDD** агрегат — это объект, который:
1. **Содержит бизнес-логику**: В нем реализованы все проверки и операции, связанные с изменением состояния.
2. **Контролирует консистентность**: Внутри агрегата нельзя нарушить инварианты.

Метод `Update()` в репозитории лишь сохраняет уже проверенные и измененные данные агрегата. Он не имеет доступа к бизнес-логике и просто фиксирует текущее состояние объекта.

---
