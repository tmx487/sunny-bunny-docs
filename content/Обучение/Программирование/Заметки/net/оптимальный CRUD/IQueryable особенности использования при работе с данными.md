Давай разберемся, почему в случае с `IQueryable<T>` не возникает исключений, даже если данные не загружены в память (например, если ты строишь запрос, но еще не выполняешь его).

### Важное отличие: `IQueryable<T>` и выполнение запросов

1. **`IQueryable<T>` — это не сам набор данных**:
   - Когда ты используешь `IQueryable<T>`, ты **не работаешь напрямую с данными**. Ты на самом деле создаешь выражение запроса (или цепочку операций), которое будет выполнено только в момент, когда ты решишь извлечь данные (например, вызвав `ToList()`, `ToListAsync()`, `FirstOrDefault()`, и т.д.).
   - `IQueryable<T>` представляет собой **конвейер для построения запроса**, а не сами данные. Запрос сам по себе не выполняет загрузку данных, пока не будет явно вызван.

2. **Отложенное выполнение (Lazy Evaluation)**:
   - `IQueryable<T>` использует принцип **отложенного выполнения**. Это означает, что запрос будет выполняться только в момент, когда ты запросишь данные (например, когда вызовешь `ToListAsync()`, или выполнится другой метод, который требует данных).
   - Если ты строишь запрос и не выполняешь его, данные из базы данных **не извлекаются**, и соответственно исключений не возникает, потому что ты просто собираешь цепочку операций, а не работаешь с реальными данными.

3. **Запросы не выполняются без необходимости**:
   - При использовании `IQueryable<T>`, операции, такие как `Where()`, `OrderBy()`, и другие, просто создают новые выражения. Например, метод `Where()` добавляет фильтрацию в запрос, но не выполняет его сразу.
   - Только когда ты вызываешь метод, который фактически выполняет запрос (например, `ToListAsync()`), EF Core переводит это выражение в SQL-запрос, отправляет его в базу данных и выполняет запрос.

### Почему нет исключений?

1. **Запросы не выполняются в момент создания**:
   - Пока ты не вызвал метод вроде `ToListAsync()`, `FirstOrDefault()`, или `Count()`, сам запрос не выполняется. Ты не работаешь с реальными данными в памяти, и, следовательно, **не возникает ситуации, когда ты работаешь с `null`**.
   - Например, когда ты вызываешь `Where()`, это не означает, что данные будут сразу загружены в память. Это просто создание нового запроса, который будет выполнен позже.

2. **Если данных нет, ошибка не будет до выполнения запроса**:
   - Если в запросе есть операция, которая может вызвать ошибку (например, обращение к несуществующему полю или неправильное соединение), исключение возникнет **только при выполнении запроса** (когда ты вызовешь метод вроде `ToListAsync()`, и SQL-запрос будет отправлен в базу данных).
   - Пока запрос не выполняется, ты просто строишь логическое выражение, которое EF Core переведет в SQL.

3. **Работа с `null` не приводит к ошибке**:
   - Если данные для запроса не найдены, то результат запроса будет пустым, но никаких исключений не произойдет. Например, если в запросе нет записей, то `ToListAsync()` просто вернет пустой список, а не вызовет ошибку.
   - Если данные вообще не могут быть найдены (например, ошибка в запросе), исключение произойдет **только при выполнении запроса**, когда ты попытаешься получить доступ к результатам.

### Пример:

```csharp
public async Task<IEnumerable<Contact>> GetContactsAsync(string searchTerm)
{
    IQueryable<Contact> query = _context.Contacts;

    // Строим запрос с фильтрацией
    if (!string.IsNullOrEmpty(searchTerm))
    {
        query = query.Where(c => c.Name.Contains(searchTerm));
    }

    // Запрос еще не выполнен, и никаких исключений не возникает
    return await query.ToListAsync();  // Только здесь будет выполнен запрос к базе данных
}
```

### Разбор:

1. **`IQueryable<Contact>`**:
   - На момент, когда мы создаем запрос с помощью `Where()`, мы еще не выполняем запрос. Это просто выражение запроса, которое будет передано в базу данных при вызове `ToListAsync()`.
   - Никакие данные не загружаются в память, исключений не возникает.

2. **`await query.ToListAsync()`**:
   - Когда ты вызываешь `ToListAsync()`, EF Core строит SQL-запрос на основе операций, которые были добавлены к `IQueryable`, и отправляет запрос в базу данных.
   - Если данных нет, просто возвращается пустой список. Если запрос некорректный (например, неправильная колонка или ошибка в связи), исключение будет выброшено на момент выполнения запроса.

### Важные моменты:

- **Отложенное выполнение** (`Lazy Evaluation`) — запрос не выполняется до тех пор, пока ты не запросишь результат.
- **Строение запроса** — при построении запросов через `IQueryable<T>` нет реального взаимодействия с базой данных, исключений не возникает, пока ты не попытаешься получить данные.
- **Реальное выполнение запроса** — исключения могут возникать только при фактическом выполнении запроса, например, при вызове `ToListAsync()` или `FirstOrDefaultAsync()`.