
В реальной производственной среде дедлоки могут возникать при обработке заказов в интернет-магазине. Рассмотрим конкретный сценарий:

## Ситуация

Представим систему обработки заказов в интернет-магазине с микросервисной архитектурой, где есть два параллельных процесса:

**Процесс обработки платежа:**

```sql
BEGIN TRANSACTION;
-- Блокирует запись о заказе для обновления статуса оплаты
UPDATE orders SET payment_status = 'processing' WHERE order_id = 12345;

-- Здесь происходит обращение к платежному шлюзу, которое занимает некоторое время

-- Пытается обновить информацию о товаре (уменьшить количество)
UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 789;
COMMIT;
```

**Процесс резервирования товара:**

```sql
BEGIN TRANSACTION;
-- Блокирует запись о товаре для резервирования
UPDATE inventory SET reserved = reserved + 1 WHERE product_id = 789;

-- Здесь происходит проверка доступности на складе, которая занимает время

-- Пытается обновить статус заказа
UPDATE orders SET inventory_status = 'reserved' WHERE order_id = 12345;
COMMIT;
```

## Что происходит

1. Сервис платежей блокирует запись в таблице `orders` для заказа #12345
2. Одновременно сервис инвентаря блокирует запись в таблице `inventory` для товара #789
3. Сервис платежей пытается обновить данные в таблице `inventory`, но не может, так как эта запись заблокирована
4. Сервис инвентаря пытается обновить данные в таблице `orders`, но не может, так как эта запись заблокирована

В результате оба сервиса ждут друг друга, и обработка заказа останавливается.

## Последствия в реальных системах

Такой дедлок может привести к:

- "Зависанию" заказов клиентов
- Постепенному исчерпанию пула соединений к базе данных
- Увеличению времени отклика системы
- В итоге может произойти каскадный сбой всей системы обработки заказов

## Решения

В реальных системах для предотвращения подобных дедлоков применяют:

1. Упорядочение доступа к ресурсам (всегда сначала блокировать orders, потом inventory)
2. Использование механизма обнаружения дедлоков СУБД с откатом одной из транзакций
3. Установка таймаутов блокировок
4. Переход к оптимистичной блокировке вместо пессимистичной
5. Использование очередей сообщений для асинхронной обработки