В Prometheus существуют четыре основных типа метрик, каждый из которых предназначен для измерения разных видов данных. Понимание этих типов крайне важно для правильной настройки приложения и эффективного анализа собранных данных.

Виды метрик:

### 1. Counter (Счетчик)

- **Что это:** Это монотонно возрастающая числовая метрика. Ее значение может только увеличиваться или сбрасываться до нуля при перезапуске приложения (или по другим специфическим условиям, например, сброс метрик).

- **Для чего используется:** Идеально подходит для подсчета событий, которые происходят с течением времени и накапливаются.

- **Примеры:**
    - `http_requests_total`: Общее количество полученных HTTP-запросов.
    - `errors_total`: Общее количество произошедших ошибок.
    - `tasks_completed_total`: Общее количество завершенных задач.
    - `users_registered_total`: Общее количество зарегистрированных пользователей.

- **Как анализировать:** Само по себе абсолютное значение счетчика часто не так информативно. Гораздо полезнее смотреть на **скорость изменения (rate)** счетчика за определенный период времени, чтобы понять, сколько событий произошло за этот период (например, `rate(http_requests_total[5m])` покажет количество запросов в секунду за последние 5 минут).

### 2. Gauge (Датчик)

- **Что это:** Это метрика, представляющая собой одиночное числовое значение, которое может **произвольно увеличиваться и уменьшаться**.

- **Для чего используется:** Для измерения текущего состояния чего-либо.

- **Примеры:**
    - `memory_usage_bytes`: Текущее использование памяти приложением.
    - `active_connections`: Количество активных сетевых соединений.
    - `cpu_temperature_celsius`: Текущая температура CPU.
    - `queue_length`: Текущее количество элементов в очереди.

- **Как анализировать:** Значение датчика показывает текущее состояние на момент скрапинга. Вы можете строить графики изменения этого значения со временем, чтобы видеть тренды, пики и провалы.

### 3. Histogram (Гистограмма)

- **Что это:** Более сложный тип метрики, предназначенный для **сэмплирования (наблюдения) распределения значений**, таких как продолжительность запросов или размеры ответов. Гистограмма **группирует наблюдаемые значения в настраиваемые "бакеты" (buckets)**.

- **Как это работает:** Гистограмма экспортирует несколько временных рядов:
    - `_bucket`: Кумулятивные счетчики для каждого бакета, указывающие, сколько наблюдений попало в каждый бакет (меньше или равно верхней границе бакета).
    - `_sum`: Сумма всех наблюдаемых значений.
    - `_count`: Общее количество наблюдений (этот счетчик эквивалентен бакету `+Inf`, который содержит все наблюдения).

- **Для чего используется:** Идеально подходит для анализа задержек (latency), размеров файлов, объемов данных и всего, что имеет распределение значений. Позволяет понять, сколько запросов укладываются в определенные временные диапазоны, и оценить перцентили (например, 90-й или 99-й перцентиль времени ответа).

- **Примеры:**
    - `http_request_duration_seconds`: Время выполнения HTTP-запросов.
    - `database_query_duration_seconds`: Время выполнения запросов к базе данных.

- **Как анализировать:** Используя данные гистограммы, можно вычислять перцентили (например, `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))`), строить тепловые карты (heatmap) распределения задержек и определять аномалии.

### 4. Summary (Сводка)


- **Что это:** Похож на гистограмму, но вместо предоставления бакетов для самостоятельного расчета перцентилей на стороне Prometheus, **Summary вычисляет настраиваемые квантили (перцентили) на стороне клиента (в самом приложении) за скользящее окно времени**.

- **Как это работает:** Summary также экспортирует `_sum` (сумма всех наблюдений) и `_count` (количество наблюдений), как и гистограмма. Дополнительно, он экспортирует метрики для каждого сконфигурированного квантиля (например, `http_request_duration_seconds{quantile="0.99"}`).

- **Для чего используется:** Также для измерения распределения значений, но с предварительно рассчитанными перцентилями.

- **Примеры:**
    - `rpc_duration_seconds`: Длительность RPC-вызовов с уже рассчитанными 0.01, 0.05, 0.5, 0.9, 0.99 квантилями.

- **Histogram vs Summary:**
    
	- **Histogram** является более предпочтительным, если вам нужна точная агрегация перцентилей по нескольким экземплярам приложения или по времени. Вы определяете бакеты, и Prometheus рассчитывает перцентили на основе этих бакетов. Это позволяет объединять данные из разных источников и получать точные глобальные перцентили.
    
	- **Summary** рассчитывает перцентили на стороне клиента (в самом приложении) за скользящее окно времени. Это менее ресурсоемко для Prometheus, но имеет существенный недостаток: квантили из разных экземпляров (или с разных периодов времени) **нельзя точно агрегировать** друг с другом. Если у вас несколько инстансов приложения, и вы хотите узнать 99-й перцентиль задержки для всего сервиса, Summary вам не подойдет, поскольку усреднение 99-х перцентилей с разных инстансов не даст истинный 99-й перцентиль для всего сервиса.

В большинстве современных сценариев **предпочтительным выбором для измерения распределений является Histogram**, так как он обеспечивает большую гибкость и точность при агрегации данных. Summary чаще используется для более простых случаев, где не требуется точная агрегация перцентилей между несколькими источниками.