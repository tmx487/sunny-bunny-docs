В C# существует несколько способов получения результатов асинхронной операции:

1. **Task/Task\<T> с async/await** (современный и рекомендуемый подход):
    
    ```csharp
    async Task DoWorkAsync()
    {
        try
        {
            // Ожидание результата асинхронной операции
            var result = await SomeAsyncOperation();
            Console.WriteLine($"Результат: {result}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка: {ex.Message}");
        }
    }
    ```
    
2. **Продолжения задач (Task Continuations)**:
    
    ```csharp
    SomeAsyncOperation()
        .ContinueWith(task => 
        {
            if (task.IsFaulted)
                Console.WriteLine($"Ошибка: {task.Exception.InnerException.Message}");
            else
                Console.WriteLine($"Результат: {task.Result}");
        });
    ```
    
3. **Ожидание завершения задачи**:
    
    ```csharp
    Task<string> task = SomeAsyncOperation();
    // Блокирующее ожидание (не рекомендуется в UI-потоке)
    string result = task.Result; // или task.GetAwaiter().GetResult();
    ```
    
4. **События (Events) и шаблон асинхронной модели на основе событий (EAP)**:
    
    ```csharp
    // Старый подход, менее распространен в современном C#
    someObject.OperationCompleted += (sender, e) => 
    {
        Console.WriteLine($"Результат: {e.Result}");
    };
    someObject.StartOperation();
    ```
    
5. **IAsyncEnumerable\<T>** (C# 8.0+) для асинхронных потоков данных:
    
    ```csharp
    async Task ProcessDataAsync()
    {
        await foreach (var item in GetAsyncDataStream())
        {
            Console.WriteLine($"Получен элемент: {item}");
        }
    }
    ```
    

В современной разработке на C# наиболее рекомендуемым подходом является использование `Task/Task<T>` с ключевыми словами async/await, которые делают асинхронный код похожим на синхронный, сохраняя при этом его неблокирующую природу.