**Коллизия** - когда разные ключи дают одинаковый хеш-код и попадают в одну ячейку [[Хеш-таблица|хеш-таблицы]].

```csharp
// Пример коллизии
string key1 = "ABC";
string key2 = "BCD"; 
// Могут дать одинаковый хеш (упрощенно)
```

## Как работает Dictionary внутри

```csharp
// Упрощенная схема Dictionary
internal struct Entry
{
    public int hashCode;    // Хеш ключа
    public int next;        // Ссылка на следующий элемент в цепочке
    public TKey key;        // Сам ключ
    public TValue value;    // Значение
}

private Entry[] entries;    // Массив элементов
private int[] buckets;      // Массив "корзин" (индексы в entries)
```

О buckets читай в [[buckets]].
## Методы разрешения коллизий в .NET

### 1. Метод цепочек (Chaining)

**Как работает**: элементы с одинаковым хешем связываются в список.

```csharp
// Когда происходит коллизия:
// Bucket[5] -> Entry1 -> Entry2 -> Entry3 -> null
//              hash=X    hash=X    hash=X
```

**Плюсы**:

- Простота реализации
- Хорошо работает при умеренном количестве коллизий

**Минусы**:

- При многих коллизиях поиск становится O(n)
- Дополнительная память на указатели

### 2. Открытая адресация (Open Addressing)

.NET использует **квадратичное пробирование**:

```csharp
// Алгоритм поиска свободной ячейки
int originalIndex = hash % buckets.Length;
int probe = 1;

while (buckets[index] != null)
{
    index = (originalIndex + probe * probe) % buckets.Length;
    probe++;
}
```

## Причины плохих коллизий

### 1. Плохой GetHashCode()

```csharp
// ПЛОХО - все объекты дают одинаковый хеш
public class BadUser
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public override int GetHashCode()
    {
        return 42; // Катастрофа!
    }
}

// ПЛОХО - только одно поле
public override int GetHashCode()
{
    return Name?.GetHashCode() ?? 0; // Игнорирует Age
}

// ПЛОХО - простое сложение
public override int GetHashCode()
{
    return Name.GetHashCode() + Age.GetHashCode(); // "AB" + 1 == "A" + "B1"
}
```

### 2. Предсказуемые паттерны ключей

```csharp
// Много коллизий из-за паттерна
for (int i = 0; i < 1000; i++)
{
    dict[$"user_{i * 100}"] = data; // user_0, user_100, user_200...
}
```

## Как правильно реализовать GetHashCode()

### 1. Используйте HashCode.Combine (.NET Core 2.1+)

```csharp
public class User
{
    public string Name { get; set; }
    public int Age { get; set; }
    public DateTime BirthDate { get; set; }
    
    public override int GetHashCode()
    {
        return HashCode.Combine(Name, Age, BirthDate);
    }
    
    public override bool Equals(object obj)
    {
        if (obj is User other)
        {
            return Name == other.Name && 
                   Age == other.Age && 
                   BirthDate == other.BirthDate;
        }
        return false;
    }
}
```

### 2. Для старых версий .NET

```csharp
public override int GetHashCode()
{
    unchecked // Разрешаем переполнение
    {
        int hash = 17;
        hash = hash * 23 + (Name?.GetHashCode() ?? 0);
        hash = hash * 23 + Age.GetHashCode();
        hash = hash * 23 + BirthDate.GetHashCode();
        return hash;
    }
}
```

### 3. Для readonly struct

```csharp
public readonly struct Point
{
    public readonly int X, Y;
    
    public Point(int x, int y) => (X, Y) = (x, y);
    
    public override int GetHashCode() => HashCode.Combine(X, Y);
    
    public override bool Equals(object obj) => 
        obj is Point other && X == other.X && Y == other.Y;
}
```

## Диагностика коллизий

### 1. Измерение распределения

```csharp
public static void AnalyzeHashDistribution<T>(IEnumerable<T> keys)
{
    var hashGroups = keys
        .GroupBy(k => k.GetHashCode())
        .Select(g => g.Count())
        .ToList();
    
    Console.WriteLine($"Уникальных хешей: {hashGroups.Count}");
    Console.WriteLine($"Максимальная коллизия: {hashGroups.Max()}");
    Console.WriteLine($"Средняя коллизия: {hashGroups.Average():F2}");
    
    // Хорошее распределение: большинство групп размером 1
    var collisions = hashGroups.Count(count => count > 1);
    Console.WriteLine($"Групп с коллизиями: {collisions}");
}
```

### 2. Профилирование производительности

```csharp
var dict = new Dictionary<BadKey, string>();
var stopwatch = Stopwatch.StartNew();

// Заполняем
for (int i = 0; i < 100000; i++)
{
    dict[new BadKey(i)] = $"value{i}";
}

Console.WriteLine($"Добавление: {stopwatch.ElapsedMilliseconds}ms");

stopwatch.Restart();

// Поиск
for (int i = 0; i < 100000; i++)
{
    var exists = dict.ContainsKey(new BadKey(i));
}

Console.WriteLine($"Поиск: {stopwatch.ElapsedMilliseconds}ms");
```

## Решения проблем коллизий

### 1. Выбор правильного типа ключа

```csharp
// Плохо - строки с паттерном
var cache = new Dictionary<string, Data>();
for (int i = 0; i < 10000; i++)
{
    cache[$"item_{i}"] = new Data();
}

// Лучше - числовые ключи
var cache = new Dictionary<int, Data>();
for (int i = 0; i < 10000; i++)
{
    cache[i] = new Data();
}

// Или оптимизированный StringComparer
var cache = new Dictionary<string, Data>(StringComparer.Ordinal);
```

### 2. Кастомные IEqualityComparer

```csharp
public class CaseInsensitiveComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y)
    {
        return string.Equals(x, y, StringComparison.OrdinalIgnoreCase);
    }
    
    public int GetHashCode(string obj)
    {
        return obj?.ToUpperInvariant().GetHashCode() ?? 0;
    }
}

// Использование
var dict = new Dictionary<string, int>(new CaseInsensitiveComparer());
```

### 3. Правильный размер словаря

```csharp
// Плохо - постоянные resize и перехеширование
var dict = new Dictionary<string, int>();

// Хорошо - заранее выделяем память
var dict = new Dictionary<string, int>(capacity: 10000);

// Или используем конструктор с начальными данными
var dict = items.ToDictionary(x => x.Key, x => x.Value);
```

## Альтернативы Dictionary при многих коллизиях

```csharp
// 1. SortedDictionary для стабильной производительности O(log n)
var sorted = new SortedDictionary<string, int>();

// 2. ConcurrentDictionary с лучшим распределением
var concurrent = new ConcurrentDictionary<string, int>();

// 3. Специализированные коллекции
var frozen = data.ToFrozenDictionary(); // .NET 8+
```

**Ключевое правило**: всегда переопределяйте `GetHashCode()` и `Equals()` вместе, используйте `HashCode.Combine()`, и измеряйте распределение хешей в production-нагрузках.