**Хеш-таблица** - это структура данных, которая использует **хеш-функцию** для преобразования ключей в индексы массива.

```
Ключ → Хеш-функция → Индекс → Значение в массиве
"apple" → hash() → 5 → data[5]
```

### Визуализация структуры

```plaintext
Хеш-таблица Dictionary:
┌─────────────┐
│ Сегмент 0   │ → [элемент1] → [элемент5] → null
├─────────────┤
│ Сегмент 1   │ → [элемент2] → null  
├─────────────┤
│ Сегмент 2   │ → null
├─────────────┤
│ Сегмент 3   │ → [элемент3] → [элемент4] → [элемент6] → null
├─────────────┤
│ Сегмент 4   │ → [элемент7] → null
└─────────────┘
```

### Когда в одном сегменте несколько элементов

```csharp
// Сегмент 1 содержит:
// [apple] → [cherry] → null

// При поиске "cherry":
// 1. Вычисляем сегмент: hash("cherry") % 8 = 1
// 2. Идем в сегмент 1
// 3. ЛИНЕЙНЫЙ ПОИСК: проверяем "apple" ≠ "cherry", затем "cherry" ✓
```

## Автоматическое изменение размера

```csharp
// Когда Dictionary становится слишком заполненным
// (load factor > 0.75), он автоматически увеличивает количество сегментов

// Было: 8 сегментов
// Стало: 16 сегментов

// Все элементы перераспределяются:
// "apple": hash % 8 = 1 → hash % 16 = 9 (новый сегмент!)
```
## Внутренняя структура Dictionary в .NET

```csharp
// Упрощенная схема внутреннего устройства
public class Dictionary<TKey, TValue>
{
    private struct Entry
    {
        public int hashCode;    // Хеш-код ключа
        public int next;        // Индекс следующего элемента в цепочке (-1 если последний)
        public TKey key;        // Исходный ключ
        public TValue value;    // Значение
    }
    
    private int[] buckets;      // Массив "корзин" (начальные индексы цепочек)
    private Entry[] entries;    // Массив всех элементов
    private int count;          // Количество элементов
    private int freeList;       // Список свободных слотов для переиспользования
    private int freeCount;      // Количество свободных слотов
}
```

## Пошаговый алгоритм работы

### 1. Добавление элемента

```csharp
// dict["apple"] = 42;

// Шаг 1: Вычисляем хеш
int hashCode = "apple".GetHashCode(); // Например: 1234567

// Шаг 2: Определяем bucket
int bucketIndex = hashCode % buckets.Length; // 1234567 % 7 = 4

// Шаг 3: Проверяем коллизии
int entryIndex = buckets[bucketIndex];
while (entryIndex >= 0)
{
    if (entries[entryIndex].hashCode == hashCode && 
        entries[entryIndex].key.Equals("apple"))
    {
        // Ключ уже существует - обновляем значение
        entries[entryIndex].value = 42;
        return;
    }
    entryIndex = entries[entryIndex].next;
}

// Шаг 4: Добавляем новый элемент
int newIndex = count;
entries[newIndex] = new Entry
{
    hashCode = hashCode,
    key = "apple",
    value = 42,
    next = buckets[bucketIndex] // Вставляем в начало цепочки
};

buckets[bucketIndex] = newIndex; // Обновляем указатель bucket
count++;
```

### 2. Поиск элемента

```csharp
// dict.TryGetValue("apple", out value);

// Шаг 1: Вычисляем хеш
int hashCode = "apple".GetHashCode();

// Шаг 2: Находим bucket
int bucketIndex = hashCode % buckets.Length;

// Шаг 3: Проходим по цепочке
int entryIndex = buckets[bucketIndex];
while (entryIndex >= 0)
{
    Entry entry = entries[entryIndex];
    
    if (entry.hashCode == hashCode && entry.key.Equals("apple"))
    {
        value = entry.value;
        return true; // Найдено!
    }
    
    entryIndex = entry.next; // Переходим к следующему
}

return false; // Не найдено
```

## Визуальное представление

```
buckets[] (указатели на начало цепочек):
[0]: 3    [1]: -1   [2]: 1    [3]: -1   [4]: 0    [5]: 4    [6]: -1

entries[] (все элементы):
[0]: {hash:1001, key:"banana", value:20, next:2}
[1]: {hash:2002, key:"apple",  value:10, next:-1}
[2]: {hash:1001, key:"cherry", value:30, next:-1}  // Коллизия с "banana"
[3]: {hash:3003, key:"date",   value:40, next:-1}
[4]: {hash:4004, key:"elderberry", value:50, next:-1}

Цепочки коллизий:
bucket[0] → entries[3] ("date")
bucket[1] → пустой
bucket[2] → entries[1] ("apple") 
bucket[3] → пустой
bucket[4] → entries[0] ("banana") → entries[2] ("cherry")
bucket[5] → entries[4] ("elderberry")
bucket[6] → пустой
```

## Хеш-функция

### Требования к хорошей хеш-функции

```csharp
// 1. Детерминированность - один вход = один выход
"apple".GetHashCode() == "apple".GetHashCode(); // Всегда true

// 2. Равномерное распределение
var hashes = new[] { "a", "b", "c", "aa", "bb", "cc" }
    .Select(s => s.GetHashCode() % 1000)
    .ToArray();
// Должны быть разбросаны по всему диапазону [0..999]

// 3. Быстрое вычисление
// GetHashCode() должен работать за O(1) или O(k), где k - размер ключа
```

### Примеры хеш-функций

```csharp
// Для строк (упрощенно)
public static int SimpleStringHash(string str)
{
    int hash = 0;
    for (int i = 0; i < str.Length; i++)
    {
        hash = hash * 31 + str[i]; // 31 - простое число
    }
    return hash;
}

// Для чисел
public static int IntHash(int value)
{
    // Простейший случай - само число
    return value;
}

// Для пользовательских типов
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public override int GetHashCode()
    {
        return HashCode.Combine(Name, Age); // .NET Core 2.1+
    }
}
```

## Управление размером и resize

### Load Factor и производительность

```csharp
// Load Factor = count / buckets.Length
// Оптимальное значение ≈ 0.75

if (count >= buckets.Length * 0.75)
{
    Resize(); // Увеличиваем размер в 2 раза
}
```

### Процесс resize

```csharp
private void Resize()
{
    int newSize = buckets.Length * 2; // Удваиваем размер
    int[] newBuckets = new int[newSize];
    Entry[] newEntries = new Entry[newSize];
    
    // Инициализируем новые buckets
    for (int i = 0; i < newSize; i++)
    {
        newBuckets[i] = -1;
    }
    
    // Копируем элементы
    Array.Copy(entries, 0, newEntries, 0, count);
    
    // Перехешируем все элементы
    for (int i = 0; i < count; i++)
    {
        if (newEntries[i].hashCode >= 0) // Если элемент активен
        {
            int bucket = newEntries[i].hashCode % newSize;
            newEntries[i].next = newBuckets[bucket];
            newBuckets[bucket] = i;
        }
    }
    
    buckets = newBuckets;
    entries = newEntries;
}
```

## Сложность операций

|Операция|Лучший случай|Средний случай|Худший случай|
|---|---|---|---|
|Поиск|O(1)|O(1)|O(n)|
|Вставка|O(1)|O(1)|O(n)|
|Удаление|O(1)|O(1)|O(n)|

**Худший случай** возникает при большом количестве коллизий.

## Различные методы разрешения коллизий

### 1. Separate Chaining (используется в .NET)

```
bucket[2] → Entry1 → Entry2 → Entry3 → null
```

**Плюсы**: простота, хорошо работает при высоком Load Factor **Минусы**: дополнительная память на указатели

### 2. Open Addressing (Linear Probing)

```csharp
// Если позиция занята, ищем следующую свободную
int index = hash % size;
while (table[index] != null)
{
    index = (index + 1) % size; // Линейное пробирование
}
table[index] = value;
```

### 3. Quadratic Probing

```csharp
// Квадратичные шаги для уменьшения кластеризации
int index = hash % size;
int step = 1;
while (table[index] != null)
{
    index = (index + step * step) % size;
    step++;
}
```

## Практический пример создания простой хеш-таблицы

```csharp
public class SimpleHashTable<TKey, TValue>
{
    private class Node
    {
        public TKey Key;
        public TValue Value;
        public Node Next;
    }
    
    private Node[] buckets;
    private int count;
    
    public SimpleHashTable(int capacity = 16)
    {
        buckets = new Node[capacity];
    }
    
    public void Add(TKey key, TValue value)
    {
        int index = Math.Abs(key.GetHashCode()) % buckets.Length;
        
        // Проверяем коллизии
        Node current = buckets[index];
        while (current != null)
        {
            if (current.Key.Equals(key))
            {
                current.Value = value; // Обновляем
                return;
            }
            current = current.Next;
        }
        
        // Добавляем новый узел в начало цепочки
        Node newNode = new Node { Key = key, Value = value, Next = buckets[index] };
        buckets[index] = newNode;
        count++;
    }
    
    public bool TryGetValue(TKey key, out TValue value)
    {
        int index = Math.Abs(key.GetHashCode()) % buckets.Length;
        Node current = buckets[index];
        
        while (current != null)
        {
            if (current.Key.Equals(key))
            {
                value = current.Value;
                return true;
            }
            current = current.Next;
        }
        
        value = default(TValue);
        return false;
    }
}
```

**Ключевая идея**: хеш-таблица превращает поиск O(n) в массиве в поиск O(1) с помощью хеш-функции, но требует правильного управления коллизиями и размером для поддержания производительности.