**Дерево выражений** — это структура данных, которая представляет код в виде дерева узлов, где каждый узел является частью выражения. Это позволяет анализировать и преобразовывать код во время выполнения программы.

Вместо немедленного выполнения запроса, как в случае с IEnumerable, [[IQueryable · Работа с деревом выражений|IQueryable]] строит дерево выражений, которое можно:

- Анализировать
- Преобразовывать
- Передавать провайдеру данных для оптимизации
- Транслировать в другой язык запросов (например, SQL)

Also read [article](#https://code-maze.com/csharp-expression-trees/)

# Преобразование дерева выражений в целевой язык: триггеры

Преобразование дерева выражений, построенного через IQueryable, в целевой язык (например, SQL) происходит в момент **материализации** запроса.

## Триггеры материализации запроса

1. **Явные операции материализации:**
    
    - `ToList()`, `ToArray()`, `ToDictionary()`
    - `First()`, `FirstOrDefault()`
    - `Single()`, `SingleOrDefault()`
    - `Count()`, `Any()`
    - `Sum()`, `Min()`, `Max()`, `Average()`
    - И другие подобные методы расширения, которые требуют получения результата
2. **Перечисление результатов:**
    
    - Итерация по запросу с использованием `foreach`
    - Использование `GetEnumerator()` напрямую

## Пример процесса выполнения

```csharp
// Формирование дерева выражений (запрос еще не выполнен)
var query = dbContext.Users
    .Where(u => u.Age > 18)
    .OrderBy(u => u.LastName);

// ЗДЕСЬ ТРИГГЕР: вызов ToList() запускает преобразование в SQL и выполнение
var results = query.ToList();
```

## Что происходит при триггере материализации

1. IQueryProvider (например, EF Core's DbContext) получает финальное дерево выражений
2. ExpressionVisitor анализирует дерево выражений
3. Провайдер преобразует дерево в целевой язык запросов
4. Запрос отправляется к источнику данных
5. Результаты обрабатываются и возвращаются как .NET объекты

## Отложенное выполнение и композиция запросов

Важно понимать, что до момента материализации:

```csharp
// Каждое из этих действий только дополняет дерево выражений
var query = dbContext.Users; // Базовый запрос
if (includeInactive)
    query = query.Where(u => !u.IsActive); // Условное дополнение
if (!string.IsNullOrEmpty(searchTerm))
    query = query.Where(u => u.Name.Contains(searchTerm)); // Еще одно условное дополнение

// ЗДЕСЬ происходит преобразование и выполнение запроса
var finalResults = query.ToList();
```

## Внутренний механизм преобразования

Когда срабатывает триггер материализации:

1. Вызывается метод `Execute<TResult>()` интерфейса `IQueryProvider`
2. Провайдер запросов получает выражение запроса (`Expression` свойство интерфейса `IQueryable`)
3. Провайдер анализирует выражение и строит запрос в целевом языке
4. Запрос выполняется и результаты преобразуются обратно в объекты .NET

## Пример внутреннего процесса (упрощенно)

```csharp
// Упрощенный пример того, что происходит внутри ToList()
public static List<T> ToList<T>(this IQueryable<T> source)
{
    // Получаем провайдер запросов
    var provider = source.Provider;
    
    // Создаем выражение вызова метода ToList
    var expression = Expression.Call(
        typeof(Enumerable),
        "ToList",
        new[] { typeof(T) },
        source.Expression);
    
    // Провайдер выполняет запрос, преобразуя выражение в целевой язык
    return provider.Execute<List<T>>(expression);
}
```

## Практические следствия

1. **Производительность:** Преобразование и выполнение запроса происходит только один раз при материализации
    
2. **Композиция запросов:** Можно создавать методы, которые дополняют IQueryable без выполнения запроса
    
3. **Отладка:** Для просмотра сгенерированного SQL можно использовать логирование:
    
    ```csharp
    // В EF Core
    dbContext.Database.Log = Console.Write; // EF 6
    // или
    services.AddDbContext<AppDbContext>(options => 
        options.LogTo(Console.WriteLine)); // EF Core
    ```
    

Понимание точного момента преобразования и выполнения запроса помогает писать эффективный код и избегать распространенных проблем производительности, таких как [[N+1 проблема|N+1]] запросы или неожиданная материализация запросов в памяти.