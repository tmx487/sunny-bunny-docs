## Стратегия роста в .NET

### List\<T> — не всегда удваивание

```csharp
var list = new List<int>();

// Отслеживаем изменения Capacity
for (int i = 1; i <= 100; i++)
{
    int oldCapacity = list.Capacity;
    list.Add(i);
    
    if (list.Capacity != oldCapacity)
    {
        Console.WriteLine($"Count: {list.Count}, Old: {oldCapacity} → New: {list.Capacity}, Multiplier: {(double)list.Capacity / oldCapacity:F2}");
    }
}
```

**Реальный вывод:**

```
Count: 1, Old: 0 → New: 4, Multiplier: ∞
Count: 5, Old: 4 → New: 8, Multiplier: 2.00
Count: 9, Old: 8 → New: 16, Multiplier: 2.00
Count: 17, Old: 16 → New: 32, Multiplier: 2.00
Count: 33, Old: 32 → New: 64, Multiplier: 2.00
Count: 65, Old: 64 → New: 128, Multiplier: 2.00
```

### Исключения из правила удваивания

#### 1. **Очень большие массивы**

```csharp
// При приближении к лимитам памяти рост замедляется
// Вместо удваивания может быть рост на 50% или меньше

// Например, для массива на 1GB:
// Удваивание потребовало бы 2GB → может не хватить памяти
// Вместо этого рост на 512MB, 256MB и т.д.
```

#### 2. **Лимит Array.MaxLength**

```csharp
// В .NET массив не может быть больше Array.MaxLength
// Обычно это int.MaxValue - 56 (примерно 2.1 миллиарда элементов)

const int ArrayMaxLength = 0X7FEFFFFF; // int.MaxValue - некоторый буфер

// При приближении к лимиту удваивание невозможно
```

#### 3. **Специальные случаи StringBuilder**

```csharp
var sb = new StringBuilder();

// StringBuilder может использовать разные стратегии:
// - Удваивание для малых размеров
// - Рост на 50% для средних  
// - Минимальный рост для больших

for (int i = 0; i < 50; i++)
{
    int oldCapacity = sb.Capacity;
    sb.Append("x");
    
    if (sb.Capacity != oldCapacity)
    {
        double multiplier = (double)sb.Capacity / oldCapacity;
        Console.WriteLine($"Length: {sb.Length}, {oldCapacity} → {sb.Capacity}, x{multiplier:F2}");
    }
}
```

## Зависимость от типа данных

### Размер элемента влияет на стратегию

```csharp
// List<byte> vs List<LargeStruct>
public struct LargeStruct
{
    public long A, B, C, D, E, F, G, H; // 64 байта
}

var byteList = new List<byte>();     // 1 байт на элемент
var largeList = new List<LargeStruct>(); // 64 байта на элемент

// При одинаковом Count память различается в 64 раза!
// 1000 элементов byte: ~1KB
// 1000 элементов LargeStruct: ~64KB
```

### Внутренняя логика учитывает память

```csharp
// Псевдокод внутренней логики .NET:
int CalculateNewCapacity(int currentCapacity, int requiredCapacity)
{
    int newCapacity = currentCapacity * 2;
    
    // Проверяем лимиты памяти
    if (newCapacity * sizeof(T) > SomeMemoryLimit)
    {
        // Используем более консервативный рост
        newCapacity = currentCapacity + (currentCapacity / 2); // рост на 50%
    }
    
    // Проверяем максимальный размер массива
    if (newCapacity > Array.MaxLength)
    {
        newCapacity = Array.MaxLength;
    }
    
    return Math.Max(newCapacity, requiredCapacity);
}
```

## Практический эксперимент

```csharp
// Сравним рост для разных типов
void TestGrowthPattern<T>(T sampleValue, string typeName) where T : struct
{
    var list = new List<T>();
    int previousCapacity = 0;
    
    Console.WriteLine($"\n=== {typeName} (размер: {Marshal.SizeOf<T>()} байт) ===");
    
    for (int i = 0; i < 20; i++)
    {
        list.Add(sampleValue);
        
        if (list.Capacity != previousCapacity)
        {
            double multiplier = previousCapacity == 0 ? 0 : (double)list.Capacity / previousCapacity;
            Console.WriteLine($"Count: {list.Count,3}, Capacity: {list.Capacity,3}, Growth: x{multiplier:F2}");
            previousCapacity = list.Capacity;
        }
    }
}

// Тестируем разные типы
TestGrowthPattern<byte>(0, "byte");
TestGrowthPattern<int>(0, "int");  
TestGrowthPattern<long>(0, "long");
TestGrowthPattern<decimal>(0, "decimal");
```

## Другие коллекции с разными стратегиями

### Dictionary<K,V>

```csharp
// Dictionary растет до ближайшего простого числа
// Не удваивание! Прогрессия простых чисел: 3, 7, 11, 17, 23, 29, 37, 47...

var dict = new Dictionary<string, int>();
// Capacity: 0 → 3 → 7 → 17 → 37 → 83 → 163...
```

### HashSet\<T>

```csharp
// Аналогично Dictionary - рост до простых чисел
var hashSet = new HashSet<int>();
// Capacity: 0 → 3 → 7 → 17 → 37 → 83...
```

### StringBuilder

```csharp
// Может использовать удваивание, рост на 50% или другие стратегии
// В зависимости от текущего размера и доступной памяти
```

### ConcurrentBag\<T>

```csharp
// Более сложная стратегия из-за многопоточности
// Может выделять сегменты фиксированного размера
```

## Влияние платформы

### 32-bit vs 64-bit

```csharp
// На 32-битных системах:
// - Меньше доступной памяти
// - Более консервативный рост больших массивов

// На 64-битных системах:
// - Больше памяти → можно позволить удваивание дольше
// - Но размер указателей больше (8 байт vs 4 байта)
```

### Настройки GC

```csharp
// Large Object Heap (LOH) для объектов >85KB
// Может влиять на стратегию роста больших коллекций

// Server GC vs Workstation GC
// Разные настройки памяти → разные стратегии роста
```

## Вывод

**Удваивание** — это **стратегия по умолчанию** для `List<T>`, но не универсальное правило:

1. **Тип данных влияет косвенно** — через общий размер памяти
2. **Размер массива влияет напрямую** — большие массивы растут консервативнее
3. **Разные коллекции используют разные стратегии**
4. **Платформа и настройки GC могут влиять**

Для обычных случаев (небольшие и средние `List<T>`) можно рассчитывать на удваивание, но для производственного кода лучше **явно задавать capacity** когда размер известен заранее.