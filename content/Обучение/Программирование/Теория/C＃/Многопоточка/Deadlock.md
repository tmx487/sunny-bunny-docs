**Deadlock** — это ситуация, когда два или более потоков (или процессов) бесконечно ожидают друг друга, чтобы освободить ресурсы, которыми они владеют, и которые необходимы другим потокам для продолжения выполнения. В результате, все задействованные потоки застревают и не могут продолжить работу.

**Ключевые характеристики:**

- **Зависание системы:** Программа или ее часть полностью перестает отвечать, поскольку задействованные потоки находятся в состоянии ожидания и не могут продвинуться.
    
- **Циклическая зависимость:** Обычно возникает, когда существует круговая зависимость владения ресурсами. Поток A ждет ресурс, занятый потоком B, а поток B ждет ресурс, занятый потоком A.
    
- **[[Условия Коффмана (Coffman Conditions)|Условия Коффмана]]:** Для возникновения дедлока должны выполняться все четыре условия ([[Условия Коффмана (Coffman Conditions)|условия Коффмана]]):
    
    1. **Взаимное исключение (Mutual Exclusion):** Ресурсы не могут быть использованы одновременно несколькими потоками.
        
    2. **Удержание и ожидание (Hold and Wait):** Поток удерживает по крайней мере один ресурс и ожидает получения других ресурсов, которые удерживаются другими потоками.
        
    3. **Без вытеснения (No Preemption):** Ресурсы не могут быть принудительно отобраны у потока; они могут быть освобождены только потоком, который ими владеет.
        
    4. **Круговое ожидание (Circular Wait):** Существует цикл потоков, где каждый поток в цикле ожидает ресурс, удерживаемый следующим потоком в цикле.
        

**Пример:**

Представьте два потока и два ресурса (Lock A и Lock B).

- **Поток 1:**
    
    1. Блокирует Lock A.
        
    2. Пытается заблокировать Lock B.
        
- **Поток 2:**
    
    1. Блокирует Lock B.
        
    2. Пытается заблокировать Lock A.
        

**Последовательность событий, ведущая к дедлоку:**

1. **Поток 1** успешно захватывает Lock A.
    
2. **Поток 2** успешно захватывает Lock B.
    
3. **Поток 1** пытается захватить Lock B, но он уже занят **Потоком 2**. **Поток 1** переходит в состояние ожидания.
    
4. **Поток 2** пытается захватить Lock A, но он уже занят **Потоком 1**. **Поток 2** переходит в состояние ожидания.
    

Оба потока теперь заблокированы, и ни один из них не может продолжить выполнение, потому что каждый ждет ресурс, удерживаемый другим.

**Решение:**

Предотвращение одного или нескольких [[Условия Коффмана (Coffman Conditions)|условий Коффмана]]. Например:

- Упорядочивание блокировок (всегда захватывать блокировки в одном и том же порядке).
    
- Таймауты для блокировок.
    
- Обнаружение и восстановление после Deadlock (менее предпочтительно, так как сложнее).