**Задание порядка блокировок (resource ordering или lock ordering)** — это один из наиболее эффективных и распространенных способов предотвращения взаимоблокировок (deadlocks), особенно в сложных системах с множеством ресурсов. Идея заключается в том, чтобы **всегда захватывать блокировки в одном и том же, заранее определенном глобальном порядке**.

Если все потоки следуют этому правилу, то круговое ожидание (одно из четырех [[Условия Коффмана (Coffman Conditions)|условий Коффмана]]) становится невозможным, и, следовательно, [[Race Condition vs DeadLock#Deadlock (Взаимная блокировка)|дедлок]] не может возникнуть.

Давайте рассмотрим, как это сделать, на примерах и общих принципах.

### Общие принципы задания порядка блокировок

1. **Определите все ресурсы, требующие блокировки:** Сначала идентифицируйте все мьютексы, мониторы, семафоры или любые другие механизмы блокировки, которые используются в вашей системе.
    
2. **Присвойте им логический порядок:** Это может быть числовой порядок, алфавитный порядок по именам, или любой другой, но он должен быть **последовательным и согласованным** для всей системы.
    
    - Например, если у вас есть `lockA`, `lockB`, `lockC`, вы можете решить, что порядок такой: `lockA` -> `lockB` -> `lockC`.
        
3. **Строго следуйте порядку при захвате блокировок:** Каждый раз, когда поток должен захватить несколько блокировок, он **обязан** делать это в заранее определенном порядке.
    
4. **Освобождать блокировки можно в любом порядке:** Порядок освобождения блокировок обычно не имеет значения для предотвращения [[Race Condition vs DeadLock#Deadlock (Взаимная блокировка)|дедлоков]], так как потоки уже выполнили свои операции. Однако, для ясности и читаемости кода, часто их освобождают в обратном порядке захвата.
    

### Примеры

#### Пример 1: Простой порядок двух блокировок

Представьте, что у вас есть два объекта, `Account1` и `Account2`, и вы хотите перевести деньги между ними. Для защиты каждого счета вы используете отдельную блокировку.

❌**Плохой код (может привести к дедлоку):**

```csharp
class Account
{
    public int Balance { get; private set; }
    private readonly object _lock = new object();

    public Account(int balance)
    {
        Balance = balance;
    }

    public void Withdraw(int amount)
    {
        lock (_lock)
        {
            Balance -= amount;
        }
    }

    public void Deposit(int amount)
    {
        lock (_lock)
        {
            Balance += amount;
        }
    }

    public object GetLock() => _lock;
}

class TransferService
{
    // Может привести к дедлоку!
    public void Transfer(Account from, Account to, int amount)
    {
        // Поток 1: from = Acc1, to = Acc2
        // Поток 2: from = Acc2, to = Acc1

        // Если from.GetLock() захватывается раньше to.GetLock()
        // А в другом потоке to.GetLock() захватывается раньше from.GetLock()
        // Возникнет циклическое ожидание
        lock (from.GetLock())
        {
            lock (to.GetLock())
            {
                from.Withdraw(amount);
                to.Deposit(amount);
            }
        }
    }
}
```

В этом примере, если `Поток 1` пытается перевести из `Acc1` в `Acc2` (`lock(Acc1)` затем `lock(Acc2)`), а `Поток 2` одновременно пытается перевести из `Acc2` в `Acc1` (`lock(Acc2)` затем `lock(Acc1)`), может возникнуть дедлок.

✅**Хороший код (с порядком блокировок):**

Для решения этой проблемы мы можем гарантировать, что блокировки всегда захватываются в одном и том же порядке, например, по уникальному идентификатору (ID) счета.

```csharp
class Account
{
    public int Id { get; } // Добавляем ID для упорядочивания
    public int Balance { get; private set; }
    private readonly object _lock = new object();

    public Account(int id, int balance)
    {
        Id = id;
        Balance = balance;
    }

    public void Withdraw(int amount)
    {
        Balance -= amount;
    }

    public void Deposit(int amount)
    {
        Balance += amount;
    }

    public object GetLock() => _lock;
}

class TransferService
{
    public void Transfer(Account from, Account to, int amount)
    {
        // Определяем порядок блокировок по ID счета
        object lock1 = from.Id < to.Id ? from.GetLock() : to.GetLock();
        object lock2 = from.Id < to.Id ? to.GetLock() : from.GetLock();

        // Захватываем блокировки строго в определенном порядке
        lock (lock1)
        {
            lock (lock2)
            {
                // Теперь можно безопасно выполнять операции
                from.Withdraw(amount);
                to.Deposit(amount);
            }
        }
    }
}
```

В этом улучшенном коде `lock1` всегда будет ссылаться на блокировку счета с меньшим `Id`, а `lock2` — на блокировку счета с большим `Id`. Таким образом, независимо от того, какие счета `from` и `to`, блокировки всегда будут захватываться в одном и том же порядке (сначала меньший ID, затем больший ID), что исключает круговое ожидание.

#### Пример 2: Использование строковых имен или хэшей

Если ваши ресурсы не имеют естественного числового порядка, вы можете создать его искусственно:

```csharp
private static readonly object LockResourceA = new object();
private static readonly object LockResourceB = new object();
private static readonly object LockResourceC = new object();

// Глобальный порядок: LockResourceA -> LockResourceB -> LockResourceC

public void Operation1()
{
    lock (LockResourceA) // Всегда сначала LockA
    {
        // ...
        lock (LockResourceB) // Затем LockB
        {
            // Критическая секция, требующая A и B
        }
    }
}

public void Operation2()
{
    lock (LockResourceB) // Неправильно! Нарушает порядок, если LockA также нужен
    {
        // ...
        lock (LockResourceA) // Дедлок может произойти, если другой поток захватил A и ждет B
        {
            // ...
        }
    }
}

public void CorrectOperation2()
{
    lock (LockResourceA) // Правильно, всегда начинаем с LockA
    {
        // ...
        lock (LockResourceB) // Затем LockB
        {
            // Критическая секция, требующая A и B
        }
    }
}
```

### Сложности и ограничения

- **Масштабируемость:** В системах с очень большим количеством динамически создаваемых ресурсов (например, миллионы записей в базе данных, каждая со своим собственным "замком"), управление глобальным порядком может стать чрезвычайно сложным или непрактичным.
    
- **Производительность:** Если вам приходится захватывать много блокировок в строго определенном порядке, это может привести к снижению параллелизма, так как потокам приходится ждать, пока освободится блокировка с меньшим порядковым номером, даже если интересующие их блокировки с более высоким порядковым номером свободны.
    
- **Сложность понимания:** Поддержание и обеспечение строгого соблюдения порядка блокировок требует дисциплины и тщательного проектирования, особенно в больших командах или при изменении кода.
    
- **Внешние системы:** Если ваша система взаимодействует с внешними системами (например, базами данных), которые также имеют свои собственные механизмы блокировки, вы можете столкнуться с дедлоками, которые не поддаются контролю вашим внутренним порядком блокировок.
    

Несмотря на эти сложности, задание порядка блокировок остается мощным и широко используемым методом предотвращения дедлоков в управляемых средах.