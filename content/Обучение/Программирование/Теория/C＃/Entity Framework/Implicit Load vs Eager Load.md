Хороший вопрос! В приведенном мною примере действительно используется явная загрузка, а не жадная. Это было сделано для демонстрации работы со связанными сущностями в контексте DbContext, но вы правильно подметили, что эти подходы отличаются.

## Сравнение подходов для данного примера

### 1. Явная загрузка (как в примере)

```csharp
var order = context.Orders.Find(1);
context.Entry(order).Reference(o => o.Customer).Load(); // Явная загрузка свойства-ссылки

var customer = context.Customers.Find(1);
context.Entry(customer).Collection(c => c.Orders).Load(); // Явная загрузка коллекции
```

### 2. Жадная загрузка (альтернативный подход)

```csharp
// Жадная загрузка с Include
var order = context.Orders
    .Include(o => o.Customer)
    .FirstOrDefault(o => o.Id == 1);

// Жадная загрузка для коллекции
var customer = context.Customers
    .Include(c => c.Orders)
    .FirstOrDefault(c => c.Id == 1);
```

## Почему иногда предпочтительна явная загрузка?

В некоторых сценариях явная загрузка может быть более подходящим выбором, чем жадная загрузка:

### 1. Условная загрузка данных

Явная загрузка позволяет загружать связанные данные только при определенных условиях:

```csharp
var order = context.Orders.Find(1);

// Загружаем клиента только если нужно показать его данные
if (showCustomerDetails)
{
    context.Entry(order).Reference(o => o.Customer).Load();
}
```

### 2. Отложенные решения о загрузке

Когда в момент формирования запроса не известно, потребуются ли связанные данные:

```csharp
var order = context.Orders.Find(1);

// Выполняем какую-то логику...
if (ProcessOrderDetails(order) == ProcessingResult.NeedCustomerInfo)
{
    // Только теперь загружаем клиента
    context.Entry(order).Reference(o => o.Customer).Load();
}
```

### 3. Фильтрация связанных данных

Явная загрузка позволяет применять дополнительные фильтры к загружаемым связанным сущностям:

```csharp
var customer = context.Customers.Find(1);

// Загружаем только активные заказы
context.Entry(customer)
    .Collection(c => c.Orders)
    .Query()
    .Where(o => o.Status == OrderStatus.Active)
    .Load();
```

### 4. Управление объемом загружаемых данных

При работе с большими коллекциями можно ограничить количество загружаемых элементов:

```csharp
var customer = context.Customers.Find(1);

// Загружаем только последние 10 заказов
context.Entry(customer)
    .Collection(c => c.Orders)
    .Query()
    .OrderByDescending(o => o.OrderDate)
    .Take(10)
    .Load();
```

### 5. Распределение нагрузки на базу данных

Разделение запроса на несколько меньших может быть предпочтительнее одного большого в некоторых сценариях:

```csharp
// Когда нужно загрузить много разных связанных сущностей,
// можно сделать это последовательно, а не одним сложным запросом
var customer = context.Customers.Find(1);

// Загружаем только то, что действительно нужно
context.Entry(customer).Collection(c => c.Orders).Load();
context.Entry(customer).Collection(c => c.Addresses).Load();
context.Entry(customer).Reference(c => c.DefaultPaymentMethod).Load();
```

## Когда предпочтительнее жадная загрузка?

1. Когда точно известно, что связанные данные понадобятся
2. Когда нужно минимизировать количество запросов к БД
3. В сценариях отключенных (detached) сущностей, когда контекст будет закрыт до использования связанных данных

## Заключение

В примере, который я привел ранее, использовалась явная загрузка для демонстрации API DbContext для работы со связанными сущностями. В реальной практике выбор между жадной и явной загрузкой должен основываться на конкретном сценарии использования, с учетом требований к производительности, предсказуемости запросов и объему загружаемых данных.

Нет универсально правильного подхода — и жадная, и явная загрузка имеют свои преимущества в зависимости от контекста использования.