**Планировщик** - это компонент PostgreSQL, который решает, КАК выполнить запрос наиболее эффективно.

### **Что делает планировщик:**

```sql
-- Для запроса:
SELECT * FROM users WHERE age > 25 AND city = 'Moscow';

-- Планировщик рассматривает варианты:
-- 1. Seq Scan (читать всю таблицу)
-- 2. Index Scan по индексу age
-- 3. Index Scan по индексу city  
-- 4. Bitmap Scan (комбинация индексов)
-- 5. Hash Join, если есть соединения

-- И выбирает наименее "дорогой" план
```

### **Как планировщик использует статистику:**

```sql
-- Планировщик оценивает:
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM orders WHERE user_id = 12345;

-- Query Planner рассуждает:
-- 1. "Сколько строк в таблице?" → n_live_tup из статистики
-- 2. "Сколько уникальных user_id?" → n_distinct из статистики  
-- 3. "Какой процент строк будет выбран?" → most_common_freqs
-- 4. "Есть ли подходящий индекс?" → информация об индексах
-- 5. "Что дешевле: Seq Scan или Index Scan?" → математические модели
```

### **Пример влияния устаревшей статистики:**

```sql
-- Ситуация: таблица выросла с 1000 до 1,000,000 строк
-- Но статистика не обновлялась

-- Устаревшая статистика говорит: "1000 строк"
-- Планировщик выбирает: Seq Scan (быстро для 1000 строк)

-- На самом деле: 1,000,000 строк  
-- Seq Scan работает ОЧЕНЬ медленно!

-- После ANALYZE:
ANALYZE orders;
-- Новая статистика: "1,000,000 строк"
-- Планировщик выбирает: Index Scan (быстро для больших таблиц)
```

### **Проверка планов выполнения:**

```sql
-- Посмотреть план без выполнения
EXPLAIN SELECT * FROM users WHERE age > 25;

-- Посмотреть план с реальным выполнением
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM users WHERE age > 25;

-- Результат:
-- Seq Scan on users  (cost=0.00..1000.00 rows=500 width=32) (actual time=0.123..45.678 rows=523 loops=1)
--   Filter: (age > 25)
--   Rows Removed by Filter: 477
--   Buffers: shared hit=100
-- Planning time: 0.145 ms
-- Execution time: 46.234 ms
```

## **Взаимосвязь всех компонентов:**

```sql
-- 1. Много UPDATE/DELETE → накопление dead tuples
-- 2. Dead tuples → фрагментация таблиц и индексов  
-- 3. Устаревшая статистика → неоптимальные планы запросов
-- 4. VACUUM → очистка dead tuples + обновление статистики
-- 5. Оптимальные планы → быстрые запросы
```