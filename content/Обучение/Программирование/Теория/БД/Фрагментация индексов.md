### **Как происходит фрагментация:**

```sql
-- Исходный индекс (упорядочен)
B-Tree индекс по user_id:
[1] → [2] → [3] → [4] → [5] → [6] → [7] → [8]

-- После множества UPDATE/DELETE операций:
[1] → [DEAD] → [3] → [DEAD] → [5] → [DEAD] → [7] → [DEAD]
      ↑ "дыры" в индексе

-- При поиске user_id = 7:
-- Нужно "перешагивать" через DEAD записи → медленнее
```

### **Проблемы фрагментации:**

```sql
-- Проверка фрагментации индекса
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    idx_scan,  -- Количество использований
    idx_tup_read, -- Прочитано записей
    idx_tup_fetch -- Возвращено записей
FROM pg_stat_user_indexes;

-- Сильно фрагментированный индекс:
-- idx_tup_read >> idx_tup_fetch (читаем много, возвращаем мало)
```

### **Как VACUUM помогает с индексами:**

```sql
-- Обычный VACUUM очищает DEAD записи в индексах
VACUUM table_name;

-- Если фрагментация критична - REINDEX
REINDEX INDEX index_name;
REINDEX TABLE table_name;
```