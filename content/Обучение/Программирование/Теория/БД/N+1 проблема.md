**N+1 проблема** — это классическая проблема производительности в ORM (Object-Relational Mapping), когда для получения N записей выполняется 1 основной запрос + N дополнительных запросов для загрузки связанных данных.

## Как возникает проблема

**Пример с Entity Framework:**

```csharp
// Получаем всех пользователей (1 запрос)
var users = context.Users.ToList();

// Для каждого пользователя загружаем заказы (N запросов)
foreach (var user in users)
{
    Console.WriteLine($"User: {user.Name}");
    Console.WriteLine($"Orders count: {user.Orders.Count}"); // Lazy loading!
}
```

**Что происходит в БД:**

```sql
-- 1 основной запрос
SELECT * FROM Users

-- N дополнительных запросов (по одному для каждого пользователя)
SELECT * FROM Orders WHERE UserId = 1
SELECT * FROM Orders WHERE UserId = 2  
SELECT * FROM Orders WHERE UserId = 3
-- ... и так далее для каждого пользователя
```

## Решения проблемы

### 1. Eager Loading (Include)

```csharp
// Один запрос с JOIN
var users = context.Users
    .Include(u => u.Orders)
    .ToList();

foreach (var user in users)
{
    Console.WriteLine($"Orders count: {user.Orders.Count}"); // Без доп. запросов
}
```

### 2. Select + Projection

```csharp
// Получаем только нужные данные одним запросом
var userSummaries = context.Users
    .Select(u => new UserSummary
    {
        Name = u.Name,
        OrdersCount = u.Orders.Count()
    })
    .ToList();
```

### 3. Load/LoadAsync

```csharp
var users = context.Users.ToList();

// Загружаем все заказы одним запросом
context.Entry(users.First())
    .Collection(u => u.Orders)
    .Load();
```

### 4. Split Query (EF Core 5+)

```csharp
// Разделяет на несколько оптимизированных запросов
var users = context.Users
    .AsSplitQuery()
    .Include(u => u.Orders)
    .Include(u => u.Profile)
    .ToList();
```

## Обнаружение N+1 проблемы

**В логах EF Core:**

```csharp
// Включить логирование SQL
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(connectionString)
        .LogTo(Console.WriteLine, LogLevel.Information);
}
```

**Инструменты мониторинга:**

- Application Insights
- MiniProfiler
- Entity Framework Profiler
- SQL Server Profiler

## Примеры в разных сценариях

**GraphQL:**

```csharp
// Плохо - N+1 для каждого поля
public async Task<User> GetUser(int id)
{
    return await context.Users.FindAsync(id);
}

public async Task<IEnumerable<Order>> GetOrders(User user)
{
    return await context.Orders.Where(o => o.UserId == user.Id).ToListAsync();
}

// Хорошо - DataLoader
[UseDataLoader]
public async Task<IEnumerable<Order>> GetOrders(
    User user, 
    OrdersByUserIdDataLoader dataLoader)
{
    return await dataLoader.LoadAsync(user.Id);
}
```

**Repository Pattern:**

```csharp
// Плохо
public async Task<List<UserDto>> GetUsersWithOrderCount()
{
    var users = await context.Users.ToListAsync();
    var result = new List<UserDto>();
    
    foreach (var user in users)
    {
        var orderCount = await context.Orders
            .CountAsync(o => o.UserId == user.Id); // N+1!
        
        result.Add(new UserDto 
        { 
            Name = user.Name, 
            OrderCount = orderCount 
        });
    }
    
    return result;
}

// Хорошо
public async Task<List<UserDto>> GetUsersWithOrderCount()
{
    return await context.Users
        .Select(u => new UserDto
        {
            Name = u.Name,
            OrderCount = u.Orders.Count()
        })
        .ToListAsync();
}
```

## Профилактика

- **Всегда думайте о связанных данных** при написании запросов
- **Используйте Include** для известных связей
- **Анализируйте SQL логи** в процессе разработки
- **Настройте мониторинг** количества запросов к БД
- **Рассмотрите отключение Lazy Loading** в критичных местах

N+1 проблема может серьезно деградировать производительность, особенно при больших объемах данных, поэтому важно выявлять и решать её на этапе разработки.