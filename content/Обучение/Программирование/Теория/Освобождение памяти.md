
**Освобождение памяти** (disposing)- процедура освобождения ресурсов типа открытые файлы, блокировки, дескрипторы операционной системы и неуправляемые объекты. Данная процедура поддерживается через интерфейс `IDisposable` и инициируется явно.

В С# есть специальный интерфейс для освобождения памяти `IDisposable`

```csharp
public interface IDisposable
{
	void Dispose();
}
```

Оператор `using` языка C# предлагает синтаксическое сокращение для вызова
метода `Dispose` на объектах, которые реализуют интерфейс `IDisposable`, используя блок `try/finally`

```csharp
using (FileStream fs = new FileStream ("myFile.txt", FileMode.Open))
{
	// ...Запись в файл ...
}

// Компилятор преобразует такой код следующим образом:

FileStream fs = new FileStream ("myFile.txt", FileMode.Open);
try
{
	// . . . Запись в файл. . .
}
finally
{
	if (fs != null) ((IDisposable)fs).Dispose();
}

// также строка ниже аналогична строке 1
using FileStream fs = new FileStream ("myFile.txt", FileMode.Open);
```
>*Просто имплементация `IDisposable` работает только в простых случаях и подходит для запечатанных классов.*
>*Если предполагается, что будет разветвленная иерархия типов, то лучше реализовать другой шаблон (==ДОПИСАТЬ ПОЗДНЕЕ==), чтобы обезопасить себя от ситуации, когда `Dispose` не был вызван или наследники класса сами реализовали функциональность по освобождению памяти*

Если родительский класс реализует интерфейс `IDisposable`, то наследники этого класса тоже должны реализовать этот интерфейс, если они используют ресурсы, требующие освобождения, или если они переопределяют методы родительского класса, которые управляют ресурсами.

Вот основные моменты, о которых стоит помнить:

1. **Наследование интерфейса**: При наследовании класса, который реализует `IDisposable`, дочерний класс получит возможность использовать метод `Dispose()`, но не обязан его переопределять, если не требуется дополнительная логика освобождения ресурсов.
    
2. **Переопределение метода**: Если наследник требует освобождения своих собственных ресурсов (например, неуправляемых объектов или других IDisposable объектов), то рекомендуется переопределить метод `Dispose()` и вызвать `Dispose()` родительского класса, используя `base.Dispose()`.
    
3. **Поддержка паттерна**: Если метод Dispose переопределяется в наследнике, важно также следовать паттерну «Dispose» — обеспечить возможность вызова `Dispose` как с явным вызовом, так и через финализатор, если это необходимо.
    

В общем, следование этим правилам обеспечит корректное управление ресурсами и предотвратит утечки памяти.

>*Пускай у вас есть в классе поле (ну или свойство), которое имплементирует `IDisposable`. В этом случае ваш класс тоже должен имплементировать `IDisposable`, чтобы во время своего `Dispose` вызвать `Dispose` и для внутреннего объекта.*



