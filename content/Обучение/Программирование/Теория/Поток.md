>Поток - это параллельно выполняющаяся программа в контексте нашей программы

Потоки были придуманы для решения проблем, связанных с процессами в Windows (напр., приложение могло войти в бесконечный цикл и тогда процессор не мог реагировать на другие операции).

>  *Именно поток стал той концепцией, которая предназначена для **виртуализации процессора** в Windows. Каждому Windows-процессу выделяется собственный поток исполнения (который работает как виртуальный процессор). Если код приложения войдет в бесконечный цикл, то блокируется только связанный с этим кодом процесс, а остальные процессы (исполняющиеся в собственных потоках) продолжают функционировать!*

[[Библиотека/Книги/Рихтер Дж. - CLR via C#. Программирование на платформе Microsoft .NET Framework 4.5 на языке C#. 4-е изд. (Мастер-класс) - 2013.pdf#page=725&selection=34,64,47,16|Рихтер Дж. - CLR via C#. Программирование на платформе Microsoft .NET Framework 4.5 на языке C#. 4-е изд. (Мастер-класс) - 2013, страница 725]]

> *Однако как и любые механизмы виртуализации, потоки потребляют дополнительные ресурсы, требуя пространства (памяти) и времени (снижая производительность среды исполнения*

[[Библиотека/Книги/Рихтер Дж. - CLR via C#. Программирование на платформе Microsoft .NET Framework 4.5 на языке C#. 4-е изд. (Мастер-класс) - 2013.pdf#page=725&selection=58,47,60,62|Рихтер Дж. - CLR via C#. Программирование на платформе Microsoft .NET Framework 4.5 на языке C#. 4-е изд. (Мастер-класс) - 2013, страница 725]]

- Статические переменные для всех потоков одни, т.е. если создать статическую переменную, то она будет доступна для всех потоков (*в рамках одного процесса* - ?, проверить это утверждение); если нужно, чтобы у каждого потока была такая собственная переменная, необходимо использовать атрибут `[ThreadStatic]` перед объявлением переменной. Т.е. получается, что каждый поток получит копию этой переменной, которая будет храниться в TLS (Thread Local Storage - локальное хранилище потока)

### Прерывание работы потока

![[Pasted image 20240903075519.png]]

![[Pasted image 20240903075631.png]]

![[Pasted image 20240903075818.png]]

![[Pasted image 20240903075912.png]]

`Thread.Join()`- заставляет поток ждать, пока не выполнится вызванный потом
`Thread.Abort()` - прерывает деятельность потока
`Thread.ResetAbort()` - ?

### Синхронизация доступа к разделяемым ресурсам

![[Pasted image 20240904070129.png]]

Шаблон ручной блокировки потоков - SpinLock ?

`Monitor.Enter(block)` - служит для указания момента начала блокировки потоком доступа к разделяемому ресурсу

`Monitor.Exit(block)` - заканчивает блокировку

Вместо `Monitor.Enter(), Monitrot.Exit()` можно использовать конструкцию `lock`