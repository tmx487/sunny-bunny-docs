**Абстракция** — это выделение существенных характеристик объекта и сокрытие несущественных деталей реализации. Но в C# это реализуется через несколько механизмов.

## Уровни абстракции в C＃

### 1. Концептуальная абстракция

Самый высокий уровень — мы думаем об объектах предметной области:

```cs
// Абстрагируемся от деталей и думаем о "Пользователе" как о концепции
public class User
{
    public string Name { get; set; }
    public void Login() { /* детали скрыты */ }
}
```

### 2. Абстрактные классы (`abstract`)

Определяют общий интерфейс, но не могут быть созданы напрямую:

```cs
public abstract class Shape
{
    // Конкретная реализация (общая для всех фигур)
    public string Color { get; set; }
    
    // Абстрактный метод - ОБЯЗАН быть переопределен
    public abstract double CalculateArea();
    
    // Виртуальный метод - МОЖЕТ быть переопределен
    public virtual void Draw()
    {
        Console.WriteLine($"Рисую {Color} фигуру");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }
    
    // ОБЯЗАТЕЛЬНО переопределяем абстрактный метод
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
}

// Shape shape = new Shape(); // ❌ ОШИБКА! Нельзя создать экземпляр
Shape shape = new Circle(); // ✅ ОК
```

### 3. Интерфейсы (`interface`)

Определяют контракт без реализации:

```cs
public interface IPaymentProcessor
{
    bool ProcessPayment(decimal amount);
    string GetTransactionId();
}

public interface ILogger
{
    void Log(string message);
    
    // C# 8.0+ - default implementation
    void LogError(string error) => Log($"ERROR: {error}");
}

public class CreditCardProcessor : IPaymentProcessor
{
    public bool ProcessPayment(decimal amount)
    {
        // Конкретная реализация для кредитных карт
        return true;
    }
    
    public string GetTransactionId() => Guid.NewGuid().ToString();
}
```

## Скользкие моменты абстракции

### 1. Abstract Class vs Interface — когда что использовать?

```cs
// ❌ Плохо - интерфейс для единственной реализации
public interface IUserService 
{
    void CreateUser(string name);
}

public class UserService : IUserService // Единственная реализация
{
    public void CreateUser(string name) { }
}

// ✅ Хорошо - абстрактный класс когда есть общая логика
public abstract class DocumentProcessor
{
    // Общий алгоритм
    public void ProcessDocument(string path)
    {
        var content = LoadDocument(path);
        var parsed = ParseContent(content);
        SaveResult(parsed);
    }
    
    protected abstract string ParseContent(string content); // Различается
    private string LoadDocument(string path) { /* общая логика */ }
    private void SaveResult(string result) { /* общая логика */ }
}
```

**Правило:**

- **Interface** - когда определяем контракт, который могут реализовать разные классы
- **Abstract class** - когда есть общий код и нужно принудить наследников реализовать специфичные части

### 2. Переабстрагирование

```cs
// ❌ Слишком много абстракций без смысла
public interface IUserFactory
{
    IUser CreateUser();
}

public interface IUser
{
    string GetName();
}

public interface IUserNameProvider
{
    string ProvideName();
}

// ✅ Простое решение часто лучше
public class User
{
    public string Name { get; set; }
    public User(string name) => Name = name;
}
```

### 3. Нарушение принципа замещения (LSP) через абстракцию

```cs
public abstract class Bird
{
    public abstract void Fly();
}

public class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotSupportedException("Пингвины не летают!"); // ❌ Нарушение LSP
    }
}

// ✅ Правильная абстракция
public abstract class Bird
{
    public abstract void Move();
}

public class Eagle : Bird
{
    public override void Move() => Console.WriteLine("Летаю");
}

public class Penguin : Bird
{
    public override void Move() => Console.WriteLine("Плаваю");
}

// Или с интерфейсами способностей:
public interface IFlyable
{
    void Fly();
}

public class Eagle : Bird, IFlyable
{
    public override void Move() => Fly();
    public void Fly() => Console.WriteLine("Лечу");
}

public class Penguin : Bird // Не реализует IFlyable
{
    public override void Move() => Console.WriteLine("Плаваю");
}
```

>**Почему это нарушение LSP:**
>
>1. **Контракт базового класса нарушен**: `Bird.Fly()` предполагает, что метод выполнится успешно, но `Penguin.Fly()` бросает исключение
>2. **Поведение непредсказуемо**: код, работающий с `Bird`, не ожидает исключений от `Fly()`
>3. **Замещение невозможно**: нельзя безопасно заменить `Eagle` на `Penguin` в существующем коде
### 4. Проблема с множественными интерфейсами

```cs
public interface IWritable
{
    void Write(string data);
}

public interface IReadable  
{
    string Read();
}

public class File : IWritable, IReadable
{
    public void Write(string data) { /* запись */ }
    public string Read() { /* чтение */ }
}

// Проблема: что если файл только для чтения?
public class ReadOnlyFile : IWritable, IReadable
{
    public string Read() { /* OK */ }
    public void Write(string data) 
    { 
        throw new InvalidOperationException(); // ❌ Нарушаем контракт
    }
}

// ✅ Лучше разделить интерфейсы по назначению (ISP)
public class ReadOnlyFile : IReadable
{
    public string Read() { /* OK, не реализуем Write */ }
}
```

## Современные возможности абстракции в C\#

### 1. Generic абстракции

```cs
public abstract class Repository<T> where T : class
{
    protected abstract IQueryable<T> GetQuery();
    
    public virtual async Task<T> GetByIdAsync(int id)
    {
        return await GetQuery().FirstOrDefaultAsync(x => x.Id == id);
    }
}

public class UserRepository : Repository<User>
{
    private readonly DbContext _context;
    
    protected override IQueryable<User> GetQuery()
    {
        return _context.Users.AsQueryable();
    }
}
```

### 2. Records как абстракция данных (+ [[Pattern matching]]) (C# 9+)

```cs
// Абстрагируемся от деталей реализации
public abstract record Shape;
public record Circle(double Radius) : Shape;
public record Rectangle(double Width, double Height) : Shape;

// Pattern matching вместо виртуальных методов
public static double CalculateArea(Shape shape) => shape switch
{
    Circle(var radius) => Math.PI * radius * radius,
    Rectangle(var width, var height) => width * height,
    _ => throw new ArgumentException("Unknown shape")
};
```

## Практические рекомендации

### 1. Начинайте с конкретного кода

```cs
// ❌ Не создавайте абстракции "на всякий случай"
public interface IEmailSender { }
public class EmailSender : IEmailSender { } // Единственная реализация

// ✅ Сначала конкретный код, абстракция при необходимости
public class EmailService
{
    public void SendEmail(string to, string subject, string body) { }
}

// Абстракцию добавляем, когда появляется вторая реализация
```

### 2. Принцип минимальной достаточности

```cs
// ✅ Интерфейс содержит только необходимые методы
public interface IUserNotificationService
{
    Task NotifyAsync(int userId, string message);
}

// ❌ Слишком широкий интерфейс
public interface IUserService
{
    Task CreateAsync(User user);
    Task UpdateAsync(User user);
    Task DeleteAsync(int id);
    Task NotifyAsync(int userId, string message);
    Task ValidateAsync(User user);
    // ... еще 10 методов
}
```

### 3. Правильное именование

```cs
// ✅ Ясные имена
public interface IPaymentProcessor { }
public abstract class BaseController { }

// ❌ Неясные имена
public interface IManager { } // Что управляет?
public abstract class AbstractHelper { } // Чем помогает?
```

Абстракция в C# — это баланс между гибкостью и простотой. Главное правило: создавайте абстракции тогда, когда они действительно нужны, а не "на всякий случай".