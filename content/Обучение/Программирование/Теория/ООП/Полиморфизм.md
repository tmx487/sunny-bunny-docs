**Полиморфизм** — один из фундаментальных принципов объектно-ориентированного программирования, который позволяет использовать объекты разных классов через общий интерфейс. Название происходит от греческих слов "поли" (много) и "морф" (форма), что буквально означает "много форм".

В C# полиморфизм реализуется несколькими способами, которые я подробно опишу ниже.

## 1. Полиморфизм времени выполнения (динамический полиморфизм)

Этот вид полиморфизма реализуется через наследование и [[Переопределение vs Перегрузка методов|переопределение методов]].

### Виртуальные методы и переопределение

```csharp
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Животное издает звук");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Гав-гав!");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Мяу!");
    }
}

// Использование полиморфизма
public void MakeSounds(Animal[] animals)
{
    foreach (Animal animal in animals)
    {
        // Вызывается переопределенный метод конкретного класса
        animal.MakeSound();
    }
}

// Пример вызова
Animal[] animals = new Animal[2];
animals[0] = new Dog();
animals[1] = new Cat();
MakeSounds(animals); // Выведет "Гав-гав!" и "Мяу!"
```

Здесь метод `MakeSound()` имеет несколько форм реализации, и конкретная форма определяется во время выполнения (runtime).

### Ключевые слова

- `virtual` — помечает метод базового класса как виртуальный, т.е. переопределяемый
- `override` — указывает, что метод переопределяет виртуальный метод базового класса
- `base` — ключевое слово для вызова метода базового класса из переопределяющего метода

### Абстрактные классы и методы

```csharp
public abstract class Shape
{
    // Абстрактный метод должен быть переопределен в наследниках
    public abstract double CalculateArea();
    
    // Обычный виртуальный метод с реализацией
    public virtual void Draw()
    {
        Console.WriteLine("Рисуем фигуру");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }
    
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"Рисуем круг радиусом {Radius}");
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public override double CalculateArea()
    {
        return Width * Height;
    }
}
```

## 2. Полиморфизм через интерфейсы

Другой важный способ реализации полиморфизма в C# — использование интерфейсов.

```csharp
public interface IDrawable
{
    void Draw();
}

public interface IScalable
{
    void Scale(double factor);
}

// Класс, реализующий несколько интерфейсов
public class Rectangle : IDrawable, IScalable
{
    public double Width { get; private set; }
    public double Height { get; private set; }
    
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }
    
    public void Draw()
    {
        Console.WriteLine($"Рисуем прямоугольник {Width}x{Height}");
    }
    
    public void Scale(double factor)
    {
        Width *= factor;
        Height *= factor;
    }
}

public class Circle : IDrawable, IScalable
{
    public double Radius { get; private set; }
    
    public Circle(double radius)
    {
        Radius = radius;
    }
    
    public void Draw()
    {
        Console.WriteLine($"Рисуем круг радиусом {Radius}");
    }
    
    public void Scale(double factor)
    {
        Radius *= factor;
    }
}

// Использование полиморфизма через интерфейсы
public void DrawShapes(IDrawable[] shapes)
{
    foreach (var shape in shapes)
    {
        shape.Draw();
    }
}

public void ScaleShapes(IScalable[] shapes, double factor)
{
    foreach (var shape in shapes)
    {
        shape.Scale(factor);
    }
}
```

Интерфейсы позволяют классам, не связанным наследованием, иметь общее поведение через контракты методов.

## 3. Полиморфизм времени компиляции (статический полиморфизм)

### Перегрузка методов

Один из видов статического полиморфизма — перегрузка методов, когда в одном классе определяются несколько методов с одинаковым именем, но разными параметрами.

```csharp
public class Calculator
{
    // Перегруженные методы Add
    public int Add(int a, int b)
    {
        return a + b;
    }
    
    public double Add(double a, double b)
    {
        return a + b;
    }
    
    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
    
    public string Add(string a, string b)
    {
        return a + b;  // Конкатенация строк
    }
}

// Использование
var calc = new Calculator();
int sum1 = calc.Add(5, 10);             // Вызов первого метода
double sum2 = calc.Add(5.5, 10.3);      // Вызов второго метода
int sum3 = calc.Add(5, 10, 15);         // Вызов третьего метода
string combined = calc.Add("Hello ", "World"); // Вызов четвертого метода
```

Компилятор определяет, какой именно метод вызвать, на основе типов и количества передаваемых аргументов.

### Перегрузка операторов

C# также позволяет перегружать операторы для пользовательских типов:

```csharp
public struct Vector2D
{
    public double X { get; }
    public double Y { get; }
    
    public Vector2D(double x, double y)
    {
        X = x;
        Y = y;
    }
    
    // Перегрузка оператора сложения
    public static Vector2D operator +(Vector2D a, Vector2D b)
    {
        return new Vector2D(a.X + b.X, a.Y + b.Y);
    }
    
    // Перегрузка оператора умножения на скаляр
    public static Vector2D operator *(Vector2D v, double scalar)
    {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Перегрузка оператора равенства
    public static bool operator ==(Vector2D a, Vector2D b)
    {
        return a.X == b.X && a.Y == b.Y;
    }
    
    public static bool operator !=(Vector2D a, Vector2D b)
    {
        return !(a == b);
    }
    
    // Необходимо переопределить Equals и GetHashCode
    public override bool Equals(object obj)
    {
        if (obj is Vector2D v)
            return this == v;
        return false;
    }
    
    public override int GetHashCode()
    {
        return X.GetHashCode() ^ Y.GetHashCode();
    }
}

// Использование
var v1 = new Vector2D(3, 4);
var v2 = new Vector2D(1, 2);
var v3 = v1 + v2;         // Используется перегруженный оператор +
var v4 = v1 * 2.5;        // Используется перегруженный оператор *
bool areEqual = v1 == v2; // Используется перегруженный оператор ==
```

## 4. Расширенные возможности полиморфизма в C\#

### Сокрытие методов (Hiding)

Помимо переопределения, C# поддерживает сокрытие методов базового класса с помощью ключевого слова `new`:

```csharp
public class BaseClass
{
    public void Display()
    {
        Console.WriteLine("Метод базового класса");
    }
}

public class DerivedClass : BaseClass
{
    // Скрывает (не переопределяет!) метод базового класса
    public new void Display()
    {
        Console.WriteLine("Метод производного класса");
    }
}

// Использование
BaseClass baseObj = new BaseClass();
baseObj.Display();  // "Метод базового класса"

DerivedClass derivedObj = new DerivedClass();
derivedObj.Display();  // "Метод производного класса"

// При приведении типа вызывается метод базового класса
BaseClass polymorphicObj = new DerivedClass();
polymorphicObj.Display();  // "Метод базового класса" (!)
```

Это отличается от переопределения (`override`), где для объекта производного класса, приведенного к базовому типу, всё равно будет вызван переопределенный метод.

### Ковариантность и контравариантность

C# поддерживает [[Ковариантность (covariance)|ковариантность]] и [[Контравариантность (contra-variance)|контравариантность]] для обобщений (generics), что дает дополнительную гибкость при использовании полиморфизма:

```csharp
// Ковариантность с интерфейсом IEnumerable<out T>
IEnumerable<string> strings = new List<string>();
IEnumerable<object> objects = strings;  // Допустимо благодаря ковариантности

// Контравариантность с интерфейсом Action<in T>
Action<object> objectAction = obj => Console.WriteLine(obj);
Action<string> stringAction = objectAction;  // Допустимо благодаря контравариантности
```

Ключевые слова `out` и `in` в определении обобщенных интерфейсов указывают на ковариантность и контравариантность соответственно:

```csharp
interface IProducer<out T> { T Produce(); }  // Ковариантность
interface IConsumer<in T> { void Consume(T item); }  // Контравариантность
```

### Динамическое связывание

C# 4.0 ввел тип `dynamic`, позволяющий обходить статическую типизацию и реализовывать полиморфизм через динамическое связывание:

```csharp
public class DynamicExample
{
    public void Process(dynamic value)
    {
        // Метод, вызываемый на value, определяется во время выполнения
        value.DoSomething();
    }
}

public class ClassA
{
    public void DoSomething()
    {
        Console.WriteLine("ClassA.DoSomething()");
    }
}

public class ClassB
{
    public void DoSomething()
    {
        Console.WriteLine("ClassB.DoSomething()");
    }
}

// Использование
var example = new DynamicExample();
example.Process(new ClassA());  // Выведет "ClassA.DoSomething()"
example.Process(new ClassB());  // Выведет "ClassB.DoSomething()"
```

## 5. Практические примеры применения полиморфизма

### Архитектура MVC (модель-представление-контроллер)

```csharp
// Абстрактная модель представления
public abstract class ViewModel
{
    public abstract void Validate();
    public abstract void Save();
}

// Конкретные реализации
public class UserViewModel : ViewModel
{
    public string Username { get; set; }
    public string Email { get; set; }
    
    public override void Validate()
    {
        // Специфичная для пользователя валидация
    }
    
    public override void Save()
    {
        // Сохранение пользователя
    }
}

public class ProductViewModel : ViewModel
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    
    public override void Validate()
    {
        // Специфичная для продукта валидация
    }
    
    public override void Save()
    {
        // Сохранение продукта
    }
}

// Общий код для обработки любых моделей представления
public class FormController
{
    public void ProcessForm(ViewModel viewModel)
    {
        viewModel.Validate();
        viewModel.Save();
    }
}
```

### Стратегия обработки платежей

```csharp
public interface IPaymentProcessor
{
    bool ProcessPayment(decimal amount);
}

public class CreditCardProcessor : IPaymentProcessor
{
    public bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Обработка платежа кредитной картой на сумму {amount}");
        // Логика обработки платежа кредитной картой
        return true;
    }
}

public class PayPalProcessor : IPaymentProcessor
{
    public bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Обработка платежа через PayPal на сумму {amount}");
        // Логика обработки платежа через PayPal
        return true;
    }
}

public class BankTransferProcessor : IPaymentProcessor
{
    public bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Обработка банковского перевода на сумму {amount}");
        // Логика обработки банковского перевода
        return true;
    }
}

// Использование различных стратегий
public class CheckoutService
{
    private readonly IPaymentProcessor _paymentProcessor;
    
    public CheckoutService(IPaymentProcessor paymentProcessor)
    {
        _paymentProcessor = paymentProcessor;
    }
    
    public bool Checkout(decimal totalAmount)
    {
        // Общая логика оформления заказа
        
        // Полиморфный вызов
        return _paymentProcessor.ProcessPayment(totalAmount);
    }
}
```

## Заключение

Полиморфизм в C# предоставляет гибкие возможности для создания расширяемых и поддерживаемых приложений:

1. **Динамический полиморфизм** (наследование, виртуальные и абстрактные методы) позволяет специализировать поведение для конкретных подклассов
2. **Полиморфизм через интерфейсы** обеспечивает гибкость за счет контрактов поведения
3. **Статический полиморфизм** (перегрузка методов и операторов) улучшает читаемость и удобство использования кода

Понимание и правильное применение полиморфизма является ключевым навыком для разработки гибких и расширяемых систем на C#.