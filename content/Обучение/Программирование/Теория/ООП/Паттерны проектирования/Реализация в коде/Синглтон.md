```csharp
using System;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Text.Json;
using System.Threading;

// 1. Потокобезопасный Singleton с ленивой инициализацией для конфигурации
public sealed class AppConfiguration
{
    // Использование Lazy<T> для потокобезопасной ленивой инициализации
    private static readonly Lazy<AppConfiguration> _instance = 
        new Lazy<AppConfiguration>(() => new AppConfiguration(), LazyThreadSafetyMode.ExecutionAndPublication);

    // Публичный статический экземпляр
    public static AppConfiguration Instance => _instance.Value;

    // Приватный конструктор
    private AppConfiguration()
    {
        LoadConfiguration();
    }

    // Поля для хранения конфигурации
    public string DatabaseConnectionString { get; private set; }
    public bool EnableLogging { get; private set; }
    public int MaxCacheSize { get; private set; }

    // Метод загрузки конфигурации
    private void LoadConfiguration()
    {
        // Эмуляция загрузки конфигурации из файла или внешнего источника
        DatabaseConnectionString = Environment.GetEnvironmentVariable("DB_CONNECTION") ?? "default_connection_string";
        EnableLogging = bool.TryParse(Environment.GetEnvironmentVariable("ENABLE_LOGGING"), out bool logging) && logging;
        MaxCacheSize = int.TryParse(Environment.GetEnvironmentVariable("MAX_CACHE_SIZE"), out int cacheSize) 
            ? cacheSize 
            : 1000;
    }

    // Метод обновления конфигурации (с осторожностью в многопоточной среде)
    public void Reload()
    {
        LoadConfiguration();
    }
}

// 2. Singleton для HTTP-клиента с возможностью переиспользования соединений
public sealed class HttpClientSingleton
{
    // Статическое поле для HttpClient
    private static readonly Lazy<HttpClient> _instance = new Lazy<HttpClient>(() =>
    {
        var handler = new HttpClientHandler
        {
            MaxConnectionsPerServer = 10,
            // Дополнительные настройки обработчика
            UseDefaultCredentials = false
        };

        return new HttpClient(handler)
        {
            Timeout = TimeSpan.FromSeconds(30)
        };
    }, LazyThreadSafetyMode.ExecutionAndPublication);

    // Публичный статический метод получения экземпляра
    public static HttpClient Instance => _instance.Value;

    // Приватный конструктор для предотвращения создания экземпляров
    private HttpClientSingleton() { }

    // Метод для выполнения GET-запроса
    public static async Task<string> GetAsync(string url)
    {
        try
        {
            return await Instance.GetStringAsync(url);
        }
        catch (Exception ex)
        {
            // Логирование ошибки
            Console.WriteLine($"Ошибка при выполнении запроса: {ex.Message}");
            throw;
        }
    }
}

// 3. Потокобезопасный Singleton для подключения к базе данных
public sealed class DatabaseConnectionPool
{
    // Синглтон с использованием Lazy<T>
    private static readonly Lazy<DatabaseConnectionPool> _instance = 
        new Lazy<DatabaseConnectionPool>(() => new DatabaseConnectionPool(), LazyThreadSafetyMode.ExecutionAndPublication);

    // Публичный статический экземпляр
    public static DatabaseConnectionPool Instance => _instance.Value;

    // Семафор для ограничения количества соединений
    private readonly SemaphoreSlim _connectionSemaphore;

    // Приватный список соединений
    private readonly Queue<IDbConnection> _connectionPool;
    private readonly int _maxConnections;

    // Приватный конструктор
    private DatabaseConnectionPool()
    {
        _maxConnections = 10; // Максимальное количество соединений
        _connectionPool = new Queue<IDbConnection>(_maxConnections);
        _connectionSemaphore = new SemaphoreSlim(_maxConnections);

        // Инициализация пула соединений
        InitializeConnectionPool();
    }

    // Инициализация пула соединений
    private void InitializeConnectionPool()
    {
        for (int i = 0; i < _maxConnections; i++)
        {
            _connectionPool.Enqueue(CreateNewConnection());
        }
    }

    // Создание нового соединения
    private IDbConnection CreateNewConnection()
    {
        // Эмуляция создания соединения с базой данных
        return new DbConnection(AppConfiguration.Instance.DatabaseConnectionString);
    }

    // Получение соединения из пула
    public async Task<IDbConnection> AcquireConnectionAsync()
    {
        await _connectionSemaphore.WaitAsync();
        try
        {
            return _connectionPool.Dequeue();
        }
        catch
        {
            // Если пул пуст, создаем новое соединение
            return CreateNewConnection();
        }
    }

    // Возврат соединения в пул
    public void ReleaseConnection(IDbConnection connection)
    {
        _connectionPool.Enqueue(connection);
        _connectionSemaphore.Release();
    }
}

// 4. Singleton для централизованного логгирования
public sealed class ApplicationLogger
{
    // Потокобезопасный singleton с использованием Lazy<T>
    private static readonly Lazy<ApplicationLogger> _instance = 
        new Lazy<ApplicationLogger>(() => new ApplicationLogger(), LazyThreadSafetyMode.ExecutionAndPublication);

    // Публичный статический экземпляр
    public static ApplicationLogger Instance => _instance.Value;

    // Внутренний логгер
    private readonly ILogger _logger;

    // Приватный конструктор
    private ApplicationLogger()
    {
        // Настройка логгирования
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder
                .AddConsole() // Логирование в консоль
                .AddFilter(LogLevel.Information); // Минимальный уровень логирования
        });

        _logger = loggerFactory.CreateLogger("ApplicationLogger");
    }

    // Методы логирования
    public void LogInfo(string message) => 
        _logger.LogInformation(message);

    public void LogError(string message, Exception ex = null) => 
        _logger.LogError(ex, message);

    public void LogWarning(string message) => 
        _logger.LogWarning(message);
}

// 5. Потокобезопасный Singleton с внедрением зависимостей
public interface ICacheService
{
    void Set(string key, object value);
    object Get(string key);
    void Clear();
}

public sealed class DistributedCacheSingleton : ICacheService
{
    // Потокобезопасный singleton с использованием Lazy<T>
    private static readonly Lazy<DistributedCacheSingleton> _instance = 
        new Lazy<DistributedCacheSingleton>(() => new DistributedCacheSingleton(), LazyThreadSafetyMode.ExecutionAndPublication);

    // Публичный статический экземпляр
    public static DistributedCacheSingleton Instance => _instance.Value;

    // Внутренний кэш
    private readonly ConcurrentDictionary<string, object> _cache;
    private readonly int _maxSize;

    // Приватный конструктор
    private DistributedCacheSingleton()
    {
        _cache = new ConcurrentDictionary<string, object>();
        _maxSize = AppConfiguration.Instance.MaxCacheSize;
    }

    // Реализация методов ICacheService
    public void Set(string key, object value)
    {
        // Проверка размера кэша перед добавлением
        if (_cache.Count >= _maxSize)
        {
            // Стратегия замещения - удаление старых записей
            var oldestKey = _cache.Keys.FirstOrDefault();
            if (oldestKey != null)
            {
                _cache.TryRemove(oldestKey, out _);
            }
        }

        _cache[key] = value;
    }

    public object Get(string key)
    {
        return _cache.TryGetValue(key, out var value) ? value : null;
    }

    public void Clear()
    {
        _cache.Clear();
    }
}

// Вспомогательные классы для демонстрации
public interface IDbConnection 
{
    // Интерфейс подключения к базе данных
    void Open();
    void Close();
}

public class DbConnection : IDbConnection
{
    private readonly string _connectionString;

    public DbConnection(string connectionString)
    {
        _connectionString = connectionString;
    }

    public void Open()
    {
        Console.WriteLine($"Opening connection to {_connectionString}");
    }

    public void Close()
    {
        Console.WriteLine("Closing database connection");
    }
}

// Пример использования
public class Program
{
    public static async Task Main(string[] args)
    {
        // Демонстрация использования Singleton-ов

        // 1. Конфигурация приложения
        var config = AppConfiguration.Instance;
        Console.WriteLine($"DB Connection: {config.DatabaseConnectionString}");
        Console.WriteLine($"Logging Enabled: {config.EnableLogging}");

        // 2. HTTP-клиент
        try 
        {
            var response = await HttpClientSingleton.GetAsync("https://api.example.com/data");
            Console.WriteLine($"Response: {response}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"HTTP Request failed: {ex.Message}");
        }

        // 3. Пул подключений к базе данных
        var dbConnection = await DatabaseConnectionPool.Instance.AcquireConnectionAsync();
        dbConnection.Open();
        // Работа с соединением
        DatabaseConnectionPool.Instance.ReleaseConnection(dbConnection);

        // 4. Централизованное логирование
        var logger = ApplicationLogger.Instance;
        logger.LogInfo("Application started");
        logger.LogError("Sample error message");

        // 5. Распределенный кэш
        var cache = DistributedCacheSingleton.Instance;
        cache.Set("key1", "value1");
        var cachedValue = cache.Get("key1");
        Console.WriteLine($"Cached Value: {cachedValue}");
    }
}
```