Инкапсуляция — это сокрытие внутренней реализации объекта и предоставление контролируемого доступа к его состоянию через публичный интерфейс.

## Что такое инкапсуляция на самом деле

### Это НЕ просто `private` поля

```cs
// ❌ Это НЕ инкапсуляция, а просто сокрытие
public class User
{
    private string name;
    private int age;
    
    // Геттеры/сеттеры без логики = бесполезная инкапсуляция
    public string GetName() => name;
    public void SetName(string value) => name = value;
    public int GetAge() => age;
    public void SetAge(int value) => age = value;
}
```

### Это контроль доступа и защита инвариантов

```cs
// ✅ Правильная инкапсуляция - защищаем правила бизнеса
public class User
{
    private string _name;
    private int _age;
    private readonly List<string> _roles = new();
    
    public string Name 
    { 
        get => _name;
        private set => _name = !string.IsNullOrWhiteSpace(value) 
            ? value.Trim() 
            : throw new ArgumentException("Имя не может быть пустым");
    }
    
    public int Age 
    { 
        get => _age;
        private set => _age = value >= 0 && value <= 150 
            ? value 
            : throw new ArgumentOutOfRangeException("Некорректный возраст");
    }
    
    public IReadOnlyList<string> Roles => _roles.AsReadOnly();
    
    public User(string name, int age)
    {
        Name = name;  // Используем свойство для валидации
        Age = age;    // Используем свойство для валидации
    }
    
    // Контролируемое изменение состояния
    public void AddRole(string role)
    {
        if (string.IsNullOrWhiteSpace(role))
            throw new ArgumentException("Роль не может быть пустой");
            
        if (_roles.Contains(role))
            return; // Дубликаты не добавляем
            
        _roles.Add(role.Trim());
    }
    
    public void RemoveRole(string role)
    {
        _roles.Remove(role);
    }
    
    // Нельзя стать младше
    public void CelebrateBirthday()
    {
        Age++; // Используем свойство для проверки
    }
}
```

## Уровни доступа в C# и их правильное использование

### Продакшн примеры модификаторов доступа

```cs
public class OrderService
{
    // private - только внутри класса
    private readonly IOrderRepository _repository;
    private readonly Dictionary<int, Order> _cache = new();
    
    // protected - наследники могут использовать
    protected readonly ILogger Logger;
    
    // internal - только в рамках сборки (для тестов)
    internal ValidationResult ValidateOrder(Order order)
    {
        return new ValidationResult();
    }
    
    // public - внешний API
    public async Task<Order> CreateOrderAsync(CreateOrderRequest request)
    {
        // Валидация через private метод
        var validationResult = ValidateOrderInternal(request);
        if (!validationResult.IsValid)
            throw new ValidationException(validationResult.Errors);
            
        var order = new Order(request.CustomerId, request.Items);
        await _repository.SaveAsync(order);
        
        // Кэширование через private метод
        CacheOrder(order);
        
        return order;
    }
    
    // private - детали реализации скрыты
    private ValidationResult ValidateOrderInternal(CreateOrderRequest request)
    {
        var errors = new List<string>();
        
        if (request.CustomerId <= 0)
            errors.Add("Некорректный ID клиента");
            
        if (!request.Items?.Any() == true)
            errors.Add("Заказ должен содержать товары");
            
        return new ValidationResult(errors);
    }
    
    private void CacheOrder(Order order)
    {
        if (_cache.Count > 100) // Простое управление размером кэша
            _cache.Clear();
            
        _cache[order.Id] = order;
    }
}
```

## Примеры правильной инкапсуляции из продакшна

### 1. Доменная модель - Aggregate Root

```cs
public class Order
{
    private readonly List<OrderItem> _items = new();
    private OrderStatus _status = OrderStatus.Draft;
    
    public int Id { get; private set; }
    public int CustomerId { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public OrderStatus Status => _status;
    public decimal TotalAmount => _items.Sum(i => i.Price * i.Quantity);
    public IReadOnlyList<OrderItem> Items => _items.AsReadOnly();
    
    // Конструктор контролирует создание
    public Order(int customerId, IEnumerable<OrderItem> items)
    {
        if (customerId <= 0)
            throw new ArgumentException("CustomerId должен быть положительным");
            
        if (!items?.Any() == true)
            throw new ArgumentException("Заказ должен содержать товары");
            
        CustomerId = customerId;
        CreatedAt = DateTime.UtcNow;
        
        foreach (var item in items)
        {
            AddItemInternal(item); // Используем internal метод для валидации
        }
    }
    
    // Контролируемое изменение состояния
    public void AddItem(int productId, int quantity, decimal price)
    {
        if (_status != OrderStatus.Draft)
            throw new InvalidOperationException("Нельзя изменить подтвержденный заказ");
            
        var item = new OrderItem(productId, quantity, price);
        AddItemInternal(item);
    }
    
    public void RemoveItem(int productId)
    {
        if (_status != OrderStatus.Draft)
            throw new InvalidOperationException("Нельзя изменить подтвержденный заказ");
            
        _items.RemoveAll(i => i.ProductId == productId);
    }
    
    public void Confirm()
    {
        if (_status != OrderStatus.Draft)
            throw new InvalidOperationException($"Нельзя подтвердить заказ в статусе {_status}");
            
        if (!_items.Any())
            throw new InvalidOperationException("Нельзя подтвердить пустой заказ");
            
        _status = OrderStatus.Confirmed;
    }
    
    public void Ship()
    {
        if (_status != OrderStatus.Confirmed)
            throw new InvalidOperationException($"Нельзя отправить заказ в статусе {_status}");
            
        _status = OrderStatus.Shipped;
    }
    
    // private - инварианты и детали реализации
    private void AddItemInternal(OrderItem item)
    {
        if (item == null)
            throw new ArgumentNullException(nameof(item));
            
        // Проверяем, нет ли уже такого товара
        var existingItem = _items.FirstOrDefault(i => i.ProductId == item.ProductId);
        if (existingItem != null)
        {
            // Обновляем количество существующего товара
            existingItem.UpdateQuantity(existingItem.Quantity + item.Quantity);
        }
        else
        {
            _items.Add(item);
        }
    }
}

public class OrderItem
{
    public int ProductId { get; private set; }
    public int Quantity { get; private set; }
    public decimal Price { get; private set; }
    
    public OrderItem(int productId, int quantity, decimal price)
    {
        if (productId <= 0)
            throw new ArgumentException("ProductId должен быть положительным");
        if (quantity <= 0)
            throw new ArgumentException("Quantity должно быть положительным");
        if (price < 0)
            throw new ArgumentException("Price не может быть отрицательной");
            
        ProductId = productId;
        Quantity = quantity;
        Price = price;
    }
    
    internal void UpdateQuantity(int newQuantity)
    {
        if (newQuantity <= 0)
            throw new ArgumentException("Quantity должно быть положительным");
            
        Quantity = newQuantity;
    }
}
```

### 2. Service с инкапсулированной бизнес-логикой

```cs
public class BankAccount
{
    private decimal _balance;
    private readonly List<Transaction> _transactions = new();
    private readonly object _lock = new object();
    
    public string AccountNumber { get; private set; }
    public decimal Balance 
    { 
        get 
        { 
            lock (_lock) 
            { 
                return _balance; 
            }
        }
    }
    public IReadOnlyList<Transaction> Transactions 
    { 
        get 
        { 
            lock (_lock) 
            { 
                return _transactions.ToList().AsReadOnly(); 
            }
        }
    }
    
    public BankAccount(string accountNumber, decimal initialBalance = 0)
    {
        if (string.IsNullOrWhiteSpace(accountNumber))
            throw new ArgumentException("Номер счета не может быть пустым");
        if (initialBalance < 0)
            throw new ArgumentException("Начальный баланс не может быть отрицательным");
            
        AccountNumber = accountNumber;
        _balance = initialBalance;
        
        if (initialBalance > 0)
        {
            RecordTransaction(TransactionType.Deposit, initialBalance, "Начальный взнос");
        }
    }
    
    // Публичные методы с бизнес-правилами
    public void Deposit(decimal amount, string description = "")
    {
        ValidateAmount(amount);
        
        lock (_lock)
        {
            _balance += amount;
            RecordTransaction(TransactionType.Deposit, amount, description);
        }
    }
    
    public void Withdraw(decimal amount, string description = "")
    {
        ValidateAmount(amount);
        
        lock (_lock)
        {
            if (_balance < amount)
                throw new InvalidOperationException("Недостаточно средств на счете");
                
            _balance -= amount;
            RecordTransaction(TransactionType.Withdrawal, amount, description);
        }
    }
    
    public void Transfer(BankAccount targetAccount, decimal amount, string description = "")
    {
        if (targetAccount == null)
            throw new ArgumentNullException(nameof(targetAccount));
        if (targetAccount == this)
            throw new ArgumentException("Нельзя переводить на тот же счет");
            
        // Атомарная операция для двух счетов
        var lockOrder = string.Compare(AccountNumber, targetAccount.AccountNumber) < 0
            ? new[] { _lock, targetAccount._lock }
            : new[] { targetAccount._lock, _lock };
            
        lock (lockOrder[0])
        {
            lock (lockOrder[1])
            {
                Withdraw(amount, $"Перевод на {targetAccount.AccountNumber}: {description}");
                targetAccount.Deposit(amount, $"Перевод с {AccountNumber}: {description}");
            }
        }
    }
    
    // private - детали реализации и инварианты
    private void ValidateAmount(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Сумма должна быть положительной");
        if (amount > 1_000_000)
            throw new ArgumentException("Сумма слишком большая");
    }
    
    private void RecordTransaction(TransactionType type, decimal amount, string description)
    {
        // Метод вызывается уже внутри lock, поэтому безопасен
        var transaction = new Transaction
        {
            Id = Guid.NewGuid(),
            Type = type,
            Amount = amount,
            Description = description,
            Timestamp = DateTime.UtcNow,
            BalanceAfter = _balance
        };
        
        _transactions.Add(transaction);
        
        // Ограничиваем историю транзакций
        if (_transactions.Count > 1000)
        {
            _transactions.RemoveRange(0, 100); // Удаляем старые
        }
    }
}
```

## Антипаттерны инкапсуляции

### 1. ❌ Anemic Domain Model - "Анемичная" модель

```cs
// Плохо - класс без поведения, только данные
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
    public bool IsActive { get; set; }
}

// Вся логика в сервисах - нарушение инкапсуляции!
public class ProductService
{
    public void DeactivateProduct(Product product)
    {
        if (product.Stock > 0)
            throw new InvalidOperationException("Нельзя деактивировать товар с остатками");
            
        product.IsActive = false;
    }
    
    public void UpdatePrice(Product product, decimal newPrice)
    {
        if (newPrice <= 0)
            throw new ArgumentException("Цена должна быть положительной");
            
        product.Price = newPrice;
    }
}
```

### 2. ✅ Rich Domain Model - Правильная инкапсуляция

```cs
public class Product
{
    public int Id { get; private set; }
    public string Name { get; private set; }
    public decimal Price { get; private set; }
    public int Stock { get; private set; }
    public bool IsActive { get; private set; }
    
    public Product(string name, decimal price, int initialStock)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Название товара не может быть пустым");
        if (price <= 0)
            throw new ArgumentException("Цена должна быть положительной");
        if (initialStock < 0)
            throw new ArgumentException("Начальный остаток не может быть отрицательным");
            
        Name = name;
        Price = price;
        Stock = initialStock;
        IsActive = true;
    }
    
    // Бизнес-логика инкапсулирована в модели
    public void UpdatePrice(decimal newPrice)
    {
        if (newPrice <= 0)
            throw new ArgumentException("Цена должна быть положительной");
        if (newPrice == Price)
            return; // Нет изменений
            
        Price = newPrice;
    }
    
    public void AddStock(int quantity)
    {
        if (quantity <= 0)
            throw new ArgumentException("Количество должно быть положительным");
            
        Stock += quantity;
    }
    
    public void ReserveStock(int quantity)
    {
        if (quantity <= 0)
            throw new ArgumentException("Количество должно быть положительным");
        if (Stock < quantity)
            throw new InvalidOperationException("Недостаточно товара на складе");
        if (!IsActive)
            throw new InvalidOperationException("Нельзя резервировать неактивный товар");
            
        Stock -= quantity;
    }
    
    public void Deactivate()
    {
        if (Stock > 0)
            throw new InvalidOperationException("Нельзя деактивировать товар с остатками на складе");
            
        IsActive = false;
    }
    
    public void Activate()
    {
        IsActive = true;
    }
}
```

### 3. ❌ Неправильная инкапсуляция коллекций

```cs
// Плохо - внешний код может изменить внутреннее состояние
public class Team
{
    public List<Player> Players { get; set; } = new();
    
    public void AddPlayer(Player player)
    {
        Players.Add(player);
    }
}

// Проблема:
var team = new Team();
team.Players.Add(new Player("Hacker")); // Обход валидации!
team.Players.Clear(); // Можем сломать состояние!
```

### 4. ✅ Правильная инкапсуляция коллекций

```cs
public class Team
{
    private readonly List<Player> _players = new();
    private const int MaxPlayers = 11;
    
    public IReadOnlyList<Player> Players => _players.AsReadOnly();
    public int PlayersCount => _players.Count;
    public bool IsFull => _players.Count >= MaxPlayers;
    
    public void AddPlayer(Player player)
    {
        if (player == null)
            throw new ArgumentNullException(nameof(player));
        if (_players.Count >= MaxPlayers)
            throw new InvalidOperationException($"В команде не может быть больше {MaxPlayers} игроков");
        if (_players.Any(p => p.Id == player.Id))
            throw new InvalidOperationException("Игрок уже в команде");
            
        _players.Add(player);
    }
    
    public void RemovePlayer(int playerId)
    {
        var player = _players.FirstOrDefault(p => p.Id == playerId);
        if (player == null)
            throw new ArgumentException("Игрок не найден в команде");
            
        _players.Remove(player);
    }
    
    public Player GetCaptain()
    {
        return _players.FirstOrDefault(p => p.IsCaptain);
    }
    
    public void SetCaptain(int playerId)
    {
        // Снимаем капитанство с текущего капитана
        var currentCaptain = GetCaptain();
        currentCaptain?.RemoveCaptaincy();
        
        // Назначаем нового капитана
        var newCaptain = _players.FirstOrDefault(p => p.Id == playerId);
        if (newCaptain == null)
            throw new ArgumentException("Игрок не найден в команде");
            
        newCaptain.MakeCaptain();
    }
}
```

## Современные возможности C# для инкапсуляции

### 1. Init-only свойства (C# 9.0) (читай [[ctor · private set vs init|заметку]])

```cs
public class Person
{
    public string Name { get; init; }
    public DateTime BirthDate { get; init; }
    
    // Вычисляемое свойство на основе неизменяемых данных
    public int Age => DateTime.Now.Year - BirthDate.Year;
}

// Можно установить только при создании
var person = new Person { Name = "John", BirthDate = new DateTime(1990, 1, 1) };
// person.Name = "Jane"; // ❌ Ошибка компиляции
```

### 2. Records (C# 9.0)

```cs
// Неизменяемая модель с автоматической инкапсуляцией
public record Money(decimal Amount, string Currency)
{
    // Валидация в конструкторе
    public Money(decimal Amount, string Currency) : this(Amount, Currency)
    {
        if (Amount < 0)
            throw new ArgumentException("Сумма не может быть отрицательной");
        if (string.IsNullOrWhiteSpace(Currency))
            throw new ArgumentException("Валюта должна быть указана");
    }
    
    // Методы для работы с деньгами
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Нельзя складывать разные валюты");
            
        return this with { Amount = Amount + other.Amount };
    }
}
```

### 3. Required модификатор (C# 11.0)

```cs
public class User
{
    public required string Name { get; init; }
    public required string Email { get; init; }
    public string? Phone { get; init; }
    
    private string _normalizedEmail;
    
    // Инкапсулируем логику нормализации
    public string NormalizedEmail => _normalizedEmail ??= Email.ToLowerInvariant().Trim();
}

// Компилятор заставит указать обязательные свойства
var user = new User 
{ 
    Name = "John", 
    Email = "john@example.com" // Phone опционален
};
```

## Принципы правильной инкапсуляции

1. **Скрывайте реализацию, показывайте интерфейс**
2. **Защищайте инварианты класса**
3. **Валидируйте входные данные**
4. **Предоставляйте безопасный доступ к коллекциям**
5. **Группируйте связанные данные и поведение**
6. **Используйте наименее доступный модификатор**

Инкапсуляция — это не просто `private` поля, а архитектурный принцип, который помогает создавать надежные и поддерживаемые системы.