![[Pasted image 20250506141029.png]]

```chsarp
//1) Что выведет программа в консоль
// как переписать, чтобы все прибавки работали

struct ObjectA
{
public int number;
}

class ObjectB
{
public int number;
}

void MethodA(ObjectA o)
{
o.number+ 1;
}

void MethodB (ObjectB o)
{
o = new ObjectB
{
number = 2
};
var objectA new ObjectA();
MethodA(objectA);
var objectB= new ObjectB();

MethodB (objectB);

Console.WriteLine(objectA.number);
Console.WriteLine(objectB.number);
```


![[Pasted image 20250506141810.png]]

![[Pasted image 20250506142519.png]]

![[Pasted image 20250506142922.png]]

ничего не выведет (нужно больше пройтись по таким примерам)

![[Pasted image 20250506144223.png]]

![[Pasted image 20250506144705.png]]

как реализовать метод Where как в linq


![[Pasted image 20250506145100.png]]

```csharp
public static IEnumerable<T> TestMethod<T>(IEnumerable<T> collection, int n)
{
    var queue = new Queue<T>(n + 1); // Store the last n+1 elements

    foreach (var item in collection)
    {
        queue.Enqueue(item);

        if (queue.Count > n)
        {
            yield return queue.Dequeue();
        }
    }
}
```

![[Pasted image 20250506145448.png]]

```csharp
public int[] Sum(int[] nums, int target)
{
    Dictionary<int, int> numMap = new Dictionary<int, int>();

    for (int i = 0; i < nums.Length; i++)
    {
        int complement = target - nums[i];
        if (numMap.ContainsKey(complement))
        {
            return new int[] { numMap[complement], i };
        }

        if (!numMap.ContainsKey(nums[i])) // Avoid adding duplicate numbers, keep the earlier index
        {
           numMap[nums[i]] = i;
        }
    }

    return new int[] { };
}
```

![[Pasted image 20250506150320.png]]

![[Pasted image 20250506150931.png]]





