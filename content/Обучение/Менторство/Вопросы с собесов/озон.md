![[Pasted image 20250701153347.png]]

```csharp
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

public class Response
{
}

public interface IClient
{
    Task<Response> GetAsync(long id);
}

public static class ClientExtensions
{
    // Подход 1: Использование SemaphoreSlim (самый простой и эффективный)
    public static async Task<Response[]> GetArrayAsync(this IClient client, long[] ids, int maxDegreeOfParallelism)
    {
        using var semaphore = new SemaphoreSlim(maxDegreeOfParallelism, maxDegreeOfParallelism);
        var tasks = ids.Select(async id =>
        {
            await semaphore.WaitAsync();
            try
            {
                return await client.GetAsync(id);
            }
            finally
            {
                semaphore.Release();
            }
        });

        return await Task.WhenAll(tasks);
    }

    // Подход 2: Использование Parallel.ForEach с async (более контролируемый)
    public static async Task<Response[]> GetArrayAsyncWithParallel(this IClient client, long[] ids, int maxDegreeOfParallelism)
    {
        var results = new ConcurrentDictionary<int, Response>();
        var parallelOptions = new ParallelOptions
        {
            MaxDegreeOfParallelism = maxDegreeOfParallelism
        };

        await Task.Run(() =>
        {
            Parallel.ForEach(
                ids.Select((id, index) => new { Id = id, Index = index }),
                parallelOptions,
                async item =>
                {
                    var response = await client.GetAsync(item.Id);
                    results[item.Index] = response;
                });
        });

        // Восстанавливаем порядок элементов
        return ids.Select((_, index) => results[index]).ToArray();
    }

    // Подход 3: Батчинг - разделение на группы и последовательная обработка батчей
    public static async Task<Response[]> GetArrayAsyncBatching(this IClient client, long[] ids, int maxDegreeOfParallelism)
    {
        var results = new Response[ids.Length];
        
        for (int i = 0; i < ids.Length; i += maxDegreeOfParallelism)
        {
            var batch = ids.Skip(i).Take(maxDegreeOfParallelism).ToArray();
            var batchTasks = batch.Select(id => client.GetAsync(id));
            var batchResults = await Task.WhenAll(batchTasks);
            
            // Копируем результаты в правильные позиции
            Array.Copy(batchResults, 0, results, i, batchResults.Length);
        }
        
        return results;
    }

    // Подход 4: Использование Channel для контроля потока (самый гибкий)
    public static async Task<Response[]> GetArrayAsyncWithChannel(this IClient client, long[] ids, int maxDegreeOfParallelism)
    {
        var results = new Response[ids.Length];
        var channel = Channel.CreateUnbounded<(long id, int index)>();
        var writer = channel.Writer;
        var reader = channel.Reader;

        // Заполняем канал заданиями
        for (int i = 0; i < ids.Length; i++)
        {
            await writer.WriteAsync((ids[i], i));
        }
        writer.Complete();

        // Создаем воркеры
        var workers = Enumerable.Range(0, maxDegreeOfParallelism)
            .Select(async _ =>
            {
                await foreach (var (id, index) in reader.ReadAllAsync())
                {
                    results[index] = await client.GetAsync(id);
                }
            })
            .ToArray();

        await Task.WhenAll(workers);
        return results;
    }

    // Подход 5: Простое решение с ограничением через Take
    public static async Task<Response[]> GetArrayAsyncSimple(this IClient client, long[] ids, int maxDegreeOfParallelism)
    {
        var allTasks = new List<Task<Response>>();
        
        for (int i = 0; i < ids.Length; i += maxDegreeOfParallelism)
        {
            var batch = ids.Skip(i).Take(maxDegreeOfParallelism);
            var batchTasks = batch.Select(client.GetAsync);
            allTasks.AddRange(batchTasks);
            
            // Ждем завершения текущего батча перед переходом к следующему
            await Task.WhenAll(batchTasks);
        }
        
        return await Task.WhenAll(allTasks);
    }
}

// Дополнительные классы для подхода с Channel
using System.Threading.Channels;

// Пример использования:
public class ExampleUsage
{
    public static async Task Example()
    {
        IClient client = new SomeClientImplementation();
        long[] ids = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        int maxParallelism = 3;

        // Используем основной подход с SemaphoreSlim
        var responses = await client.GetArrayAsync(ids, maxParallelism);
        
        Console.WriteLine($"Получено {responses.Length} ответов");
    }
}

// Заглушка для примера
public class SomeClientImplementation : IClient
{
    public async Task<Response> GetAsync(long id)
    {
        // Имитация сетевого запроса
        await Task.Delay(100);
        return new Response();
    }
}
```

Есть удаленный сервис, который умеет отдавать ответ по id. Необходимо реализовать метод, который по массиву id отдает массив ответов, соблюдая ограничение на количество одновременно исполняемых запросов

![[Pasted image 20250701155110.png]]
```csharp

public class Response
}
public interface IClient
Task<Response> GetAsync(long id);
public static class ClientExtensions{
	public static async Task<Response[]> GetArrayAsync(this IClient client, long[] ids, int maxDegreeOfParallelism)
	{
		var semafore = new SemaforeSlim (maxDegreeOfParallelism);
		var tasks = new List<Task<Response[]>>(ids. Lenght);

		foreach (var id in ids)
		{
			await semafore.WaitOneAsync();
			var task = Task.Run(async() => 
			{
				try
				{
					return await client.GetAsync(id);
				}
				finally
				{
					semafore.Release();
				}
			});
			tasks.Add(task);
		}
		return await Task. WhenAll(tasks);
	}
}
```