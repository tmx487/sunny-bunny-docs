


- [Теория](#Теория)
	- [Junior](#Junior)
		- [Junior_Общее](#Junior_Общее)
		- [Junior_Платформа .NET](#Junior_Платформа%20.NET)
		- [Junior_Типы, структуры и коллекции данных](#Junior_Типы,%20структуры%20и%20коллекции%20данных)
		- [Junior_Классы, структуры и интерфейсы](#Junior_Классы,%20структуры%20и%20интерфейсы)
		- [Junior_Ассинхронность](#Junior_Ассинхронность)
		- [Junior_Тестирование](#Junior_Тестирование)
		- [Junior_Базы данных](#Junior_Базы%20данных)
	- [Middle](#Middle)
		- [Middle_Общее](#Middle_Общее)
		- [Middle_Платформа .NET](#Middle_Платформа%20.NET)
		- [Middle_Типы, структуры и коллекции данныreх](#Middle_Типы,%20структуры%20и%20коллекции%20данных)
		- [Middle_Управление памятью](#Middle_Управление%20памятью)
		- [Middle_Параллелизм](#Middle_Параллелизм)
		- [Middle_Базы данных](#Middle_Базы%20данных)
	- [Senior](#Senior)
		- [Senior_Общее](#Senior_Общее)
		- [Senior_Платформа .NET](#Senior_Платформа%20.NET)
		- [Senior_Типы, структуры и коллекции данных](#Senior_Типы,%20структуры%20и%20коллекции%20данных)
		- [Senior_Микросервисы](#Senior_Микросервисы)
		- [Senior_MS Azure](#Senior_MS%20Azure)
		- [Senior_Базы данных](#Senior_Базы%20данных)
- [Практика](#Практика)
	- [Junior](#Junior-Practice)
		- [JP-Задание 1](#JP-Задание%201)
		- [JP-Задание 2](#JP-Задание%202)
		- [JP-Задание 3](#JP-Задание%203)
		- [JP-Задание 4](#JP-Задание%204)
		- [JP-Задание 5](#JP-Задание%205)
		- [JP-Задание 6](#JP-Задание%206)
	- [Middle](#Middle)
		- [MP-Задание 1](#MP-Задание%201)
		- [MP-Задание 2](#MP-Задание%202)
		- [MP-Задание 3](#MP-Задание%203)
		- [MP-Задание 4](#MP-Задание%204)
		- [MP-Задание 5](#MP-Задание%205)
		- [MP-Задание 6](#MP-Задание%206)
		- [MP-Задание 7](#MP-Задание%207)
		- [MP-Задание 8](#MP-Задание%208)
		- [MP-Задание 9](#MP-Задание%209)
	- [Senior](#Senior)
		- [SP-Задание 1](#SP-Задание%201)
		- [SP-Задание 2](#SP-Задание%202)
		- [SP-Задание 3](#SP-Задание%203)
		- [SP-Задание 4](#SP-Задание%204)
		- [SP-Задание 5](#SP-Задание%205)
		- [SP-Задание 6](#SP-Задание%206)
		- [SP-Задание 7](#SP-Задание%207)

# Теория

## ==Junior==

### Junior_Общее

#### Назовите основные принципы ООП

**ООП** - парадигма программирования, в которой программа состоит из набора объектов (см. дополнительно [Как ООП помогает разработчикам писать код быстрее и проще](https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/) и [ООП](https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/))

**Основные принципы**:
- абстракция (выделение основных свойств и методов, присущих объекту)
- наследование (использование одними классами свойств и методов других классов, а также добавление своих собственных)
- полиморфизм (у нас есть разные классы, которые имеют один и тот же метод; однако, его внутренняя реализация у них всех разная)
- инкапсуляция (все, что нужно для работы какого-то объекта, должно содержаться в нем же; при этом необходимо обеспечить сокрытие доступа, т.е. для внешних объектов доступны только публичные атрибуты и методы).

> Дополнительно стоит прочесть: [# ООП в картинках](https://habr.com/ru/articles/463125/)

#### Что такое наследование, инкапсуляция, абстракция, полиморфизм: приведите примеры (желательно из собственного опыта)

Абстракция

```cs
using TeacherResource.Domain.UserAggregate;

namespace TeacherResource.Application.Persistence
{
    public interface IUserRepository
    {
        User? GetUserByEmail(string email);
        void Add(User user);
    }
}
```

Инкапсуляция

```cs
 public sealed class User : AggregateRoot<UserId, Guid>
    {
        public string Login { get; private set; }
        public string Password { get; private set; }
        public string Role { get; private set; }
	// ...
}
```

Полиморфизм

```cs
using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using TeacherResource.Domain.Common.Models;

namespace TeacherResource.Infrastructure.Persistence.Interceptors
{
    public class PublishDomainEventsInterceptor : SaveChangesInterceptor
    {
        private readonly IPublisher _mediator;

        public PublishDomainEventsInterceptor(IPublisher mediator)
        {
            _mediator = mediator;
        }

        public override InterceptionResult<int> SavingChanges(
            DbContextEventData eventData,
            InterceptionResult<int> result)
        {
            PublishDomainEvents(eventData.Context).GetAwaiter().GetResult();
            return base.SavingChanges(eventData, result);
        }

        public override async ValueTask<InterceptionResult<int>> SavingChangesAsync(
            DbContextEventData eventData,
            InterceptionResult<int> result,
            CancellationToken cancellationToken = default)
        {
            await PublishDomainEvents(eventData.Context);

            return await base.SavingChangesAsync(eventData, result, cancellationToken);
        }

        public async override ValueTask<int> SavedChangesAsync(
            SaveChangesCompletedEventData eventData,
            int result,
            CancellationToken cancellationToken = default)
        {
            await PublishDomainEvents(eventData.Context);

            return await base.SavedChangesAsync(eventData, result, cancellationToken);
        }

        private async Task PublishDomainEvents(DbContext? dbContext)
        {
            if (dbContext is null)
            {
                return;
            }

            var entitiesWithDomainEvents = dbContext.ChangeTracker.Entries<IHasDomainEvents>()
                .Where(e => e.Entity.DomainEvents.Any())
                .Select(e => e.Entity)
                .ToList();

            var domainEvents = entitiesWithDomainEvents.SelectMany(e => e.DomainEvents)
                .ToList();

            entitiesWithDomainEvents.ForEach(e => e.ClearDomainEventsList());

            foreach (var domainEvent in domainEvents)
            {
                await _mediator.Publish(domainEvent);
            }
        }
    }
}
```

**==добавить инф про виды полиморфизма==**

Наследование:
```cs
public abstract class Entity<TId>
{
	// ...
}

public abstract class AggregateRoot<TId, TIdType> : Entity<TId>
	where TId : AggregateRootId<TIdType>
{
	// ...
}
```

#### От какого класса неявно наследуются все классы в .NET?

[System.Object](https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-8.0)
	Он предоставляет [следующие методы](https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-8.0#methods).
	Открытые методы, доступные каждому объекту в CLR: **ToString(), Equals(), GetHashCode(), GetType()**
	Защищенные методы, доступные каждому объекту в CLR: **MemberwiseClone(), Finalize()**

`Equals()` возвращает `true`, если ДВА объекты имеют одинаковые значения

`GetHashCode()` следует переопределять, если объекты типа используются в качестве ключа хеш-таблицы.
#### Разрешено ли множественное наследование в C#? 

**нет** 
	в CLR у класса может быть один и только один прямой "родитель" (см. Рихтер, с. 333); однако CLR позволяет реализовывать **ограниченное множественное наследование через интерфейсы**.
#### Что такое рекурсия?

> Рекурсия не часто бывает необходима, но при аккуратном использовании она позволяет создавать элегантные решения.
> 
> Для малой группы задач рекурсия позволяет создать простые, элегантные решения. Для несколько большей группы задач она позволяет создать простые, элегантные, трудные для понимания решения. Для большинства задач она создает исключительно запутанные решения В таких случаях использование простых итераций обычно более понятно. Поэтому применяйте рекурсию выборочно.
> 
   \- МакКонелл, С., с.385-389
   
> **Советы по использованию рекурсии:**
	> - Убедитесь, что рекурсия остановится
	> - Предотвращайте бесконечную рекурсию с помощью счетчиков безопасности
	> - Ограничьте рекурсию одним методом
	> - Следите за стеком
	> - Не используйте рекурсию для факториалов и чисел Фибоначчи

#### Что такое лямбда-выражение?

> [docs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions)

> см. Рихтер, с.453 Упрощение 2

```cs
a lambda expression (=>) is being used to create an anonymous function.
	   (input-parameters) => expression
	   (input-parameters) => { <sequence-of-statements> }
```

Если лямбда-выражение не возвращает значение, оно может быть преобразовано в один из типов делегата Action; в противном случае его можно преобразовать в один из типов делегатов Func.
#### Что такое параллельное программирование (многопоточность) и его назначение? Какие классы используются?
#### Что такое JSON?

[JSON (JavaScript Onject Notation)](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON) - стандартный текстовый формат для представления структурированных данных на основе синтаксиса объектов JavaScript[^1][^2]

```json
{
  "squadName": "Super hero squad",
  "homeTown": "Metro City",
  "formed": 2016,
  "secretBase": "Super tower",
  "active": true,
  "members": [
    {
      "name": "Molecule Man",
      "age": 29,
      "secretIdentity": "Dan Jukes",
      "powers": ["Radiation resistance", "Turning tiny", "Radiation blast"]
    },
    {
      "name": "Madame Uppercut",
      "age": 39,
      "secretIdentity": "Jane Wilson",
      "powers": [
        "Million tonne punch",
        "Damage resistance",
        "Superhuman reflexes"
      ]
    },
    {
      "name": "Eternal Flame",
      "age": 1000000,
      "secretIdentity": "Unknown",
      "powers": [
        "Immortality",
        "Heat Immunity",
        "Inferno",
        "Teleportation",
        "Interdimensional travel"
      ]
    }
  ]
}
```

[^1]: JavaScript спроектирован на основе простой парадигмы. В основе концепции лежат простые объекты. **Объект** — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Значением свойства может быть функция, которую можно назвать методом объекта. В дополнение к встроенным в браузер объектам, вы можете определить свои собственные объекты (см. [подробнее](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects)).
[^2]: [RFC 8259: The JavaScript Object Notation (JSON) Data Interchange Format](https://datatracker.ietf.org/doc/html/rfc8259)
#### Как вы понимаете REST?

**REST** (*Representational State Transfer*) - архитектурный стиль который осуществляет реализацию клиента и сервера независимо друг от друга. Сервисы в REST API взаимодействуют по протоколу HTTP/HTTPS. Главные компоненты REST API:
- Клиент - клиент или программа, которая запущена на стороне пользователя (на его девайсе) и инициирует коммуникацию
- Сервер - сервер, который предоставляет API в качестве доступа к своим данным и функциям
- Ресурс - ресурс представляет собой любой вид контента (видео, текст, картинка), который сервер может передать клиенту

![[Pasted image 20240312102517.png|600]]

Чаще всего на практике используются следующие HTTP-методы: **GET, POST, PUT, DELETE** (см. [подробнее](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods)) 
#### Какая разница между GET и POST HTTP методами?
#### Расскажите о SPA concept.
#### Какие GoF-паттерны использовали?
#### Какую проблему решает Docker? Каковы его плюсы и минусы?
#### Чем принципиально отличаются unit-тесты от интеграционных тестов?

#### Обработка исключений

> [docs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#a-when-exception-filter)
##### Что такое Exception?

[Exceptions are created by using the `throw` keyword](#https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/)

Before the catch block is executed, the runtime checks for finally blocks. Finally blocks enable the programmer to clean up any ambiguous state that could be left over from an aborted try block, or to release any external resources (such as graphics handles, database connections, or file streams) without waiting for the garbage collector in the runtime to finalize the objects (take from [this](#https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/using-exceptions)).

If no compatible `catch` block is found on the call stack after an exception is thrown, one of three things occurs [link](#https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/using-exceptions):

- If the exception is within a [finalizer](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers), the finalizer is aborted and the base finalizer, if any, is called.
- If the call stack contains a static constructor, or a static field initializer, a [TypeInitializationException](https://learn.microsoft.com/en-us/dotnet/api/system.typeinitializationexception) is thrown, with the original exception assigned to the [InnerException](https://learn.microsoft.com/en-us/dotnet/api/system.exception.innerexception) property of the new exception.
- If the start of the thread is reached, the thread is terminated.

A `catch` block can specify the type of exception to catch. The type specification is called an **_exception filter_**. The exception type should be derived from [Exception](https://learn.microsoft.com/en-us/dotnet/api/system.exception). In general, don't specify [Exception](https://learn.microsoft.com/en-us/dotnet/api/system.exception) as the exception filter unless either you know how to handle all exceptions that might be thrown in the `try` block, or you've included a [`throw` statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-throw-statement) at the end of your `catch` block. [link](#https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/exception-handling)


##### Для чего служат try, catch, finally? В каком случае может не выполниться блок finally?

[A `when` exception filter](#https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#a-when-exception-filter)

Along with an exception type, you can also specify an exception filter that further examines an exception and decides if the corresponding **catch** block handles that exception. An exception filter is a Boolean expression that follows the **when** keyword, as the following example shows:

```cs
try
{
    var result = Process(-3, 4);
    Console.WriteLine($"Processing succeeded: {result}");
}
catch (Exception e) when (e is ArgumentException || e is DivideByZeroException)
{
    Console.WriteLine($"Processing failed: {e.Message}");
}
````

The preceding example uses an exception filter to provide a single `catch` block to handle exceptions of two specified types.

You can provide several `catch` clauses for the same exception type if they distinguish by exception filters. One of those clauses might have no exception filter. If such a clause exists, it must be the last of the clauses that specify that exception type.

If a `catch` clause has an exception filter, it can specify the exception type that is the same as or less derived than an exception type of a `catch` clause that appears after it. For example, if an exception filter is present, a `catch (Exception e)` clause doesn't need to be the last clause.
##### Что такое call stack? Какие ключевые слова вы знаете?

Call Stack (стек вызова) - окно, в котором можно посмотреть текущий стек вызовов ф-й и процедур. При помощи свойства StackTrace типа System.Exception можно узнать имена и сигнатуры методов, вызов которых стал источником исключения. При этом стоит обратить внимание на следующий момент:

``` cs
private void SomeMethod(){
	try {...}
	catch (Exception e) {
		...
		throw e;    // CLR считает, что исключение возникло здесь
	            // FxCop сообщает об ошибке
	}
}
```

 ``` cs
private void SomeMethod(){
	try {...}
	catch (Exception e) {
		...
		throw ;      // CLR не меняет информацию о начальной точке исключения
		        // FxCop НЕ сообщает об ошибке
	}
}
```

> Note: **FxCop** runs post-build analysis on a compiled assembly
### Junior_Платформа .NET

#### Что такое ASP.NET?

**ASP.NET** — это бесплатная **веб-платформа** для создания веб-сайтов и веб-приложений с помощью HTML, CSS и JavaScript. Вы также можете создавать веб-API и использовать технологии в 
режиме реального времени, такие как веб-сокеты. На данный момент вместо ASP.NET все чаще используют ASP.NET Core (судя по всему, это связано с окончанием поддержки .net framework в 2019 (последняя версия 4.8) и переход на .net core в 2014). 

Были выпущены следующие версии .net core: .NET Core 1, .NET Core 2, .NET Core 3, .NET 5. Текущая версия .NET 8.

В отличие от .net framework, который предназначался преимущественно для ОС Windows, .net core (или .net) является кроссплатформенным.

#### Какие существуют типы Action filters?

[docs#1](#https://learn.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/understanding-action-filters-cs)
[docs#2-rus](#https://learn.microsoft.com/ru-ru/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0)

В ASP.NET Core существует целых пять типов фильтров:

1. Фильтры авторизации (Authorization Filter)
2. Фильтры ресурсов (Resource Filter)
3. Фильтры действий (Action Filter)
4. Фильтры результатов (Result Filter)
5. Фильтры исключений (Exception Filter)

![[action-filters.png]] 

**Action-фильтры** вызываются после фильтров ресурсов и служат для выполнения определенных действий до и после выполнения определенных методов в контроллерах

```cs
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.Logging;

public class LogActionFilter : IActionFilter
{
	private readonly ILogger<LogActionFilter> _logger;
	
	public LogActionFilter(ILogger<LogActionFilter> logger)
	{
		 _logger = logger; 
	}
	
	public void OnActionExecuting(ActionExecutingContext context)
	{
		//  Этот метод выполняется до метода контроллера
		_logger.LogInformation($"Action '{context.ActionDescriptor.DisplayName}' is starting.");
	}
	
	public void OnActionExecuted(ActionExecutedContext context)
	{ 
		// Этот метод выполняется после метода контроллера
		_logger.LogInformation($"Action '{context.ActionDescriptor.DisplayName}' has completed.");
	}
}

// Метод ConfigureServices
services.AddMvc(options =>
{
	options.Filters.Add<LogActionFilter>();
});

// SomeController
[ServiceFilter(typeof(LogActionFilter))] // Применяем фильтр к данному методу контроллераpublic IActionResult MyAction()
{
	// Логика нашего метода контроллера
}
```

> Теперь при каждом вызове метода `MyAction` фильтр `LogActionFilter` будет регистрировать начало и конец действия, представляя собой простой способ контроля за выполнением методов контроллера.
#### Что такое Web Service?
#### Что такое CLR?

.NET -- бесплатная, кроссплатформенная платформа для разработчиков с открытым исходным кодом для разработки приложений различного типа (веб, мобильные, десктопные и проч.). Она состоит из следующих компонентов:
- **CLR** (*Common Language Runtime*) - общеязыковая среда выполнения кода (выполняет код на различных языках программирования)
- **библиотеки** - предоставляют служебные функции, такие как, например, парсинг JSON (например, BCL (*Basic Class Library*) - [библиотека базовых классов](https://learn.microsoft.com/ru-ru/dotnet/standard/glossary#bcl), ранее (в .net framework 4.8) это называлось FCL (framework class library) - библиотека классов фреймворка)
- **компилятор**
- **SDK** (Software Development Kit*) и **другие средства** — включение создания и мониторинга приложений с помощью современных рабочих процессов
- **стеки приложений**, такие как ASP.NET Core и Windows Forms, которые позволяют создавать приложения

> **CTS** (*Common Type System*) - общая система типов, формальная спецификация, разработанная Microsoft, которая описывает способ определения и поведение типов
#### Что такое сборщик мусора (Garbage Collector) на базовом уровне?

Сборщик мусора (англ. Garbage Collector) - программа, осуществляющая высвобождение памяти на куче. Высвобождение происходит, когда в куче не остается больше свободного места для создания новых объектов или ОС сигнализирует об отсутствии свободного места в памяти. Сам процесс очистки происходит тогда, приложение наименее нагружено.

##### Почему GC начинает удалить из кучи только в таких исключительных случаях (см. абзац выше)?
Операция очистки памяти весьма ресурсоемкая, к тому же на время очистки приходится останавливать все потоки работающего приложения, т.к. на момент работы приложения все его объекты должны находится в неизменном состоянии

##### Как GC знает, какие объекты должны быть удалены?
GC удалит из кучи объекты, на которые отсутствует ссылка в стеке

##### Что конкретно делает GC во время очистки памяти?
GC действует по принципу "помечай и собирай". GC собирает не используемые объекты и помещает их в специальном месте в памяти, делая размещение объектов более компактным. 

##### Что происходит с объектами, которые пережили очистку GC?
Они приписываются к генерации_1, т.к. считаются важными и поэтому будут существовать в памяти еще какое-то время. Все объекты в памяти, которые пережили 2 и более очисток относятся к генерации_2.

##### Для чего объекты в памяти относятся к определенным генерациям?
Т.к. операция очистки является ресурсоемкой, то для оптимизации работы GC в первый его проход для высвобождения проверяются **только** объекты генерации_0. Если в рамках данной работы был освобожден достаточный объем памяти, то на этом работа GC прекращается. В противном случае процесс поиска объектов для удаления осуществляется сначала среди объектов генерации_1, а затем, при необходимости, среди объектов генерации_2.

##### Можно ли программно вызвать очистку памяти GC?
Да, нужно использовать метод `static System.GC.Collect()`. Данный метод используется крайне редко. Примеры программного вызова GC:
1) перед выполнением кода, работа которого не должна быть прервана GC
2) после создания большого количества объектов
#### Что такое делегат?

> **Делегат** (функция обратного вызова) - переменная, содержащая указатели на метод или методы. Они обеспечивают возможность последовательного вызова нескольких методов, а также вызова как *статических*, так и *экземплярных* методов. Делегаты безопасны по отношению к типам

Результатом использования делегата будет результат работы метода. Делегаты поддерживают операции сложения/вычитания, напр., следующий код будет работать:

```cs
public class MethodClass
{
    public void Method1(string message) { }
    public void Method2(string message) { }
}

var obj = new MethodClass();
Callback d1 = obj.Method1;
Callback d2 = obj.Method2;
Callback d3 = DelegateMethod;

// Both types of assignment are valid.
Callback allMethodsDelegate = d1 + d2;
allMethodsDelegate += d3;

//remove Method1
allMethodsDelegate -= d1;

// copy AllMethodsDelegate while removing d2
Callback oneMethodDelegate = allMethodsDelegate - d2;
```

В C# существуют следующие предопределенные делегаты (они могут принимать до 16 параметров):
- Func<> соответствуют методам, которые **возвращают** значения
- Action<> соответствуют методам, которые **не возвращают** значения

> Более подробно о [Action<>](#https://learn.microsoft.com/ru-ru/dotnet/api/system.action-1?view=net-8.0) и [Func<>](#https://learn.microsoft.com/en-us/dotnet/api/system.func-2?view=net-8.0)

```cs
static void Main(string[] args)
{
	PerformOperationWithLogging(AddWithLogging, 50, 10);
}

static void AddWithLogging(int x, int y) => Console.WriteLine($"{x} + {y} = {x + y}");

static void PerformOperationWithLogging(Action<int, int> operatorWithLogging, int x, int y) => operatorWithLogging(x, y);
```

[Неплохо вспомнить](#https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/) (ковариантность и контравариантность)

**Ковариантность** (covariance) означает, что метод может возвратить тип, производный от типа, возвращаемого делегатом. **Контравариантность** (contra-variance) означает, что метод может принимать параметр, который является базовым для типа параметра делегата. Например:
``
```cs
delegate Object MyCallback(FileStream s);
```

Определив делегат таким образом, можно получить экземпляр этого делегата, связанный с методом, прототип которого выглядит примерно так:

```cs
String SomeMethod(Stream s); //ковариантность т.к. String потомок Object
	                         //контравариантность т.к. Stream базовый для FileStream
```

> ==Ковариантность и контравариантность поддерживаются только для ссылочных типов==, но не для значимых типов или значения void. Значимые типы и void не могут использоваться ковариантно и контравариантно, потому что их структура памяти меняется, в то время как для ссылочных типов структурой памяти в любом случае остается указатель. К счастью, при попытке выполнить запрещенные действия компилятор возвращает сообщение об ошибке

[**Predicate**](#https://metanit.com/sharp/tutorial/3.33.php)

Делегат [Predicate<T\>](#https://learn.microsoft.com/en-us/dotnet/api/system.predicate-1?view=net-8.0) принимает один параметр и возвращает значение типа bool:

```cs
delegate bool Predicate<in T>(T obj);
```

Как правило, используется для сравнения, сопоставления некоторого объекта T определенному условию. В качестве выходного результата возвращается значение true, если условие соблюдено, и false, если не соблюдено:

```cs
Predicate<int> isPositive = (int x) => x > 0;
 
Console.WriteLine(isPositive(20));
Console.WriteLine(isPositive(-20));
```

В данном случае возвращается true или false в зависимости от того, больше нуля число или нет.
#### Отличается ли Delegate от Action?

При помощи `delegate` можно определить свой собственный делегат. `Action` представляет собой предопределенный делегат, который не возвращает значение (т.е. void) и принимает он [0..16] параметров
#### Что такое LINQ и для чего используется? Приведите несколько примеров применения LINQ

`LINQ` — это встроенный в C# механизм для удобной работы с коллекциями.

```cs
public List<int> GetNewLetterIds_ClassicWay()
{
	var res = new List<int>();
	for(int i=0; i<letters.Length; i++)
	{
		if (letters[i].IsNew)
			res.Add(letters[i].Id);
	}
	return res;
}

public IEnumerable<int> GetNewLetterIds_LinqWay()
{
	return letters.Where(letter => letter.IsNew).Select(letter => letter.Id);
}
```

\+ также операции в классах-репозиториях
#### Что такое пространство имен (namespace) и зачем это нужно?

### Junior_Типы, структуры и коллекции данных
#### Какие типы данных вы знаете?

Все типы в С# наследуются прямо (как ссылочные) или косвенно (как значимые) от класса System.Object.

![[типы-данных-00.png]]

> **Классы и структуры являются двумя основными конструкциями системы общих типов CTS**, используемой на платформе .NET. В C# 9 добавлены записи (**record**), которые представляют собой тип класса. Оба они являются структурами данных, которые инкапсулируют набор данных и поведений в одной логической сущности. Данные и поведение являются _членами_ класса, структуры или записи. К ним относятся методы, свойства, события и другие элементы, которые описаны далее в этой статье.

**Класс** является ссылочным типом. Когда вы создаете объект типа и назначаете его переменной, эта переменная содержит только ссылку на память объекта. Если ссылка на объект сохраняется в новую переменную, эта переменная также ссылается на исходный объект. Изменения, внесенные через одну переменную, отражаются и в другой переменной, поскольку обе они ссылаются на одни и те же данные.

**Структура** (struct) является типом значения. При создании структуры переменная, которой присвоена структура, содержит фактические данные этой структуры. Если структура присваивается новой переменной, все данные копируются. Таким образом, новая переменная и исходная переменная содержат две отдельные копии одинаковых данных. Изменения, внесенные в одну копию, не влияют на другую.

Типы записей могут быть либо ссылочными типами (`record class`), либо типами значений (`record struct`).

Как правило, классы используются для моделирования более сложного поведения. Классы обычно хранят данные, которые должны быть изменены после создания объекта класса. Структуры лучше всего подходят для небольших структур данных. Структуры обычно хранят данные, которые не должны изменяться после создания структуры. Типы записей — это структуры данных с дополнительными членами, синтезированными компилятором. Записи обычно хранят данные, которые не должны изменяться после создания объекта.

#### Какие примитивные типы знаете?

**значимые** int, char, bool, decimal (и все похожие на них), а также **ссылочные** string, object, dymanic
#### Что такое тип значения, а что такое тип ссылки? Что из этого class, а что struct? В каком участке памяти они хранятся?

**Тип значения** - тип производный от `System.ValueType`, экземпляры которого размещаются в стеке потока. К таким типам относятся все примитивные типы, а также `struct` и `enum` (+`record struct`).

**Ссылочный тип** - тип прямо или косвенно производный от `System.Object`, экземпляры которого размещаются в управляемой куче. К ним относятся почти все типы библиотеки базовых типов (примеры `string, object, dymanic, class, interface, delegate, Array` и т.д).
#### Чем отличаются value от reference type? String - это reference или value?

Если создаем переменную значимого типа и потом переприсваиваем ее значение другой переменной значимого типа, то происходит полное копирование значений членов. Это может служить проблемой производительности в определенных случаях.

Но если создадим переменную ссылочного типа и переприсвоим ее другой переменной ссылочного, то произойдет только копирование ссылок на область памяти, где лежат данные.

Тип стринг string согласно документации является ссылочным, однако, в некоторых моментах его поведение аналогично значимым типам (==***НАЙТИ НОРМ ПРИМЕР***==)
#### В чем отличие между string builder и string?
#### Что такое дженерики? Какие проблемы они решают?
- когда мы используем разные типы данных, .NET каждый раз генерирует новый метод для работы с новым типом данных
- 

#### Что такое boxing / unboxing?

> Объекты значимого типа существуют в двух формах: **неупакованной** (unboxed) и **упакованной** (boxed). Ссылочные типы бывают **только в упакованной форме** 
> 
> -\ Рихтер, с.154


**boxing** - процесс конвертации значимого типа в объект типа `object` или какой-либо интерфейс, реализованный этим интерфейсом. When the common language runtime (CLR) boxes a value type, it wraps the value inside a System.Object instance and stores it on the managed heap. **Unboxing** extracts the value type from the object. **Boxing is implicit (==неявное==); unboxing is explicit (==явное==).** The concept of boxing and unboxing underlies the C# unified view of the type system in which a value of any type can be treated as an object.

```cs
int i = 123; 
object o = i; // boxing i
int z = (int)o; //unboxing o
```


![[упаковка-значимых-типов-01.png|500]]

**An unboxing operation consists of:**

- Checking the object instance to make sure that it is a boxed value of the given value type.
- Copying the value from the instance into the value-type variable.

![[упаковка-значимых-типов-00.png|500]]

```cs
int x = 423;
object q = x;
q = "hello";
int h = (int)q; // RTE: InvalidCastException 
Console.WriteLine($"x={x}, q={q}, h={h}");
```

#### Что такое Array, List, HashSet, Dictionary? Приведите примеры использования этих структур данных. Какая сложность операций с ними (поиск, вставка, удаление)?

![[коллекции-00.png|1200]]

concurrent-коллекции - коллекции для работы в многопоточной среде

|                                                        | Внутренний вид                                              | Add/ Insert                      | Расширение коллекции | Queue/ Push/ Dequeue/ Pop/ Peek | Remove/ RemoveAt                | Item[i]                         | Get Enumerator | Move Next |
| ------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------- | -------------------- | ------------------------------- | ------------------------------- | ------------------------------- | -------------- | --------- |
| **T[]**                                                | Массив                                                      | —                                | —                    | —                               | —                               | O(1)                            | —              | —         |
| **List, ArrayList, Collection, Observable Collection** | Массив                                                      | O(1)/ O(n)                       | O(n)                 | —                               | O(n)                            | O(1)                            | O(1)           | O(1)      |
| **LinkedList**                                         | Двойной список                                              | O(1) До или после данного узла   | O(1)                 | O(1)                            | O(1) До или после данного узла  | O(n)                            | O(1)           | O(1)      |
| **Stack, Queue**                                       | Массив                                                      | O(1)                             | O(n)                 | O(1)                            | —                               | —                               | O(1)           | O(1)      |
| **Dictionary, HashSet**                                | Hashtable с ссылками на массив индексов в случае коллизии * | O(1), O(n) – в случае коллизии * | O(n)                 | —                               | O(1),O(n) – в случае коллизии * | O(1),O(n) – в случае коллизии * | O(1)           | O(1)      |
| **Sorted Dictionary, SortedSet**                       | Красно-черное дерево                                        | O(logn)                          | O(logn)              | —                               | O(logn)                         | O(logn)                         | O(logn)        | O(1)      |
| **SortedList**                                         | Массив                                                      | O(n)                             | O(n)                 | —                               | O(n)                            | O(1)                            | O(1)           | O(1)      |

> Можно заметить что LINQ предоставляет несколько похожих операций (Distinct, Union, Intersect, Except), которые можно выполнить с любой коллекцией. Но HastSet предоставляет намного больший набор операций с множествами. 
> 
> **Основная разница в том что методы множеств изменяют текущую коллекцию, в то время как LINQ методы всегда создают новый экземпляр коллекции**.

https://stefaniuk.website/all/collection-in-csharp/
#### Какие знаете коллекции?

https://learn.microsoft.com/en-us/collections/yz26f8y64n7k07

Типы коллекций представляют различные способы сбора данных, таких как хэш-таблицы, очереди, стеки, пакеты, словари и списки.

Все коллекции основаны на интерфейсах [ICollection](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.icollection) и [ICollection\<T\>](#https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.icollection-1) **прямо или косвенно**. [IList](#https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.ilist) и [IDictionary](#https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.idictionary), их универсальные аналоги, являются производными от этих двух интерфейсов.

В коллекциях на основе [IList](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.ilist) или непосредственно [ICollection](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.icollection)на **каждом элементе содержится только значение**. К таким типам относятся:

- [Array](https://learn.microsoft.com/ru-ru/dotnet/api/system.array)
- [ArrayList](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.arraylist)
- [List\<T\>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1)
- [Queue](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.queue)
- [ConcurrentQueue\<T\>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.concurrent.concurrentqueue-1)
- [Stack](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.stack)
- [ConcurrentStack\<T\>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.concurrent.concurrentstack-1)
- [LinkedList\<T\>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.linkedlist-1)

В коллекциях на основе [IDictionary](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.idictionary)  интерфейса **каждый элемент содержит ключ и значение**. К таким типам относятся:

- [Hashtable](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.hashtable)
- [SortedList](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.sortedlist)
- [SortedList<TKey,TValue>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.sortedlist-2)
- [Dictionary<TKey,TValue>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.dictionary-2)
- [ConcurrentDictionary<TKey,TValue>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.concurrent.concurrentdictionary-2)

Члены пространства имен ==**System.Collections.Concurrent**==:
- классы: BlockingCollection\<T\>; ConcurrentBag\<T\>; ConcurrentDictionary<TKey,TValue>; ConcurrentQueue\<T\>; ConcurrentStack\<T\>;
  OrderablePartitioner\<TSource\>; Partitioner; Partitioner\<TSource\>
- интерфейсы: IProducerConsumerCollection\<T\>
- перечисления: EnumerablePartitionerOptions

**Функция LINQ to Objects** предоставляет общий шаблон для доступа к объектам в памяти любого типа, реализующего [IEnumerable](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.ienumerable) или [IEnumerable\<T\>](https://learn.microsoft.com/ru-ru/dotnet/api/system.collections.generic.ienumerable-1). Запросы LINQ имеют несколько преимуществ по сравнению со стандартными конструкциями, такими как `foreach` циклы:

- Они кратки и легче понять.
- Они могут фильтровать, упорядочить и группировать данные.
- Они могут повысить производительность.
#### Что делает оператор yield?

#### Что такое Nullable-тип (`System.Nullable<T>` )?

==дописать инфу про null-совместимые значимые типы==

- В качестве параметра `T` типа `Nullable` могут использоваться **только** структуры — ведь переменные ссылочного типа и так могут принимать значение null
- Можно выполнять преобразования, а также приведение null-совместимых экземпляров к другим типам. Язык C# поддерживает возможность применения операторов к экземплярам null-совместимых значимых типов
- Для операций с экземплярами null-совместимых типов генерируется **большой объем кода**,  вследствие чего операции с null-совместимыми типами выполняются **медленнее** аналогичных операций с другими типами


**Оператор объединения null-совместимых значений** (англ. null-coalescing operator) обозначается как `??` и работает с двумя операндами. Если левый операнд **не равен null**, оператор возвращает его значение. В противном случае возвращается значение правого операнда. Оператор объединения null-совместимых значений удобен при задании предлагаемого по умолчанию значения переменной.

> Основным преимуществом этого оператора является поддержка как ссылочных, так и null-совместимых значимых типов

```cs
private static void NullCoalescingOperator()
	{
		Int32? b = null;
		
		// Приведенная далее инструкция эквивалентна следующей:
		// x = (b.HasValue) ? b.Value : 123
		
		Int32 x = b ?? 123;
		Console.WriteLine(x); // "123"
		
		// Приведенная далее в инструкции строка эквивалентна следующему коду:
		// String temp = GetFilename();
		// filename = (temp != null) ? temp : "Untitled";
		
		String filename = GetFilename() ?? "Untitled";
	}
```

boxing/unboxing of nullable-types

```cs
// BOXING

// После упаковки Nullable<T> возвращается null или упакованный тип T
Int32? n = null;
Object o = n; // o равно null
Console.WriteLine("o is null={0}", o == null); // "True"

n = 5;
o = n; // o ссылается на упакованный тип Int32
Console.WriteLine("o's type={0}", o.GetType()); // "System.Int32"

// UNBOXING

// Создание упакованного типа Int32
Object o = 5;

// Распаковка этого типа в Nullable<Int32> и в Int32
Int32? a = (Int32?) o; // a = 5
Int32 b = (Int32) o; // b = 5

// Создание ссылки, инициализированной значением null
o = null;

// "Распаковка" ее в Nullable<Int32> и в Int32
a = (Int32?) o; // a = null
b = (Int32) o; // NullReferenceException

```
### Junior_Классы, структуры и интерфейсы
#### Что такое класс?

[Класс](#https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class) - "чертеж" будущего экземпляра. Является ссылочным типом. Может содержать следующие члены:
- Constructors
- Constants
- Fields
- Finalizers
- Methods
- Properties
- Indexers
- Operators
- Events
- Delegates
- Classes
- Interfaces
- Structure types
- Enumeration types
#### Чем отличается класс от абстрактного класса? (урок №76 SimpleCode)

- в абстрактном классе может быть конструктор (причем их может быть много, т.е. можно перегружать конструктор)
- абстрактные методы могут быть только в абстрактных классах
#### Чем отличается абстрактный класс от интерфейса? Для чего нужны интерфейсы и какие задачи они выполняют?

> **СТРУКТУРЫ НЕ МОГУТ БЫТЬ АБСТРАКТНЫМИ! ПРИ ЭТОМ ОНИ ПО УМОЛЧАНИЮ ЯВЛЯЮТСЯ** `SEALED`([подробно](#https://learn.microsoft.com/en-us/dotnet/csharp/misc/cs0666))

- задача интерфейса - определить контракт взаимодействия между классами
- в интерфейсе не может быть конструкторов
- интерфейс не может содержать полей
- все члены интерфейса имеют по умолчанию модификатор доступа **public**
- интерфейсы могут содержать свойства
- интерфейс может наследовать неограниченное количество других интерфейсов

Явная реализация интерфейсов (*вопрос с собеса: Может ли класс реализовать два интерфейса, которые содержат два метода с одинаковым названием?*):

```cs
interface IFirstInterface
{
	void Action();
}
interface ISecondInterface
{
	void Action();
}

class MyClass : IFirstInterface, ISecondInterface
{
	void IFirstInterface.Action() // явная реализация интерфейса
								  // МОДИФИКАТОР ДОСТУПА В ТАКИХ МЕТОДАХ НЕ УКАЗЫВАЕТСЯ
	{
		Console.WriteLine("IFirstInterface.Action has called");
	}
	void ISecondInterface.Action() // явная реализация интерфейса
	{
		Console.WriteLine("ISecondInterface.Action has called");
	}
}

class Program
{
	static void Mani(string[] args)
	{
		MyClass myClass = new MyClass();
		Foo(myClass); // IFirstInterface.Action has called
		Bar(myClass); // ISecondInterface.Action has called
	}
	static void Foo(IFirstInterface firstInterface)
	{
		firstInterface.Action();
	}
	static void Bar(ISecondInterface secondInterface)
	{
		secondInterface.Action();
	}
}
```

- если класс реализовывает какой-либо интерфейс, то можно создать переменную с типом данного интерфейса и присвоить ему ссылку на переменную типа класса, реализующего данный интерфейс:

```c#
MyClass myClass = new MyClass();
IFirstInterface firstInterface = myClass; // т.к. MyClass реализует IFirstInterface
firstInterface.Action(); // IFirstInterface.Action has called

// вместо 3х строк выше можно написать иначе:

((IFirstInterface)myClass).Action(); // вариант 1

if(myClass is IFirstInterface firstInterface) // вариант 2
{
	firstInterface.Action();
}

(myClass as IFirstInterface).Action(); // вариант 3
```

**Реализация интерфейса по умолчанию (добавлена в .net 8.0)**
- реализация по умолчанию - это когда в интерфейса можно писать код реализации методов, что ранее было недоступно
- по логике, реализация по умолчанию дает возможность множественного наследования в C#, как было в С++
#### Какие вы знаете модификаторы доступа? [подробнее](#https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)

```
public > internal > protected > private
```

**На текущую дату (12.04.2024) в C# существуют следующие модификаторы доступа:**
- `public`: код в любой сборке имеет доступ к типу/члену (Уровень доступности содержащего типа управляет уровнем доступности открытых членов типа.)
- `private` : доступ к данному ==члену== есть только у класса/структуры, внутри которых объявлен член
- `protected` : только код в этом же типа или его наследниках имеет доступ к типу/члену
- `internal` : только код в этой сборке имеет доступ к типу/члену
- `protected internal` : только код в этой сборке или в наследнике из другой сборки имеет доступ к типу/члену
- `private protected` : только код в этой сборке и этот же класс или его наследник имеет доступ к типу/члену
- `file` : только код в этом файле имеет доступ к типу/члену

![[модификаторы-доступа-01.png]]

| Caller's location                      | `public` | `protected internal` | `protected` | `internal` | `private protected` | `private` | `file` |
| -------------------------------------- | -------- | -------------------- | ----------- | ---------- | ------------------- | --------- | ------ |
| Within the file                        | ✔️️      | ✔️                   | ✔️          | ✔️         | ✔️                  | ✔️        | ✔️     |
| Within the class                       | ✔️️      | ✔️                   | ✔️          | ✔️         | ✔️                  | ✔️        | ❌      |
| Derived class (same assembly)          | ✔️       | ✔️                   | ✔️          | ✔️         | ✔️                  | ❌         | ❌      |
| Non-derived class (same assembly)      | ✔️       | ✔️                   | ❌           | ✔️         | ❌                   | ❌         | ❌      |
| Derived class (different assembly)     | ✔️       | ✔️                   | ✔️          | ❌          | ❌                   | ❌         | ❌      |
| Non-derived class (different assembly) | ✔️       | ❌                    | ❌           | ❌          | ❌                   | ❌         | ❌      |

- наследники не могут получить доступ к private-членам базового класса, поэтому нельзя делать переопределенные методы с модификатором private (переопределять можно public и protected методы базового класса с модификатором virtual)
- по умолчанию все члены класса/структуры, включая вложенные классы и структуры, имеют модификатор доступа `private`, если не указано иное
- класс/структуры, объявленные внутри пространства имен (не являющиеся вложенными в другие классы/структуры) могут иметь **ТОЛЬКО** модификатор доступа `public` , `file` или `internal` (по умолчанию `internal`)
- если в качестве модификатора доступа для класс/структуры указать `protected`, то получим следующую ошибку:
  ==***CS1527 Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected***==
- члены структуры, включая вложенные, могут быть объявленными как  `public`, `internal`, or `private`
- члены класс, включая вложенные, могут быть объявленными как   `public`, `protected internal`, `protected`, `internal`, `private protected`, or `private`
- производные классы не могут иметь большую доступность, чем их базовые типы. Вы не можете объявить общедоступный класс B, который является производным от внутреннего класса A. Если это разрешено, это приведет к тому, что A станет общедоступным, поскольку все защищенные или внутренние члены A доступны из производного класса

```cs
 internal class MyClass { ... }

 public class MyClass1 : MyClass // будет ошибка: CS0060 Inconsistent accessibility:
								 // base class 'MyClass' is less accessible than class 'MyClass1'
 {
     
 }
```

#### В чем разница между обычным классом и статическим?

- Static-конструктор работает только со статическими членами класса.
- Со static-контсруктором не используются модификаторы доступа.
- В любом классе может быть только один статический конструктор.
- Статический конструктор не принимает никаких параметров.
- Статический конструктор вызывается ТОЛЬКО ОДИН РАЗ при создании первого экземпляра типа (даже если происходит вызов статических методов, то этот статический конструктор также вызывается только один раз).
- Статические члены типа могут работать только со статическими членами

**Статический класс**
- статический класс может содержать только статические члены (включая конструктор)
- ключевое слово this нельзя использовать при работе со статическим классом или его членами, за исключением случаев, когда речь идет о методов расширения
- статические классы не умеют в наследование и в реализацию интерфейсов (поэтому при использовании статических классов нельзя реализовать полиморфизм)
- на основании пункта выше, при использовании статических классов у них могут быть проблемы с DI, а также при с их тестированием

**Методы расширения (extension methods)**
- методы расширения должны находиться в статическом классе и сам должны быть статическими
- могут принимать параметры (указываются сразу после первого параметра с this)
- методы расширения лучше размещать в отдельном пространстве имен
#### [В чем разница переопределения метода между ключевыми словами new и override?](#https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords)

В C# метод в классе-наследнике может иметь такое же название, что и метод в базовом классе. Можно указать какой именно нужно будет вызывать посредством ключевых слов `new` и `override`. Модификатор `override` ***расширяет*** базовый виртуальный метод, а модификатор`new` скрывает доступный метод базового класса

```csharp
using System;  
using System.Text;  
  
namespace OverrideAndNew  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            BaseClass bc = new BaseClass();  
            DerivedClass dc = new DerivedClass();  
            BaseClass bcdc = new DerivedClass();  
  
            // The following two calls do what you would expect. They call  
            // the methods that are defined in BaseClass.  
            bc.Method1();  
            bc.Method2();  
            // Output:  
            // Base - Method1  
            // Base - Method2  
  
            // The following two calls do what you would expect. They call  
            // the methods that are defined in DerivedClass.  
            dc.Method1();  
            dc.Method2();  
            // Output:  
            // Derived - Method1  
            // Derived - Method2  
  
            // The following two calls produce different results, depending
            // on whether override (Method1) or new (Method2) is used.  
            bcdc.Method1();  
            bcdc.Method2();  
            // Output:  
            // Derived - Method1  
            // Base - Method2  
        }  
    }  
  
    class BaseClass  
    {  
        public virtual void Method1()  
        {  
            Console.WriteLine("Base - Method1");  
        }  
  
        public virtual void Method2()  
        {  
            Console.WriteLine("Base - Method2");  
        }  
    }  
  
    class DerivedClass : BaseClass  
    {  
        public override void Method1()  
        {  
            Console.WriteLine("Derived - Method1");  
        }  
  
        public new void Method2()  
        {  
            Console.WriteLine("Derived - Method2");  
        }  
    }  
}
```

##### Method signatures

> Methods are declared in a `class`, `record`, or `struct` by specifying:

- An optional access level, such as `public` or `private`. The default is `private`.
- Optional modifiers such as `abstract` or `sealed`.
- The return value, or `void` if the method has none.
- The method name.
- Any method parameters. Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters.

These parts together form the method signature.

**==Important**
A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.==
#### Какое различие между const и read only?

The [readonly](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) keyword differs from the `const` keyword. A `const` field can only be initialized at the declaration of the field. A `readonly` field can be initialized either at the declaration or in a constructor. Therefore, `readonly` fields can have different values depending on the constructor used. Also, although a `const` field is a compile-time constant, the `readonly` field can be used for run-time constants, as in this line:
`public static readonly uint l1 = (uint)DateTime.Now.Ticks;`

Ключевое слово `readonly` отличается от ключевого слова const. Константное поле может быть инициализировано только при объявлении поля. Поле только для чтения может быть инициализировано либо в объявлении, либо в конструкторе. Таким образом, поля только для чтения могут иметь разные значения в зависимости от используемого конструктора. Кроме того, хотя поле const является константой времени компиляции, поле readonly можно использовать для констант времени выполнения, как в этой строке: public static readonly uint l1 = (uint)DateTime.Now.Ticks;

- константе обязательно должно быть присвоено значение в месте ее объявления (иначе будет ошибка: *CS0145	A const field requires a value to be provided)*, при этом далее в коде нельзя будет изменить ее значение (т.е. написать так как ниже)

```cs
public class MyCalss
{
	public const int PI = 3,14;
}

public class SomeClass
{
	PI = 1; // будет ошибка
}
```

- все константы неявно статические, при этом указать модификатор `static` нельзя

**readonly**
- в отличие от `const` не нужно в месте объявления инициализировать значение
- не является по умолчанию `static`, но его можно сделать явно статическим: `public static readonly int a;` (при этом стоит учесть, что инициализация значением `static readonly` может быть осуществлена либо в `static`, либо в месте объявления)

урок 69 от SimpleCode
#### Разница между структурой и классом. Приведите примеры структур.

https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects#object-identity-vs-value-equality

- структуры - значимый тип, который не умеет в наследование
- структуры, как и классы, могут реализовывать интерфейсы
- ~~члены структуры могут иметь только модификатор доступа public (проверить это)~~
- в структурах нет методов финализаторов, т.к. структуры - значимый тип
- в структурах нельзя инициализировать поля/свойства напрямую (public int Numb {get; set; } = 1)
- в структурах нет конструкторов без параметров (он реализован "под капотом", поэтому даже если в структуре определен конструктор с параметрами, все равно возможно использование конструктора без параметров для создания экземпляра структуры, просто ее поля/свойства будут инициализированы значением по умолчанию)
- при сравнении структур при помощи метода Equals() происходит сравнение значений, а не ссылок

Примеры структур: все примитивные типы (int, char, deicmal, DateTime, DateTimeOffset, Guid,  и проч.)

[Больше примеров структур и классов namespace System читай здесь](#https://learn.microsoft.com/en-us/dotnet/api/system?view=net-8.0)

==закончила на 81==
#### Может ли экземпляр структуры храниться в куче (heap)? Как это сделать?

- да, если входит в состав ссылочного типа как член
- если структура прошла через операцию boxing

### Junior_Ассинхронность
#### Что такое асинхронность и чем она отличается от многопоточности?

Многопоточность (Thread) - выполнение кода программы в нескольких потоках. Потоки выделяет ОС. Ядро может иметь собственный кэш и контроллер памяти (?). 

![[Pasted image 20240325182825.png|600]]

Thread ограничения:
- управление потоками потребляет ресурсы
- в некоторых случаях распределение по ядрам/процессорам задача не тривиальная
- блокировка/синхронизация

Стандартизация управления потоками:
- `ThreadPool`
- `BackgroundWorker`

`Task` - надстройка над `Thread`. Позволяет гибко управлять задачами (потоками), дает красивую асинхронность async/await

![[Pasted image 20240325183712.png|600]]

Параллельное, обычно, подразумевает многопоточность, когда потоки работают параллельно и кто-то ими управляет.

Асинхронность не подразумевает многопоточность (мы отдаем задачи кому-то, но при этом не знаем что и как будет выполнено; мы лишь в конце получаем результаты работы).

![[Pasted image 20240325184050.png|600]]

Ответ на вопрос выше не в полной мере верен.

![[Pasted image 20240325184429.png|600]]
![[Pasted image 20240325184502.png|600]]


#### Какие есть ключевые слова для использования асинхронности в коде?
#### Что означают ключевые слова async / await?

### Junior_Тестирование
#### Для чего нужны unit-тесты?
#### Какие преимущества и недостатки использования unit-тестов?
#### Из каких трех логических блоков состоит unit-тест?

### Junior_Базы данных
#### Разница между реляционными и нереляционными базами, плюсы и минусы использования обоих вариантов.
#### Что такое индексы в RDBMS?

> [Habr: Как устроено индексирование баз данных](#https://habr.com/ru/companies/ruvds/articles/724066/)

Конкретный процесс создания индекса может варьироваться в зависимости от типа используемой системы базы данных, однако в целом общие этапы выглядят так:  
1. Определение столбца или столбцов в таблице базы данных, которые нужно индексировать. Обычно они определяются по тому, какие столбцы чаще всего используются в запросах или поисках.
2. Выбор алгоритма индексирования, подходящего для типа индексируемых данных. Например, индексы в виде B-деревьев обычно используются для индексирования строковых или числовых данных, а полнотекстовые индексы — для индексирования текстовых данных.
3. Применение алгоритма индексирования к выбранным столбцам, что создаёт структуру данных, сопоставляющую значения в столбцах с местоположениями соответствующих записей таблицы.
4. Сохранение индекса в отдельной структуре данных, обычно в другой части диска или в памяти, чтобы доступ к ней был более эффективным, чем к соответствующим табличным данным.
5. Обновление индекса в случае добавления новых записей, удаления или изменения записей в таблице.
   
> **Одними из ярких минусов индексирования являются увеличение требований к объему хранилища, снижение скорости выполнения операций вставки и удаления записей.**
   
   Наиболее популярными алгоритмами индексирования являются:
   - **B-tree** (быстро происходит вставка, поиск, удаление)
	   ***B-дерево***- это структура данных самобалансирующегося дерева, которая часто используется в качестве алгоритма индексирования в базах данных. Каждый узел дерева состоит из набора ключей и указателей на дочерние узлы; хранение данных осуществляется в иерархической структуре. Деревья B-узлов упорядочены таким образом, что позволяют быстро выполнять поиск, вставку и удаление данных.
   - **bitmap-index** (
     - быстро происходит чтение;
     - используется для сокращения время ответа для больших классов и запросов;
     - примеры: git, jpg, png, etc. )
	***Bitmap-индексирование*** — это методика индексирования данных, использующая битовые карты (bitmap) для обозначения наличия или отсутствия значения в таблице. Это успешная техника индексирования для таблиц с низкой кардинальностью, где количество уникальных значений в столбце довольно мало по сравнению с общим количеством строк.

   - **hash-index**
   
	   Хэш-индекс - это разновидность методики индексирования баз данных, использующая хэш-функцию для сопоставления ключей индекса с местоположениями соответствующих записей данных. Это быстрый метод индексирования для запросов точного соответствия в одном столбце.  Сопоставление ключей индекса с местоположениями соответствующих записей данных позволяет выполнять быстрый поиск и вставки за постоянное время O(1). Однако этот метод плохо работает с запросами диапазонов или частичными совпадениями и может страдать от коллизий, с которыми можно справляться при помощи различных техник разрешения коллизий.

   - **GiST (generalised search tree)** -- это техника индексирования баз данных, которая может использоваться для индексирования сложных типов данных, например, ***геометрических объектов, текста или массивов***. Это сбалансированная древовидная структура, состоящая из узлов с множественными дочерними узлами. Каждый узел описывает диапазон или множество значений и связан с предикативной функцией, проверяющей, принадлежит ли значение диапазону или множеству. Предикативная функция зависит от типа индексируемых данных и может быть подстроена под разные типы данных.  
   
	   ==низкая скорость операций вставки и обновления; подходит не для всех типов данных
   
   - **fulltext-index** (полнотекстовое индексирование) — это методика индексирования баз данных, используемая для повышения эффективности поиска текстовых запросов. Это особый вид индекса, спроектированный для работы с текстовыми данными. В отличие от традиционных индексов, хранящих значения отдельных столбцов, полнотекстовый индекс хранит текстовое содержимое одного или нескольких столбцов как множества слов или токенов. Эти слова или токены используются при выполнении поискового запроса для быстрого нахождения релевантных строк.

> Индексы позволяют ускорить поиск по полю или набору полей, а также обеспечивают уникальность данных.

**Кластеризованный индекс** - индекс на основе первичного ключа (строки физически сортируются на диске в соответствии с индексируемым полем в определенном порядке: по возрастанию или по убыванию). Таблица или представление могут иметь **только один** кластеризованный индекс.

**Некластеризованный индекс** - индекс на основе одного или нескольких не ключевых столбцов (хранится отдельно от таблицы, для которой определен); строки в таблице могут находится в любом порядке, а сортировка осуществляется при помощи специальной таблицы - дерева индексов. Для таблицы или представления можно создать 999 некластеризованных индексов, при этом неважно, есть ли кластеризованный индекс. Некластеризованный индекс хранит в себе информацию о ключевых столбцах, для которых был создан индекс, а также ссылки на строки исходной таблицы, где хранятся данные. Максимальное количество столбцов, из которых может состоять некластеризованный индекс, равняется 16 (?).

> Для первичных ключей и столбцов, отмеченных как UNIQUE, кластеризованные индексы создаются автоматически.

Лучше не использовать индексы в следующих случаях:
- в небольших таблицах;
- в таблицах с частыми массовыми update и insert;
- для столбцов, содержащих большое количество значений NULL;
- для столбцов, которые часто обрабатываются.
#### Какие типы JOIN существуют в SQL?
## ==Middle==

### Middle_Общее
#### Вы набираете google.com в браузере. Расскажите как можно подробнее, что происходит в это время на HTTP-уровне?
#### Как работает HTTPS?
#### Как вы понимаете SOLID?
#### Какие протоколы сериализации вы знаете и где они применяются?
#### Что такое в вашем понимании чистая функция? Какие у нее преимущества?
#### Что такое dependency injection и зачем оно нужно?

#### Что такое cohesion и coupling (связанность и связность)?

#### Что такое IaaS, PaaS, SaaS и каковы различия между ними?

#### Какие способы отладки программы вы используете?

#### Какие знаете паттерны? Объясните суть перечисленных.

#### В чем суть паттерна Singleton? Почему его еще называют антипаттерном?

#### Для чего нужен паттерн Strategy?

#### Какие ключевые различия между распределенными системами и монолитными?

#### Какие паттерны проектирования распределенных систем вы знаете?

#### Какие есть принципы работы Message bus? Почему могут возникать дубликаты в очередях?

#### Какие принципы построения идемпотентных сервисов знаете?

#### Расскажите, как работают асинхронные методы? Чем асинхронность отличается от параллелизма?

### Middle_Платформа .NET
#### Какие исключения нельзя остановить в блоке catch?

#### Какая разница между .NET Standard Class Library и .NET Core Class Library?

#### Объясните разницу между отложенным и немедленным исполнением в LINQ. Приведите примеры.



#### Для чего нужен метод ConfigureServices в Startup.cs?

#### Какая разница между services.AddTransient и services.AddScope в ASP.NET Core?

#### Что такое Kestrel?

#### Опишите ASP.NET MVC request pipeline.

#### Как в ASP.NET WebAPI настроить кэширование ответов на HTTP-запросы?
### Middle_Типы, структуры и коллекции данных
#### Когда генерируется дженерик-класс конкретного типа - при выполнении программы или во время компиляции?

#### Что такое рефлексия?
#### Расскажите о коллекции `LinkedList <T>`. Чем она отличается от других коллекций?
#### Что такое индексатор?

#### Что такое `immutable object`? Какие преимущества дает использование `immutable object`? Предложите способ реализации его в .NET.

#### Когда использовать `StringBuilder`, а когда `string`? Как работает `StringBuilder`?

```csharp
public static void Main(string[] args)
{
	string strVariable = "few letters";
	
	bool containsL = strVariable.Contains('l');
	bool endsWithErs = strVariable.EndsWith("ers");
	bool startsWithFew = strVariable.StartsWith("few");
	int indexOfT = strVariable.IndexOf('t');
	
	string subString = strVariable.Substring(5);

	
}
```

#### Что такое балансирование деревьев?

#### Что такое `Key-value` структуры?

#### Что такое хэш-функция и зачем нужны хэш-таблицы?

#### Какими свойствами должна обладать идеальная хеш-функция?

#### Что такое коллизии и как с ними бороться?

#### В чем заключается сложность `CRUD-операций` в `Dictionary <K, V>` в .NET?

#### Где хранятся массивы? Массивы примитивных типов?

#### В чем отличие между массивом (`T [ ]`) и списком (`List <T>`)?

#### В чем разница между `IList <T>` и `IEnumerable <T>`?

#### Зачем нужны `Enumerable`, `Observable`, `AsyncEnumerable` и какие модели получения данных они реализуют?

#### В чем разница между `IEnumerable` и `IQueryable`?

#### Что такое `enum flags`?

### Middle_Управление памятью
#### Что такое куча и стек? Различия, принцип работы

##### Управляемая куча (англ. Managed Heap)

Для доступа к ресурсу в C# нужно:
1. Выделить память для типа, представляющего ресурс (обычно это делается при помощи оператора `new` в C#).
2. Инициализировать выделенную память, установив начальное состояние ресурса и сделав его пригодным к использованию. За установку начального состояния типа отвечает его конструктор.
3. Использовать ресурс, обращаясь к членам его типа (при необходимости операция может повторяться).
4. В рамках процедуры очистки уничтожить состояние ресурса.
5. Освободить память. За этот этап отвечает **исключительно** уборщик мусора.

Иногда очистка ресурса должна выполняться как можно раньше, не дожидаясь вмешательства уборщика мусора. В таких классах можно вызвать дополнительный метод  (называемый `Dispose`), чтобы очистка была выполнена по вашему собственному расписанию. Как правило, типы, требующие специальной очистки, используют низкоуровневые
системные ресурсы — **файлы, сокеты или подключения к базе данных**.

##### Чему равен размер кучи?
По мере заполнения области объектами CLR выделяет новые области, вплоть до заполнения всего адресного пространства. Таким образом, **память приложения ограничивается виртуальным адресным пространством процесса**. Для 32-разрядных процессов можно выделить до 1,5 гигабайта памяти, а для 64-разрядных процессов — около 8 терабайт памяти.

##### Алгоритм работы метода `new()`:
1) подсчет количества байтов для размещения полей типа и всех полей, что были унаследованы от базового типа;
2) к полученному количеству прибавляется количество байт, необходимое для **указателя на объект-тип** и **индекса блока синхронизации**;
3) проверка на предмет, есть ли в куче свободное место для объекта (если есть, то для него выделяется память и занимаемые им байты обнуляются); затем вызывается конструктор типа (передающий `NextObjPtr` в качестве параметра `this`), и оператор new возвращает ссылку на объект. 

>`NextObjPtr` - так Рихтер называет указатель, который указывает на базовый адрес зарезервированной под кучу области адресного пространства. Он определяет, где в куче будет выделена память для следующего объекта (вроде указателя на "голову" стека)

##### Алгоритм сборки мусора
CLR использует алгоритм ***отслеживания ссылок***. Алгоритм отслеживания ссылок работает ==**только**== с переменными ссылочного типа, потому что только эти переменные
могут ссылаться на объекты в куче; переменные значимых типов просто содержат данные экземпляра значимого типа. Все переменные ссылочных типов называются **корнями** (roots).
Алгоритм сборки мусора:
1) маркировка (поиск объектов для удаления, построение графа достижимости объектов)
2) сжатие (в этой фазе CLR перемещает вниз все «немусорные» объекты, чтобы они занимали смежный блок памяти, иначе происходит **дефрагментация**)

>Если CLR не удается освободить память в результате уборки мусора, а в процессах не осталось адресного пространства для выделения нового сегмента, значит, свободная память процесса полностью исчерпана. В этом случае попытка выделения новой памяти оператором `new()` приведет к выдаче исключения `OutOfMemoryException`

==Замечание Рихтера==

>**Статическое поле типа** хранит объект, на который ссылается, бессрочно или до выгрузки домена приложений с загруженными типами. Чаще всего утечка памяти возникает из-за хранения в статическом поле ссылки на коллекцию, в которую добавляются элементы. Статическое поле сохраняет объект коллекции, которая, в свою очередь, сохраняет все свои элементы. Поэтому статических полей следует по возможности избегать

	JIT-компилятор является оптимизирующим, а приравнивание локальной переменной или переменной-параметра к null равнозначно отсутствию ссылки на эту переменную

##### Поколения (англ. generations)

*Cборщик мусора с поддержкой поколений* (generational garbage collector), который также называют *эфемерным уборщиком мусора* (ephemeral garbage collector), работает на основе следующих предположений:
+ чем младше объект, тем короче его время жизни;
+ чем старше объект, тем длиннее его время жизни;
+ уборка мусора в части кучи выполняется быстрее, чем во всей куче.
Сразу после инициализации в управляемой куче нет объектов. К поколению 0 относятся только что созданные объекты, которых не касался сборщик мусора. При инициализации CLR выбирает пороговый размер для всех поколений.

>Если в результате выделения памяти для нового объекта размер поколения 0 превышает пороговое значение, должна начаться сборка мусора.

В поколении 2 находятся объекты, проверенные сборщиком мусора **не меньше 2** раз. Операций сборки мусора может быть много, но объекты поколения 1 проверяются только тогда, когда их суммарный размер достигает порогового значения — до этого обычно проходит несколько операций сборки мусора в поколении 0.
Управляемая куча поддерживает **только** три поколения: 0, 1 и 2. Поколения 3 не существует. При инициализации в CLR устанавливается пороговое значение для всех трех поколений. 

Если сборщик видит, что после сборки мусора в поколении 0 остается очень мало выживших объектов, он может снизить порог для поколения 0. В этом случае сборка мусора будет выполняться чаще, но это меньше загрузит сборщик, поэтому рабочий набор процесса останется небольшим. В сущности, если все объекты поколения 0 станут мусором, сборщику не придется даже дефрагментировать память — достаточно будет вернуть указатель `NextObjPtr` в начало поколения 0, чтобы посчитать сборку мусора законченной.
В то же время, если после обработки поколения 0 сборщик мусора обнаруживает множество выживших объектов, значит, удается освободить мало памяти. В этом случае сборщик мусора может поднять порог для поколения 0. В результате сборка мусора выполняется реже, но каждый раз будет освобождаться значительный объем памяти. Кстати, если сборщик освобождает недостаточно памяти, перед генерированием исключения `OutOfMemoryException` он выполняет полную сборку мусора.

> Пороговые значения применяются аналогичным образом и для поколений 1 и 2

	Класс `GCNotification` позволяет проанализировать код приложения, чтобы лучше понять каким образом оно использует память

##### Запуск сборки мусора

Помимо ситуации, когда объем поколения 0 превысил свое значение, сборка мусора запускается в следующих случаях:
- вызов статического метода `System.GC.Collect()` 
- Windows сообщает о нехватке памяти
- выгрузка домена приложения
- завершение работы CLR

##### Большие объекты (LargeObjectsHeap)

- память для них выделяется в отдельной части адресного пространства
- к  большим объектам не применяется сжатие (англ. *compaction*), так как на их перемещение в памяти потребуется слишком много процессорного времени
- большие объекты **всегда** считаются частью поколения 2. Размещение в памяти короткоживущих больших объектов приведет к необходимости частой уборки мусора в поколении 2, что снижает производительность.

> Обычно в больших объектах хранятся большие строки (например, XML или JSON) или массивы байтов, используемые в операциях ввода/вывода — например, при чтении данных из файла или сети в буфер для последующей обработки


Стек работает по принципу LIFO (last in first out). Взять данные из можно только из его "головы", но ни из какой-либо другой части. На стеке можно разместить типы, унаследованные от `System.ValueType` (напр., bool, byte, char, float, short, uint, **enum, struct**, etc), указатели на объекты, служебная информация

Куча может хранить следующие типы данных: ссылочные типы; типы значения. Существует 3 типа кучи: **SOH** (small objects (до 85кбайт) heap), **LOH** (large objects (свыше 85кбайт) heap), **POH** (pinned objects heap - появился с выходом .net5 в ноябре 2020)
#### Как работает сборщик мусора (GC)?

GC - это часть CLR. В момент работы сборщика мусора приложение полностью останавливается.

Объектам в LOH при их создании сразу же присваивается поколение 2. В LOH не проводится дефрагментация - оптимизация адресного пространства в памяти - т.к. это ресурсоемкая операция ввиду большого размера объектов.

Как GC понимает, что нужно удалить? Для этого создаются графы объектов - между объектами выстраиваются связи, через которые GC понимает востребованность объектов в программе. Чтобы понять какие объекты можно удалить, строится граф достижимости и все объекты, которые на достижимы из какой-либо вершины графа, удаляются GC. После удаления объектов, структура графа обновляется соответствующим образом. При этом, если процент фрагментации невелик, то после перестройки графа процедура дефрагментации запущена не будет.

Перед удалением объекта из кучи, на нем будет вызван метод `Destructor()` .

```cs
class Rocket
{
	Rocket()  // конструктор
	{}
	
	~Rocket() // деструктор = System.Object.Finilize()
	{}
}
```

> **В чем отличие деструктора от метода `System.Object.Finilize()` ? Ни в чем, это одно и то же.**

Все объекты, подлежащие удалению, помещаются в **Finalization Queue** (очередь финализации). GC, добираясь до Finalization Queue, сначала выполняет методы-деструкторы объектов, а затем только удаляет их из памяти.
#### Зачем нам зарезервированное слово using в C#, если в .NET есть автоматическое управление памятью? Как с этим связан disposable-паттерн и зачем такой сложный паттерн для managed и unmanaged ресурсов?

#### Какие особенности работы с Large Object Heap?

### Middle_Параллелизм
#### Для чего использовать `Task.ConfigureAwait`?

#### Например, есть веб-сервер, который по HTTP-запросу делает выборку из базы данных. Всего на сервере 16 тредов (threads). Каждый HTTP-request выполняет запрос в базу и ожидает результатов, в этом случае тред блокируется. Можно ли оптимизировать эту работу средствами .NET?

#### Зачем нужен ThreadPool? Опишите механику работы: как поток выделяется и возвращается обратно в ThreadPool.

### Middle_Базы данных
#### Расскажите о нормальных формах в СУБД.

#### Что такое индекс в БД?

#### Когда следует использовать индексы? Преимущества и недостатки.

#### Какие типы индексов существуют? Чем они отличаются?

#### Что такое ACID?

**A** (*atomicity or, sometimes, abortability*) - означает, что если необходимо выполнить набор операций (т.е. чтобы выполнилась каждая операция), то их нужно "обернуть" в транзакцию; в случае, если какая-либо операции из набора не выполнилась, то механизмы транзакции "откатят" все остальные операции и БД вернется в исходное состояние

**C** (*consistency*) - означает, что все данные в БД находятся в "good state", т.е. для данных выполняется набор каких-либо правил или, иначе, инвариантов (напр., возраст не должен быть более 150 лет и проч.). Правило консистентности гласит, что данные до и после выполнения транзакции должно находится в "good state".

> Однако, стоит заметить, что ни одна БД не может гарантировать выполнение данного правила по причине того, что полная ответственность за проверку на соответствие правилам лежит на программе

**I** (*isolation*) - означает ограничение доступа к данным в случае, когда с данными работает множество пользователей (race condition); для обеспечения такого ограничения служат уровни изоляции

**D** (*durability*) - означает, что после коммита транзакции данные записаны в постоянное хранилище, а не находятся в оперативной памяти

#### Какие вы знаете уровни изоляции транзакций?

Serialisable: сформировать очередь из транзакций и выполнять их поочередно, главный минус - низкая производительность:  читать данные только после того, как одна транзакция "закоммитит" свои изменения; минус - грязное чтение

![[Pasted image 20240320100351.png|600]]

![[Pasted image 20240320100541.png|600]]

Snapshot or Repeatable Read: 

![[Pasted image 20240320101629.png|600]]

При использовании уровня изоляции Snapshot (Repeatable Read) используется

 **MVCC** (*multi-version concurrency control*) - архитектурное решение, когда БД может хранить множество состояний одно и того же объекта. При использовании данного подхода (уровень изоляции может быть любой) могут возникнуть следующие проблемы:
- Lost Update
![[Pasted image 20240320102918.png|600]]

Решение проблемы Lost Update 
![[Pasted image 20240320102952.png|600]]

![[Pasted image 20240320103018.png|600]]

![[Pasted image 20240320103027.png|600]]

> В последнем способе решения Lost Update используется менеджер транзакций, который откатывает транзакцию, если что-то пошло не так

Проблема конкурентного доступа (иначе аномалии в БД) см. выше про read uncommitted

unpeatable read
фантомное чтение

Почитать про аномалии в БД  можно [здесь](#https://www.bestprog.net/ru/2020/10/17/databases-normalization-concept-and-necessity-of-application-modification-anomalies-examples-ru/#q02) и [здесь](#https://q-pax.ru/blog/erid/it/back/sql/db_double_anomal/)
#### Что такое план выполнения запроса (execution plan) в MS SQL?

#### Проблема: запрос долго выполняется. Какие есть методы ее диагностики и решения?

#### Как ORM (Entity Framework или Entity Framework Core) транслируют C# код в язык запросов базы данных? Что для этого используется?
## ==Senior==

### Senior_Общее
#### Какие ещё практики, кроме ООП, использовали (AOP, FP и т. д.)?

#### Назовите три самые сложные проблемы, которые вам приходилось решать. Как вы это сделали, как пришли к этому решению?

#### Что такое слабосвязанный код? Чем он лучше сильносвязанного кода? Как бы вы достигали более слабой связности кода?

#### Использование статических классов повышает или понижает связность кода?

#### Как можно измерить performance кода? Влияет ли факт замеров на производительность?

#### Для чего используются и как работают multi-stage билды в Docker?

#### Как понять, что какая-то часть кода утилизирует много памяти или долго выполняется? Что может быть ботлнеком в разных случаях? Какие есть способы уменьшения памяти и трафика памяти?

#### Как бы вы реализовали cross-cutting concern (например, логирование, валидация, транзакции)?

#### Расскажите о Rest Maturity Model.

#### Что такое CPU и IO-bound задачи?

#### Что такое маршалинг?

#### Как работает async / await (подробно)? Почему нельзя использовать async void методы?
### Senior_Платформа .NET
#### Как работает lock? Можно ли использовать структуры внутри выражения lock?

#### Что такое Expression Tree?

#### Как работает сборщик мусора (подробно)? Почему в GC три поколения, а не, скажем, пять, десять или два?

#### Как бы вы организовали трассировки Web API сервисов?

#### Как в .NET Core можно настроить хранение секретов на компьютерах разработчиков и на рабочих средах?

#### Как бы вы организовали процесс CI/CD .NET Core сервисов для их деплоймента в облачную инфраструктуру?

#### Как включить CORS в AspNetCore?
### Senior_Типы, структуры и коллекции данных
#### Как реализованы дженерики?

#### Как создать собственный immutable-тип?

#### Как работает `IEnumerable <T>` (подробно)?

#### Какой алгоритм использует коллекция STACK?

#### Какие структуры данных вы реализовывали сами для платформы .NET? Расскажите, чем они отличались от стандартных реализаций.

#### Чем отличается интерфейс от абстрактного класса? В каких случаях вы использовали бы и то, и другое?

#### Почему в структуре нет конструктора по умолчанию?
### Senior_Микросервисы
#### Какую проблему решают микросервисы?

#### Какие есть способы коммуникации микросервисов?

#### Расскажите варианты реализации распределенных транзакций в микросервисах

#### Что такое circuit breaker?

#### Каким образом вы будете налаживать систему, состоящую из множества микросервисов, если нужно отследить полный путь обработки запроса?

#### Что такое брокеры сообщений? Что такое at-least-once, at-most-once семантика? Есть ли какие-то брокеры, которые гарантируют exactly-once семантику?

#### Как должен работать код клиента брокера в зависимости от выбранной семантики?

#### Какие инструменты для работы с очередями вам известны (как в .NET, так и отдельные продукты), какой инструмент/продукт вы бы выбрали и почему?

### Senior_MS Azure
#### Какие виды сервисов бывают в Service Fabric?

#### Какие особенности и ограничения Azure Table Storage?

#### Как бороться с проблемой холодного старта в Azure Functions?

#### В чем отличие очередей и топиков в Azure Service Bus?
### Senior_Базы данных
#### Как БД сохраняет данные?

#### Какие типы БД вы знаете?

#### Как и когда БД лучше использовать?

#### Что такое денормализация?

#### Когда и какие уровни изоляции транзакций можно использовать?

#### Как в популярных СУБД реализованы принципы ACID (SQL Server, PostgreSQL и т. д.)?

#### Приходилось ли вам оптимизировать запрос в БД? Если да, то как?

#### Опишите, какие вы знаете потенциальные проблемы, связанные с параллельными запросами к БД.

#### Какую базу данных вы бы использовали для реализации distributed lock механизма? Расскажите детали реализации.

# Практика

## Junior-Practice

#### JP-Задание 1
Опишите, как бы вы реализовали калькулятор. Если понадобится добавить поддержку для римской системы счисления, что будете делать?
#### JP-Задание 2
Напишите программу, чтобы проверить, является ли число простым или нет.
#### JP-Задание 3
Найдите наименьший элемент в массиве.
#### JP-Задание 4
Упорядочите структуры папок в файловой системе.
#### JP-Задание 5
Напишите программу, которая симулирует fizz-buzz.
#### JP-Задание 6
Расскажите, что делает этот код, и предложите, как его улучшить.

_а)_
```csharp
public bool IsArrayEmpty(string[] array)  
{  
  if (array.Length > 0)  
    return false;  
  else  
    return true;  
}
```

_б)_
```cs
protected string GetClass(object url)  
{  
  string result = string.Empty;  
  if (SiteMap.CurrentNode != null && SiteMap.CurrentNode.Url == url.ToString())  
    result = "class=\"active\"";  
  return result;  
}
```

## Middle-Practice
#### MP-Задание 1
Напишите программу для тиражирования последовательности Фибоначчи для заданного числа.

#### MP-Задание 2
Спроектируйте базу данных врачей и пациентов в SQL. Создайте stored procedure или запрос в SQL, который вернет врачей, имеющих больше, чем N пациентов.

#### MP-Задание 3
Проверьте коллекцию на наличие дубликатов.

#### MP-Задание 4
Спроектируйте thread-safe класс Singleton в C#.

#### MP-Задание 5
Надо записать некую сущность в базу данных и отправить событие в брокер сообщений. Как это сделать с минимальным риском потери данных?

#### MP-Задание 6
Имеются три сервиса. Выполняется HTTP-запрос на первый. Первый должен записать данные во второй, а второй - в третий. Как гарантировать, что данные при такой сложной коммуникации не потеряются? Как предотвратить записи дубликатов данных?

#### MP-Задание 7
Будет ли работать этот код и почему?

_а)_
```cs
SomeClass myClass = null;  
myClass.SomeMethod();
```

_б)_
```cs
var table = GetTable();  
table.Draw();  
…  
private SomeClass GetTable()  
{  
  using(var table = new SomeClass())  
  {  
    table.ID = "www";  
    table.Width = "95%";  
    table.Controls.Add(tr);  
    return table;  
  }  
}
```

#### MP-Задание 8
Расскажите, что делает этот код, и предложите, как его улучшить:

_а)_
```cs
Shape shape = GetNextShape();  
if(shape is Circle)  
Console.WriteLine(((Circle)shape).Radius);
```

_б)_
```cs
public int Quantity  
{  
  get  
  {  
    try  
    {  
      return int.Parse(TxtQuantity.Text);  
    }  
    catch (Exception)  
    {  
      return 0;  
    }  
  }  
}
```

#### MP-Задание 9
Что не так с кодом?

```cs
try  
{  
  SomeMethod();  
}  
catch(Exception e)  
{  
  Log(e.Message);  
  throw e;  
}
```

## Senior-Practice

#### SP-Задание 1
Как бы вы спроектировали FTP-сервер? Web-сервер? Хостинг картинок с разделением прав доступа? Систему, состоящую из front- и back-офисов? Создайте клон любой популярной социальной сети (Instagram, Facebook и т.д.)

#### SP-Задание 2
Допустим, есть сущность сделки (Bid). И в сделке есть список партнеров, с которыми эта сделка заключается. Сами сделки хранятся в сервисе сделок (bidding service), а партнеры - в своем сервисе (partners service). И когда показывается список сделок, на начальном скрине нужно отразить количество партнеров. Как бы вы спроектировали хранение и изображение этого счетчика?

#### SP-Задание 3
Задача на знание LINQ: с исходной коллекции данных необходимо получить новую коллекцию по определенным требованиям (например, отсортированную, без дубликатов и т. д.).

#### SP-Задание 4
Напишите программу, которая проверяет, является ли поле судоку 9×9 правильно заполненным.

#### SP-Задание 5
Реализуйте свой Select, Where, SelectMany со всеми характеристиками LINQ (отложенное исполнение, одномоментная (eager) проверка входных данных).

#### SP-Задание 6
С помощью LINQ напишите метод, который вернет такие элементы коллекции, которые делятся на N без остатка, отсортированные от наибольшего значения к наименьшему. Сигнатура метода: 

```cs
List <int> Filter (IEnumerable <int> collection, int n)
```

#### SP-Задание 7
Напишите функцию, которая вернет сумму всех четных элементов массива, который передается в функцию (JavaScript).