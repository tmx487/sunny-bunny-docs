В контексте C# "критическая секция" имеет два распространенных значения:

### 1. Участок кода, защищенный от одновременного выполнения потоками

Это участок кода, который должен выполняться только одним потоком за раз для обеспечения целостности данных. В C# для этого обычно используются **механизмы синхронизации** (`lock`):

```csharp
// Использование lock
private readonly object _lockObject = new object();

public void UpdateSharedResource()
{
    lock (_lockObject)
    {
        // Критическая секция - только один поток может выполнять этот код
        // Работа с общими ресурсами
    }
}
```

Альтернативные способы реализации критических секций в C#:

- `Monitor.Enter()` и `Monitor.Exit()`
- `Mutex`
- `Semaphore` или `SemaphoreSlim`
- `ReaderWriterLockSlim`

### 2. Код с высокими требованиями к производительности и предсказуемости

В контексте оптимизации производительности "критическая секция" означает участок кода, где особенно важны:

- Низкая задержка выполнения
- Предсказуемое время выполнения
- Отсутствие пауз (например, из-за сборки мусора)

Примеры таких критических секций:

- Обработка аудио/видео в реальном времени
- Высокочастотные финансовые операции
- Системы управления промышленным оборудованием
- Игровой цикл обновления кадров

В этом контексте ограничение работы GC, о котором вы спрашивали, используется именно для второго типа критических секций - когда критичность означает не защиту данных, а обеспечение предсказуемой производительности.

### Пример комбинированного использования

Иногда оба значения термина пересекаются - код может быть и потокобезопасным, и оптимизированным по производительности:

```csharp
private readonly object _lockObject = new object();

public void ProcessCriticalData()
{
    GCLatencyMode oldMode = GCSettings.LatencyMode;
    try
    {
        // Ограничиваем вмешательство GC
        GCSettings.LatencyMode = GCLatencyMode.LowLatency;
        
        lock (_lockObject)
        {
            // Код, требующий и защиты от параллельного выполнения,
            // и высокой производительности без прерываний
            PerformTimeCriticalOperation();
        }
    }
    finally
    {
        // Восстанавливаем исходный режим GC
        GCSettings.LatencyMode = oldMode;
    }
}
```

Выбор подхода зависит от конкретных требований вашего приложения.