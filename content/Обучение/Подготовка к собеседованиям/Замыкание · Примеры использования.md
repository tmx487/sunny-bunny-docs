
### 1. Асинхронное программирование с таймаутом

Когда вам нужно выполнить асинхронную операцию с возможностью её отмены через определённое время:

```csharp
public static async Task<T> WithTimeout<T>(
    Task<T> task, 
    TimeSpan timeout,
    CancellationToken cancellationToken = default)
{
    // Создаём локальный TokenSource для отслеживания таймаута
    using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
    
    // Устанавливаем таймаут
    timeoutCts.CancelAfter(timeout);
    
    // Создаём задачу задержки, которая отменится при вызове Cancel
    var delayTask = Task.Delay(Timeout.Infinite, timeoutCts.Token);
    
    // Замыкание захватывает task и timeoutCts
    var resultTask = task.ContinueWith(t => {
        // Отменяем задержку, когда основная задача завершается
        timeoutCts.Cancel();
        return t;
    }, TaskContinuationOptions.ExecuteSynchronously);
    
    // Ждём, что произойдет первым - выполнение задачи или таймаут
    var completedTask = await Task.WhenAny(resultTask, delayTask);
    
    if (completedTask == delayTask)
        throw new TimeoutException($"Операция превысила таймаут {timeout}");
    
    return await ((Task<Task<T>>)resultTask).Result;
}

// Пример использования
public async Task<string> GetDataWithTimeoutAsync()
{
    try {
        var result = await WithTimeout(
            apiClient.GetDataAsync(), 
            TimeSpan.FromSeconds(5)
        );
        return result;
    }
    catch (TimeoutException) {
        return "Время ожидания истекло";
    }
}
```

Здесь замыкание в `ContinueWith` имеет доступ к переменным `task` и `timeoutCts`, даже когда вызов этого метода вернётся в основной поток.

### 2. Обработчики событий пользовательского интерфейса

В приложениях с графическим интерфейсом замыкания часто используются для обработки событий:

```csharp
public class OrderForm : Form
{
    private readonly OrderService _orderService;
    private readonly Customer _customer;
    private decimal _total;
    
    public OrderForm(OrderService orderService, Customer customer)
    {
        _orderService = orderService;
        _customer = customer;
        
        InitializeComponents();
        
        // Настройка UI...
        
        // Использование замыкания для обработки события
        submitButton.Click += async (sender, e) => {
            // Замыкание захватывает _customer, _total и _orderService
            try {
                submitButton.Enabled = false;
                statusLabel.Text = "Отправка заказа...";
                
                var order = new Order {
                    CustomerId = _customer.Id,
                    Items = GetOrderItems(),
                    Total = _total,
                    DeliveryAddress = addressTextBox.Text
                };
                
                // Используем захваченный _orderService
                var result = await _orderService.SubmitOrderAsync(order);
                
                if (result.Success) {
                    MessageBox.Show($"Заказ #{result.OrderId} успешно создан!");
                    DialogResult = DialogResult.OK;
                    Close();
                }
                else {
                    MessageBox.Show($"Ошибка: {result.ErrorMessage}");
                }
            }
            catch (Exception ex) {
                MessageBox.Show($"Произошла ошибка: {ex.Message}");
            }
            finally {
                submitButton.Enabled = true;
                statusLabel.Text = "";
            }
        };
    }
    
    // Другие методы формы...
}
```

Здесь замыкание в обработчике `Click` захватывает состояние формы (`_customer`, `_total`, `_orderService`) и использует его при обработке события клика.

### 3. Middleware в веб-приложениях (например, ASP.NET Core)

В ASP.NET Core middleware представляет собой замыкания, которые обрабатывают HTTP-запросы:

```csharp
public class Startup
{
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        // Создаём middleware для логирования запросов
        app.Use(async (context, next) => {
            var requestId = Guid.NewGuid().ToString();
            var stopwatch = Stopwatch.StartNew();
            
            // Добавляем requestId в логический контекст
            context.Items["RequestId"] = requestId;
            
            try {
                // Вызываем следующий middleware в цепочке
                await next();
            }
            finally {
                stopwatch.Stop();
                
                // Логируем информацию о запросе
                var statusCode = context.Response.StatusCode;
                var method = context.Request.Method;
                var path = context.Request.Path;
                var elapsed = stopwatch.ElapsedMilliseconds;
                
                var logLevel = statusCode >= 500 ? LogLevel.Error : LogLevel.Information;
                
                // Используем захваченные переменные requestId и elapsed
                context.RequestServices
                    .GetRequiredService<ILogger<Startup>>()
                    .Log(logLevel, "Request {RequestId} {Method} {Path} completed with {StatusCode} in {Elapsed}ms",
                        requestId, method, path, statusCode, elapsed);
            }
        });

        // Другие middleware...
        
        app.UseRouting();
        app.UseEndpoints(endpoints => {
            endpoints.MapControllers();
        });
    }
}
```

Здесь замыкание в методе `Use` захватывает контекст запроса и выполняет код до и после вызова следующего middleware, используя переменные `requestId` и `stopwatch`, даже после возврата из функции.

### 4. Кэширование с "ленивой" инициализацией

Когда вам нужно создать объект только при первом обращении и затем переиспользовать его:

```csharp
public class ConfigurationService
{
    private readonly string _configPath;
    private readonly Func<AppSettings> _settingsFactory;
    
    public ConfigurationService(string configPath)
    {
        _configPath = configPath;
        
        // Создаём замыкание с "ленивой" инициализацией
        AppSettings settings = null;
        _settingsFactory = () => {
            // Если настройки ещё не загружены - загружаем их
            if (settings == null)
            {
                try
                {
                    var json = File.ReadAllText(_configPath);
                    settings = JsonConvert.DeserializeObject<AppSettings>(json);
                    
                    // Устанавливаем значения по умолчанию если нужно
                    settings.Timeout ??= TimeSpan.FromSeconds(30);
                    settings.MaxRetries ??= 3;
                }
                catch (Exception ex)
                {
                    // В случае ошибки создаём настройки по умолчанию
                    settings = new AppSettings 
                    { 
                        Timeout = TimeSpan.FromSeconds(30),
                        MaxRetries = 3
                    };
                    
                    Log.Error(ex, "Failed to load settings from {ConfigPath}", _configPath);
                }
            }
            
            return settings;
        };
    }
    
    public AppSettings Settings => _settingsFactory();
    
    // В этом методе замыкание _settingsFactory будет использовано каждый раз при обращении к Settings
}
```

Здесь замыкание используется для реализации паттерна "ленивая инициализация" - настройки загружаются только при первом обращении.

### 5. Стратегии авторизации в приложении

```csharp
public class AuthorizationService
{
    private readonly Dictionary<string, Func<User, AuthorizationContext, bool>> _policies = new();
    
    public AuthorizationService()
    {
        // Настраиваем различные политики авторизации
        
        // Администраторы могут делать всё
        _policies["Admin"] = user => user.IsAdmin;
        
        // Редакторы могут редактировать статьи
        _policies["EditArticle"] = user => 
            user.IsAdmin || 
            user.Roles.Contains("Editor") || 
            user.Permissions.Contains("article:edit");
        
        // Только владелец объекта может его удалить
        _policies["DeleteOwnedObject"] = (user, ctx) => 
		    user.IsAdmin || user.Id == ctx.GetResourceOwnerId();
    }
    
    public bool Authorize(User user, string policyName, AuthorizationContext context = null)
    {
        if (_policies.TryGetValue(policyName, out var policy))
        {
            return policy(user, context);
        }
        
        return false;
    }
}
```

В этом примере замыкания используются для создания гибких политик авторизации, которые имеют доступ к объекту пользователя.

### Когда нужно использовать замыкания:

1. **Когда вам нужно сохранить контекст между вызовами:** Сохранение состояния, доступного между вызовами функции.
2. **Для обработки событий:** Когда обработчик события нуждается в доступе к состоянию внешних объектов.
3. **Для "ленивой" инициализации:** Когда вы хотите создать объект только при первом обращении.
4. **Для создания фабричных методов:** Когда вам нужно создавать экземпляры с различными предустановленными параметрами.
5. **Для асинхронных операций:** Когда результат асинхронной операции должен иметь доступ к переменным из контекста, где операция была запущена.
6. **Для инкапсуляции логики:** Когда вы хотите скрыть внутреннюю логику, но предоставить способ её вызова.

Замыкания в C# стали особенно популярны с распространением LINQ, асинхронного программирования и событийно-ориентированной архитектуры. Они позволяют писать более лаконичный и элегантный код, сохраняя при этом доступ к необходимому контексту.