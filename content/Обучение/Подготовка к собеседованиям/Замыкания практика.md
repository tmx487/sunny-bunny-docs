Конечно! Вот набор задач для практики написания замыканий в C#, отсортированные от простых к сложным:

## Задание 1: Простой счётчик

Напишите функцию `CreateCounter`, которая создаёт счётчик, начинающийся с указанного значения. Каждый вызов возвращаемой функции должен увеличивать счётчик на 1 и возвращать новое значение.

```csharp
// Пример использования:
var counter = CreateCounter(5);
Console.WriteLine(counter()); // Должно вывести: 6
Console.WriteLine(counter()); // Должно вывести: 7
```

## Задание 2: Множитель

Создайте функцию `CreateMultiplier`, которая принимает коэффициент и возвращает функцию, умножающую свой аргумент на этот коэффициент.

```csharp
// Пример использования:
var double = CreateMultiplier(2);
var triple = CreateMultiplier(3);
Console.WriteLine(double(5)); // Должно вывести: 10
Console.WriteLine(triple(5)); // Должно вывести: 15
```

## Задание 3: Кэширующая функция

Напишите функцию `Memoize`, которая принимает функцию и возвращает её кэширующую версию. Кэширующая функция должна запоминать результаты предыдущих вызовов с теми же аргументами и возвращать их из кэша, не вычисляя заново.

```csharp
// Пример использования:
Func<int, int> factorial = null;
factorial = Memoize<int, int>(n => n <= 1 ? 1 : n * factorial(n - 1));

Console.WriteLine(factorial(10)); // Вычисляет факториал
Console.WriteLine(factorial(10)); // Берёт из кэша
```

## Задание 4: Конвейер обработки данных

Напишите функцию `Pipeline`, которая принимает несколько функций и возвращает функцию, применяющую их последовательно к аргументу.

```csharp
// Пример использования:
Func<int, int> addOne = x => x + 1;
Func<int, int> multiplyByTwo = x => x * 2;
Func<int, string> toString = x => $"Результат: {x}";

var process = Pipeline(addOne, multiplyByTwo, toString);
Console.WriteLine(process(5)); // Должно вывести: "Результат: 12"
```

## Задание 5: Генератор последовательности

Создайте функцию `CreateSequenceGenerator`, которая возвращает пару функций: одна для получения следующего числа в последовательности, вторая для сброса последовательности к начальному значению.

```csharp
// Пример использования:
var (nextFibonacci, resetFibonacci) = CreateSequenceGenerator(
    () => (0, 1),
    (current, next) => (next, current + next),
    current => current);

Console.WriteLine(nextFibonacci()); // 0
Console.WriteLine(nextFibonacci()); // 1
Console.WriteLine(nextFibonacci()); // 1
Console.WriteLine(nextFibonacci()); // 2
Console.WriteLine(nextFibonacci()); // 3
resetFibonacci();
Console.WriteLine(nextFibonacci()); // 0 (после сброса)
```

## Задание 6: Строитель запросов

Напишите функцию `CreateQueryBuilder`, которая возвращает объект с методами для построения SQL-запроса. Методы должны накапливать информацию и в конце формировать полный SQL-запрос.

```csharp
// Пример использования:
var builder = CreateQueryBuilder();
var query = builder
    .Select("id", "name", "email")
    .From("users")
    .Where("status = @status")
    .OrderBy("created_at DESC")
    .Limit(10)
    .Build();

Console.WriteLine(query);
// Должно вывести: "SELECT id, name, email FROM users WHERE status = @status ORDER BY created_at DESC LIMIT 10"
```

## Задание 7: Управление подписками на события

Создайте функцию `CreateEventManager`, которая позволяет добавлять подписчиков на события, отписывать их и уведомлять о событиях. Подписчики должны получать данные события.

```csharp
// Пример использования:
var eventManager = CreateEventManager<string>();

// Добавляем подписчиков
var unsubscribe1 = eventManager.Subscribe(data => Console.WriteLine($"Подписчик 1: {data}"));
var unsubscribe2 = eventManager.Subscribe(data => Console.WriteLine($"Подписчик 2: {data}"));

// Уведомляем о событиях
eventManager.Notify("Событие A");
// Должно вывести:
// Подписчик 1: Событие A
// Подписчик 2: Событие A

// Отписываем одного подписчика
unsubscribe1();

// Уведомляем снова
eventManager.Notify("Событие B");
// Должно вывести:
// Подписчик 2: Событие B
```

## Задание 8: Конечный автомат

Напишите функцию `CreateStateMachine`, которая создаёт конечный автомат с заданными состояниями, переходами и действиями при переходах.

```csharp
// Пример использования:
var stateMachine = CreateStateMachine<string, string>("Initial");

stateMachine.AddTransition("Initial", "Processing", "start", (from, to, input) => 
    Console.WriteLine($"Переход из {from} в {to} по команде {input}"));

stateMachine.AddTransition("Processing", "Completed", "complete", (from, to, input) => 
    Console.WriteLine($"Переход из {from} в {to} по команде {input}"));

stateMachine.AddTransition("Completed", "Initial", "reset", (from, to, input) => 
    Console.WriteLine($"Переход из {from} в {to} по команде {input}"));

Console.WriteLine(stateMachine.CurrentState); // Initial
stateMachine.ProcessInput("start");
Console.WriteLine(stateMachine.CurrentState); // Processing
stateMachine.ProcessInput("complete");
Console.WriteLine(stateMachine.CurrentState); // Completed
```

## Задание 9: Многоуровневое кэширование

Создайте систему кэширования с несколькими уровнями (например, память, файловая система, сетевое хранилище). Реализуйте стратегию извлечения данных из самого быстрого доступного кэша и заполнения более быстрых кэшей при получении данных из более медленных.

```csharp
// Пример использования:
var cacheManager = CreateMultiLevelCache<string, string>(
    // Уровень 1: память (быстрый доступ)
    CreateMemoryCache<string, string>(TimeSpan.FromMinutes(5)),
    
    // Уровень 2: файловая система (средний доступ)
    CreateFileCache<string, string>("cache", TimeSpan.FromHours(1)),
    
    // Уровень 3: "удалённое" хранилище (медленный доступ)
    CreateRemoteCache<string, string>("https://api.example.com/cache", TimeSpan.FromDays(1))
);

// Первый запрос получит данные из самого медленного кэша и заполнит более быстрые
var data = await cacheManager.GetOrAddAsync("user:123", async key => {
    // Этот код выполнится только если данные отсутствуют во всех уровнях кэша
    return await httpClient.GetStringAsync($"https://api.example.com/users/123");
});

// Второй запрос должен получить данные из памяти
var cachedData = await cacheManager.GetOrAddAsync("user:123", async key => {
    // Этот код не должен выполниться, так как данные уже в кэше
    throw new Exception("Этот код не должен выполниться!");
});
```

## Задание 10: Разработка мини-системы аспектно-ориентированного программирования

Создайте систему для внедрения дополнительной функциональности (аспектов) в методы классов. Реализуйте поддержку аспектов логирования, кэширования, валидации параметров и транзакций.

```csharp
// Пример использования:
var aspectWeaver = CreateAspectWeaver();

// Регистрируем аспекты
aspectWeaver.RegisterAspect("logging", method => 
    async (target, args) => {
        Console.WriteLine($"Вызов метода {method.Name} с аргументами: {string.Join(", ", args)}");
        try {
            var result = await method.Invoke(target, args);
            Console.WriteLine($"Метод {method.Name} вернул: {result}");
            return result;
        }
        catch (Exception ex) {
            Console.WriteLine($"Метод {method.Name} выбросил исключение: {ex.Message}");
            throw;
        }
    });

aspectWeaver.RegisterAspect("caching", method => 
    async (target, args) => {
        var cacheKey = $"{method.Name}({string.Join(",", args)})";
        if (cache.TryGetValue(cacheKey, out var cachedResult)) {
            return cachedResult;
        }
        
        var result = await method.Invoke(target, args);
        cache[cacheKey] = result;
        return result;
    });

// Создаём прокси, добавляющий аспекты к методам
var userService = new UserService();
var proxy = aspectWeaver.CreateProxy(userService, builder => {
    builder.InterceptMethod("GetUserById", "logging", "caching");
    builder.InterceptMethod("UpdateUser", "logging", "validation");
});

// Вызов метода через прокси активирует все зарегистрированные аспекты
var user = await proxy.GetUserById(123);
```

Эти задания помогут вам освоить замыкания от простых примеров до сложных архитектурных решений. Начните с первых задач и постепенно переходите к более сложным по мере уверенного решения предыдущих.