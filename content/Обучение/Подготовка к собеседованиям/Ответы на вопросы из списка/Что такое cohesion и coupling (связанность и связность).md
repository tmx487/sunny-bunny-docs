---
уровень: "[[middle]]"
секция: общее
пройдено: 
теги: 
дата: 02-05-2024
время: 20:19
---
**Cohesion** (связанность) и **Coupling** (связность) — это важные концепции в программной инженерии и объектно-ориентированном проектировании, которые помогают оценивать и улучшать структуру и организацию кода.

![[cohesion_coupling.png]]

### Cohesion (Связанность)

**Связанность** описывает степень, в которой элементы внутри модуля (например, класса или модуля) работают вместе для выполнения одной задачи или функции. Высокая связанность означает, что компоненты модуля тесно связаны и выполняют связанные задачи, что делает модуль более понятным и легким для поддержки.

#### Примеры связанности:

1. **Высокая связанность**:
   - Класс `Order` может иметь методы для создания заказа, добавления товаров в заказ и вычисления итоговой суммы. Все методы и данные связаны с основной задачей — управлением заказом.

2. **Низкая связанность**:
   - Класс `Order` также может содержать методы для печати отчетов и работы с базой данных, которые не связаны напрямую с управлением заказом. Это делает класс более сложным и трудным для понимания и поддержки.

#### Преимущества высокой связанности:

- **Упрощение поддержки**: Модуль с высокой связанностью легче поддерживать, так как все элементы модуля направлены на решение одной задачи.
- **Переиспользуемость**: Модуль с высокой связанностью может быть легче переиспользовать в других частях системы, если его задача ясно определена.

### Coupling (Связность)

**Связность** описывает степень, в которой один модуль зависит от другого. Низкая связность означает, что модули имеют минимальные зависимости друг от друга, что делает систему более гибкой и устойчивой к изменениям. Высокая связность означает, что изменения в одном модуле могут потребовать изменений в других модулях.

#### Примеры связности:

1. **Низкая связность**:
   - Класс `OrderService` зависит от интерфейса `IOrderRepository` для доступа к данным. Если конкретная реализация репозитория меняется, это не требует изменений в классе `OrderService`, что обеспечивает низкую связность.

2. **Высокая связность**:
   - Класс `OrderService` напрямую использует конкретный класс `SqlOrderRepository` для доступа к данным. Изменения в `SqlOrderRepository` могут потребовать изменений в `OrderService`, что увеличивает связность.

#### Преимущества низкой связности:

- **Гибкость**: Низкая связность делает систему более гибкой и легче адаптируемой к изменениям, так как изменения в одном модуле имеют минимальное влияние на другие модули.
- **Упрощение тестирования**: Низкая связность облегчает модульное тестирование, так как модули могут быть протестированы независимо друг от друга.
- **Переиспользуемость**: Модули с низкой связностью могут быть легко переиспользованы в других системах.

### Взаимосвязь между Cohesion и Coupling

- **Идеальный дизайн**: В идеальном проектировании системы следует стремиться к высокой связанности внутри модулей и низкой связности между модулями. Это делает систему более понятной, легкой для поддержки и гибкой к изменениям.
- **Баланс**: В реальных системах часто приходится балансировать между высокой связанностью и низкой связностью в зависимости от требований и сложности системы.

### Пример

Рассмотрим пример на основе проектирования классов:

1. **Высокая связанность и низкая связность**:
   ```csharp
   // Интерфейс репозитория
   public interface IOrderRepository
   {
       void AddOrder(Order order);
       Order GetOrder(int orderId);
   }

   // Реализация репозитория
   public class SqlOrderRepository : IOrderRepository
   {
       public void AddOrder(Order order) { /* Реализация */ }
       public Order GetOrder(int orderId) { /* Реализация */ }
   }

   // Сервис заказов
   public class OrderService
   {
       private readonly IOrderRepository _orderRepository;

       public OrderService(IOrderRepository orderRepository)
       {
           _orderRepository = orderRepository;
       }

       public void CreateOrder(Order order)
       {
           _orderRepository.AddOrder(order);
       }
   }
   ```
   В этом примере `OrderService` имеет высокую связанность, так как все его методы связаны с управлением заказами, и низкую связность с `IOrderRepository`, так как он зависит только от интерфейса, а не от конкретной реализации.

2. **Низкая связанность и высокая связность**:
   ```csharp
   // Класс с низкой связанностью
   public class OrderManager
   {
       private readonly SqlOrderRepository _orderRepository;

       public OrderManager()
       {
           _orderRepository = new SqlOrderRepository();
       }

       public void CreateOrder(Order order)
       {
           _orderRepository.AddOrder(order);
       }
   }
   ```
   В этом примере `OrderManager` имеет низкую связанность, так как его метод связан только с управлением заказами, но высокая связность с `SqlOrderRepository`, так как он напрямую зависит от конкретной реализации репозитория.

В идеальном проектировании системы, следует стремиться к высокой связанности внутри модулей и низкой связности между модулями для обеспечения гибкости и легкости поддержки системы.