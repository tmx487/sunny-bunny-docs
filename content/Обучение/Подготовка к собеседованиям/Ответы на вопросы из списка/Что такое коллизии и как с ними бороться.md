---
уровень: "[[middle]]"
секция: типы, структуры и коллекции данных
пройдено: 
теги: 
дата: 02-05-2024
время: 20:34
---
Коллизии — это ситуации, когда два или более элемента данных приводят к одинаковому значению в некоторой структуре данных, такой как хеш-таблица или хеш-функция. В контексте программирования и структур данных, коллизии часто возникают в хеш-таблицах при использовании хеш-функций для распределения элементов по "корзинам" или "бакетам".

### Причины коллизий

Коллизии возникают из-за ограниченного количества корзин или бакетов для хранения данных и конечного диапазона возможных хеш-значений. Поскольку количество уникальных возможных входных данных может быть значительно больше, чем количество корзин, два разных элемента могут получить одинаковое хеш-значение и, следовательно, попадают в одну корзину.

### Примеры ситуаций с коллизиями

1. **Хеш-таблицы**: Если два различных ключа имеют одинаковый хеш-код, то это приведет к коллизии в хеш-таблице.
2. **Хеш-функции**: Например, в криптографических приложениях, где различные данные могут привести к одному и тому же хеш-значению.

### Методы борьбы с коллизиями

1. **Метод цепочек (Separate Chaining)**:
   - Использует связные списки или другие структуры данных для хранения всех элементов, имеющих одинаковый хеш-код. Каждый элемент с одинаковым хеш-значением добавляется в список, связанный с соответствующей корзиной.
   - **Пример**:
     ```csharp
     public class HashTableWithChaining<TKey, TValue>
     {
         private List<KeyValuePair<TKey, TValue>>[] table;

         public HashTableWithChaining(int size)
         {
             table = new List<KeyValuePair<TKey, TValue>>[size];
             for (int i = 0; i < size; i++)
                 table[i] = new List<KeyValuePair<TKey, TValue>>();
         }

         public void Add(TKey key, TValue value)
         {
             int hash = key.GetHashCode() % table.Length;
             var bucket = table[hash];
             foreach (var kvp in bucket)
             {
                 if (kvp.Key.Equals(key))
                 {
                     bucket.Remove(kvp);
                     break;
                 }
             }
             bucket.Add(new KeyValuePair<TKey, TValue>(key, value));
         }

         public TValue Get(TKey key)
         {
             int hash = key.GetHashCode() % table.Length;
             var bucket = table[hash];
             foreach (var kvp in bucket)
             {
                 if (kvp.Key.Equals(key))
                     return kvp.Value;
             }
             throw new KeyNotFoundException();
         }
     }
     ```

2. **Метод открытой адресации (Open Addressing)**:
   - Вместо хранения нескольких элементов в одной корзине, ищет другие свободные корзины для хранения элементов при возникновении коллизии. Использует различные стратегии поиска таких корзин.
   - **Стратегии поиска**:
     - **Линейное пробирование (Linear Probing)**: Проверяет следующие корзины последовательно, пока не найдет свободную.
     - **Квадратичное пробирование (Quadratic Probing)**: Использует квадратичную функцию для поиска следующих корзин.
     - **Двойное хеширование (Double Hashing)**: Использует вторую хеш-функцию для поиска новых позиций.

   - **Пример**:
     ```csharp
     public class HashTableWithOpenAddressing<TKey, TValue>
     {
         private KeyValuePair<TKey, TValue>?[] table;
         private int size;

         public HashTableWithOpenAddressing(int size)
         {
             this.size = size;
             table = new KeyValuePair<TKey, TValue>?[size];
         }

         public void Add(TKey key, TValue value)
         {
             int hash = key.GetHashCode() % size;
             int originalHash = hash;
             while (table[hash].HasValue && !table[hash].Value.Key.Equals(key))
             {
                 hash = (hash + 1) % size;
                 if (hash == originalHash) throw new Exception("Hash table is full");
             }
             table[hash] = new KeyValuePair<TKey, TValue>(key, value);
         }

         public TValue Get(TKey key)
         {
             int hash = key.GetHashCode() % size;
             int originalHash = hash;
             while (table[hash].HasValue)
             {
                 if (table[hash].Value.Key.Equals(key))
                     return table[hash].Value.Value;
                 hash = (hash + 1) % size;
                 if (hash == originalHash) throw new KeyNotFoundException();
             }
             throw new KeyNotFoundException();
         }
     }
     ```

3. **Изменение хеш-функции**:
   - Разработка более эффективных хеш-функций для распределения элементов равномернее по корзинам, что помогает уменьшить вероятность коллизий.

4. **Увеличение размера хеш-таблицы**:
   - Увеличение количества корзин в хеш-таблице, что помогает распределить элементы более равномерно и уменьшить количество коллизий. Обычно это делается путем повторного хеширования и перемещения существующих элементов в новую, более крупную таблицу.

### Преимущества и недостатки методов

- **Метод цепочек**:
  - **Преимущества**: Простота реализации, гибкость (не требует изменения размера таблицы).
  - **Недостатки**: Использует дополнительную память для хранения связанных списков.

- **Метод открытой адресации**:
  - **Преимущества**: Нет необходимости в дополнительной памяти для хранения связных списков.
  - **Недостатки**: Может привести к проблемам с производительностью при высоком уровне заполняемости.

### Заключение

Коллизии являются неотъемлемой частью работы с хеш-таблицами и другими структурами данных, использующими хеширование. Понимание и использование методов борьбы с коллизиями помогает обеспечить эффективность и производительность этих структур данных, а также позволяет минимизировать проблемы, возникающие из-за повторяющихся хеш-значений.