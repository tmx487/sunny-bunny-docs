---
уровень: "[[middle]]"
секция: управление_памятью
пройдено: 
теги: 
дата: 02-05-2024
время: 20:40
---
GC - это часть CLR. В момент работы сборщика мусора приложение полностью останавливается.

Объектам в LOH при их создании сразу же присваивается поколение 2. В LOH не проводится дефрагментация - оптимизация адресного пространства в памяти - т.к. это ресурсоемкая операция ввиду большого размера объектов.

Как GC понимает, что нужно удалить? Для этого создаются графы объектов - между объектами выстраиваются связи, через которые GC понимает востребованность объектов в программе. Чтобы понять какие объекты можно удалить, строится граф достижимости и все объекты, которые на достижимы из какой-либо вершины графа, удаляются GC. После удаления объектов, структура графа обновляется соответствующим образом. При этом, если процент фрагментации невелик, то после перестройки графа процедура дефрагментации запущена не будет.

Перед удалением объекта из кучи, на нем будет вызван метод `Destructor()` .

```c#
class Rocket
{
	Rocket()  // конструктор
	{}
	
	~Rocket() // деструктор = System.Object.Finilize()
	{}
}
```

> **В чем отличие деструктора от метода `System.Object.Finilize()` ? Ни в чем, это одно и то же.**

Все объекты, подлежащие удалению, помещаются в **Finalization Queue** (очередь финализации). GC, добираясь до Finalization Queue, сначала выполняет методы-деструкторы объектов, а затем только удаляет их из памяти.