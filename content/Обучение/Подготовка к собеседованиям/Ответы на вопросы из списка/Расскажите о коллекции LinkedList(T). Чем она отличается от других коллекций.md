---
уровень: "[[middle]]"
секция: типы, структуры и коллекции данных
пройдено: 
теги: 
дата: 02-05-2024
время: 20:30
---
Коллекция `LinkedList<T>` в .NET — это двусвязный список, который представляет собой коллекцию элементов, где каждый элемент (узел) содержит ссылки на предыдущий и следующий элемент. Это позволяет легко вставлять и удалять элементы в любом месте списка без необходимости перемещения других элементов.

### Основные особенности `LinkedList<T>`:

1. **Двусвязный список**:
   - Каждый элемент (или узел) в `LinkedList<T>` содержит ссылки как на следующий узел, так и на предыдущий. Это позволяет осуществлять двусторонний проход по списку.

2. **Операции вставки и удаления**:
   - Вставка и удаление элементов в `LinkedList<T>` выполняются быстро, поскольку эти операции могут быть выполнены без необходимости перемещения других элементов. Это делает `LinkedList<T>` полезным для задач, где требуется частое изменение структуры коллекции.

3. **Отсутствие индексов**:
   - В отличие от массивов и списков (`List<T>`), `LinkedList<T>` не поддерживает прямой доступ к элементам по индексу. Чтобы найти элемент, необходимо перебрать список от начала до конца или до конца от заданного узла.

4. **Память и производительность**:
   - Каждый элемент в `LinkedList<T>` требует дополнительной памяти для хранения ссылок на предыдущий и следующий элементы, что может увеличить общий объем памяти, необходимой для хранения коллекции.
   - Поиск элемента по индексу может быть медленнее, чем в коллекциях, таких как `List<T>`, поскольку требуется последовательный проход.

### Сравнение с другими коллекциями

1. **`List<T>`**:
   - `List<T>` представляет собой динамический массив и предоставляет быстрый доступ по индексу. Добавление и удаление элементов в середине списка может быть медленнее, так как элементы должны быть перемещены.
   - В `List<T>` вставка и удаление элементов требует перемещения элементов, что может быть медленным при работе с большими коллекциями, но `List<T>` предоставляет быстрый доступ к элементам по индексу.

2. **`Queue<T>` и `Stack<T>`**:
   - `Queue<T>` и `Stack<T>` также реализуют коллекции на основе массива или связанного списка, но с определенными ограничениями на доступ к элементам. Например, `Queue<T>` работает по принципу FIFO (First In, First Out), а `Stack<T>` по принципу LIFO (Last In, First Out).
   - `Queue<T>` и `Stack<T>` имеют фиксированные методы для добавления и удаления элементов, что ограничивает их использование по сравнению с `LinkedList<T>`.

3. **`Dictionary<TKey, TValue>`**:
   - `Dictionary<TKey, TValue>` представляет собой хеш-таблицу и обеспечивает быстрый доступ к элементам по ключу. В отличие от `LinkedList<T>`, `Dictionary<TKey, TValue>` не поддерживает упорядоченные элементы и не предназначен для частых вставок и удалений.

### Примеры использования `LinkedList<T>`

**Пример создания и использования `LinkedList<T>`:**

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        LinkedList<string> linkedList = new LinkedList<string>();

        // Добавление элементов
        linkedList.AddLast("Element 1");
        linkedList.AddLast("Element 2");
        linkedList.AddLast("Element 3");

        // Итерация по элементам
        foreach (var item in linkedList)
        {
            Console.WriteLine(item);
        }

        // Вставка элемента перед определенным узлом
        var node = linkedList.Find("Element 2");
        linkedList.AddBefore(node, "New Element");

        // Удаление элемента
        linkedList.Remove("Element 3");

        // Итерация после изменений
        foreach (var item in linkedList)
        {
            Console.WriteLine(item);
        }
    }
}
```

В этом примере:

- Элементы добавляются в конец списка с помощью метода `AddLast`.
- Мы вставляем новый элемент перед узлом с определенным значением.
- Мы удаляем элемент и затем итерируем по оставшимся элементам.

### Заключение

`LinkedList<T>` полезен, когда требуется частое добавление и удаление элементов в коллекции и когда прямой доступ по индексу не требуется. Он обеспечивает гибкость в работе с элементами, но может потреблять больше памяти и иметь медленное выполнение операций поиска по сравнению с другими коллекциями, такими как `List<T>`.