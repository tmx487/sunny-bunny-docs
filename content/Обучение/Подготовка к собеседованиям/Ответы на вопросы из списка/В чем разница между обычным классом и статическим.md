---
уровень: "[[junior]]"
секция: классы, структуры и интерфейсы
пройдено: true
теги: 
дата: 02-05-2024
время: 20:03
---
- Static-конструктор работает только со статическими членами класса.
- Со static-контсруктором не используются модификаторы доступа.
- В любом классе может быть только один статический конструктор.
- Статический конструктор не принимает никаких параметров.
- Статический конструктор вызывается ТОЛЬКО ОДИН РАЗ при создании первого экземпляра типа (даже если происходит вызов статических методов, то этот статический конструктор также вызывается только один раз).
- Статические члены типа могут работать только со статическими членами

**Статический класс**
- статический класс может содержать только статические члены (включая конструктор)
- ключевое слово this нельзя использовать при работе со статическим классом или его членами, за исключением случаев, когда речь идет о методов расширения
- статические классы не умеют в наследование и в реализацию интерфейсов (поэтому при использовании статических классов нельзя реализовать полиморфизм)
- на основании пункта выше, при использовании статических классов у них могут быть проблемы с DI[^1], а также с их тестированием[^2]

[^1]: Статические классы **не могут принимать зависимости через конструкторы или свойства** ([[static constructor]]), что делает невозможным их конфигурацию при помощи DI-контейнера. Это также ограничивает гибкость и расширяемость кода, так как статический класс жестко привязан к своей реализации и не может быть заменен альтернативной реализацией.

[^2]: Статические методы нельзя замокать или застафить (mock или stub) с использованием обычных инструментов мокирования, таких как Moq, NSubstitute или FakeItEasy. Это ограничивает возможность изолированного тестирования кода, который использует статические методы или классы, так как такие методы нельзя подменить тестовой реализацией
public static class DateTimeProvider
{
    public static DateTime Now => DateTime.Now;
}
Если DateTimeProvider.Now используется в коде, его невозможно будет замокать, чтобы вернуть фиксированное время в тестах, что делает тесты менее предсказуемыми и устойчивыми

> The following list provides the main features of a static class:
>
> - Contains only static members.
>
> - Can't be instantiated.
> 
> - Is sealed.
> 
> - Can't contain [Instance Constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors).

> Creating a static class is therefore basically the same as creating a class that contains only static members and a private constructor. A private constructor prevents the class from being instantiated. The advantage of using a static class is that the compiler can check to make sure that no instance members are accidentally added. The compiler guarantees that instances of this class can't be created.

> Static classes are **sealed** and **therefore can't be inherited**. *They can't inherit from any class or interface* except [Object](https://learn.microsoft.com/en-us/dotnet/api/system.object). Static classes can't contain an instance constructor. However, they can contain a static constructor. Non-static classes should also define a static constructor if the class contains static members that require non-trivial initialization. For more information, see [Static Constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors).

\- [msdn](#https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members)

**Методы расширения (extension methods)**
- методы расширения должны находиться в статическом классе и сами должны быть статическими
- могут принимать параметры (указываются сразу после первого параметра с this)
- методы расширения лучше размещать в отдельном пространстве имен


> *Extension methods are static methods, but they're called as if they were instance methods on the extended type. For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.*



```c#
// Define an interface named IMyInterface.
namespace DefineIMyInterface
{
    public interface IMyInterface
    {
        // Any class that implements IMyInterface must define a method
        // that matches the following signature.
        void MethodB();
    }
}

// Define extension methods for IMyInterface.
namespace Extensions
{
    using System;
    using DefineIMyInterface;

    // The following extension methods can be accessed by instances of any
    // class that implements IMyInterface.
    public static class Extension
    {
        public static void MethodA(this IMyInterface myInterface, int i)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, int i)");
        }

        public static void MethodA(this IMyInterface myInterface, string s)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, string s)");
        }

        // This method is never called in ExtensionMethodsDemo1, because each
        // of the three classes A, B, and C implements a method named MethodB
        // that has a matching signature.
        public static void MethodB(this IMyInterface myInterface)
        {
            Console.WriteLine
                ("Extension.MethodB(this IMyInterface myInterface)");
        }
    }
}

// Define three classes that implement IMyInterface, and then use them to test
// the extension methods.
namespace ExtensionMethodsDemo1
{
    using System;
    using Extensions;
    using DefineIMyInterface;

    class A : IMyInterface
    {
        public void MethodB() { Console.WriteLine("A.MethodB()"); }
    }

    class B : IMyInterface
    {
        public void MethodB() { Console.WriteLine("B.MethodB()"); }
        public void MethodA(int i) { Console.WriteLine("B.MethodA(int i)"); }
    }

    class C : IMyInterface
    {
        public void MethodB() { Console.WriteLine("C.MethodB()"); }
        public void MethodA(object obj)
        {
            Console.WriteLine("C.MethodA(object obj)");
        }
    }

    class ExtMethodDemo
    {
        static void Main(string[] args)
        {
            // Declare an instance of class A, class B, and class C.
            A a = new A();
            B b = new B();
            C c = new C();

            // For a, b, and c, call the following methods:
            //      -- MethodA with an int argument
            //      -- MethodA with a string argument
            //      -- MethodB with no argument.

            // A contains no MethodA, so each call to MethodA resolves to
            // the extension method that has a matching signature.
            a.MethodA(1);           // Extension.MethodA(IMyInterface, int)
            a.MethodA("hello");     // Extension.MethodA(IMyInterface, string)

            // A has a method that matches the signature of the following call
            // to MethodB.
            a.MethodB();            // A.MethodB()

            // B has methods that match the signatures of the following
            // method calls.
            b.MethodA(1);           // B.MethodA(int)
            b.MethodB();            // B.MethodB()

            // B has no matching method for the following call, but
            // class Extension does.
            b.MethodA("hello");     // Extension.MethodA(IMyInterface, string)

            // C contains an instance method that matches each of the following
            // method calls.
            c.MethodA(1);           // C.MethodA(object)
            c.MethodA("hello");     // C.MethodA(object)
            c.MethodB();            // C.MethodB()
        }
    }
}
/* Output:
    Extension.MethodA(this IMyInterface myInterface, int i)
    Extension.MethodA(this IMyInterface myInterface, string s)
    A.MethodB()
    B.MethodA(int i)
    B.MethodB()
    Extension.MethodA(this IMyInterface myInterface, string s)
    C.MethodA(object obj)
    C.MethodA(object obj)
    C.MethodB()
 */
```

### Binding Extension Methods at Compile Time

You can use extension methods to extend a class or interface, but **not to override** them. An extension method with the same name and signature as an interface or class method will never be called. At compile time, extension methods always have lower priority than instance methods defined in the type itself. In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method. When the compiler encounters a method invocation, it first looks for a match in the type's instance methods. If no match is found, it searches for any extension methods that are defined for the type, and bind to the first extension method that it finds.

В C# обычные и статические классы имеют разные цели и особенности, что делает их подходящими для различных сценариев.

### Обычный класс (Non-static class)

1. **Экземпляры**: 
   - Обычные классы могут иметь несколько экземпляров, каждый из которых хранит свои собственные данные (поля) и имеет свои собственные состояния.
   - Экземпляры создаются с помощью ключевого слова `new`, например: `var obj = new MyClass();`.

2. **Поля и методы**:
   - Обычные классы могут содержать как статические, так и нестатические поля и методы.
   - Нестатические методы и поля принадлежат конкретному экземпляру класса и могут взаимодействовать с его состоянием.
   - Статические методы и поля принадлежат самому классу и общие для всех экземпляров этого класса.

3. **Наследование**:
   - Обычные классы могут наследовать другие классы и могут быть унаследованы.
   - Поддерживают реализацию интерфейсов.

4. **Примеры использования**:
   - Подходят для реализации объектов с состоянием, которые могут изменяться в ходе выполнения программы.

### Статический класс (Static class)

1. **Экземпляры**:
   - Статические классы не могут иметь экземпляров. Это означает, что вы не можете создавать объекты статического класса с помощью ключевого слова `new`.
   - Все члены статического класса также должны быть статическими.

2. **Поля и методы**:
   - Статические классы могут содержать только статические поля и методы.
   - Статические методы могут вызываться напрямую через имя класса, без создания экземпляра: `MyStaticClass.MyMethod();`.

3. **Наследование**:
   - Статические классы не могут наследовать другие классы и не могут быть унаследованы.
   - Статические классы также не могут реализовывать интерфейсы.

4. **Примеры использования**:
   - Используются для создания вспомогательных (utility) классов, которые содержат методы и данные, общие для всего приложения. Например, это могут быть классы с методами для работы со строками, математическими операциями или конвертацией типов.

### Пример использования

#### Обычный класс:
```csharp
public class Car
{
    public string Model { get; set; }
    public int Year { get; set; }

    public void Drive()
    {
        Console.WriteLine($"{Model} is driving.");
    }
}

// Использование
var car = new Car { Model = "Toyota", Year = 2021 };
car.Drive();
```

#### Статический класс:
```csharp
public static class MathHelper
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}

// Использование
int result = MathHelper.Add(5, 10);
Console.WriteLine(result); // Вывод: 15
```

### Основные различия

1. **Создание объектов**:
   - Обычный класс: можно создать несколько объектов.
   - Статический класс: создание объектов невозможно.

2. **Члены класса**:
   - Обычный класс: может содержать как статические, так и нестатические члены.
   - Статический класс: содержит только статические члены.

3. **Наследование**:
   - Обычный класс: поддерживает наследование и реализацию интерфейсов.
   - Статический класс: не поддерживает наследование и реализацию интерфейсов.

Таким образом, обычные классы и статические классы в C# служат разным целям, и выбор между ними зависит от того, как именно планируется использовать класс в приложении.