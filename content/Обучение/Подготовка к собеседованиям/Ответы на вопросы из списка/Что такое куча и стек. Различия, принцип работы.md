---
уровень: "[[middle]]"
секция: управление_памятью
пройдено: true
теги: 
дата: 02-05-2024
время: 20:39
---
Управляемая куча (англ. Managed Heap)

Для доступа к ресурсу в C# нужно:
1. Выделить память для типа, представляющего ресурс (обычно это делается при помощи оператора `new` в C#).
2. Инициализировать выделенную память, установив начальное состояние ресурса и сделав его пригодным к использованию. За установку начального состояния типа отвечает его конструктор.
3. Использовать ресурс, обращаясь к членам его типа (при необходимости операция может повторяться).
4. В рамках процедуры очистки уничтожить состояние ресурса.
5. Освободить память. За этот этап отвечает **исключительно** уборщик мусора.

Иногда очистка ресурса должна выполняться как можно раньше, не дожидаясь вмешательства уборщика мусора. В таких классах можно вызвать дополнительный метод  (называемый `Dispose`), чтобы очистка была выполнена по вашему собственному расписанию. Как правило, типы, требующие специальной очистки, используют низкоуровневые системные ресурсы — **файлы, сокеты или подключения к базе данных**.

##### Чему равен размер кучи?
По мере заполнения области объектами CLR выделяет новые области, вплоть до заполнения всего адресного пространства. Таким образом, **память приложения ограничивается виртуальным адресным пространством процесса**. Для 32-разрядных процессов можно выделить до 1,5 гигабайта памяти, а для 64-разрядных процессов — около 8 терабайт памяти.

##### Алгоритм работы метода `new()`:
1) подсчет количества байтов для размещения полей типа и всех полей, что были унаследованы от базового типа;
2) к полученному количеству прибавляется количество байт, необходимое для **указателя на объект-тип** и **индекса блока синхронизации**;
3) проверка на предмет, есть ли в куче свободное место для объекта (если есть, то для него выделяется память и занимаемые им байты обнуляются); затем вызывается конструктор типа (передающий `NextObjPtr` в качестве параметра `this`), и оператор new возвращает ссылку на объект. 

>`NextObjPtr` - так Рихтер называет указатель, который указывает на базовый адрес зарезервированной под кучу области адресного пространства. Он определяет, где в куче будет выделена память для следующего объекта (вроде указателя на "голову" стека)

##### Алгоритм сборки мусора
CLR использует алгоритм ***отслеживания ссылок***. Алгоритм отслеживания ссылок работает ==**только**== с переменными ссылочного типа, потому что только эти переменные
могут ссылаться на объекты в куче; переменные значимых типов просто содержат данные экземпляра значимого типа. Все переменные ссылочных типов называются **корнями** (roots).
Алгоритм сборки мусора:
1) маркировка (поиск объектов для удаления, построение графа достижимости объектов)
2) сжатие (в этой фазе CLR перемещает вниз все «немусорные» объекты, чтобы они занимали смежный блок памяти, иначе происходит **дефрагментация**)

>Если CLR не удается освободить память в результате уборки мусора, а в процессах не осталось адресного пространства для выделения нового сегмента, значит, свободная память процесса полностью исчерпана. В этом случае попытка выделения новой памяти оператором `new()` приведет к выдаче исключения `OutOfMemoryException`

==Замечание Рихтера==

>**Статическое поле типа** хранит объект, на который ссылается, бессрочно или до выгрузки домена приложений с загруженными типами. Чаще всего утечка памяти возникает из-за хранения в статическом поле ссылки на коллекцию, в которую добавляются элементы. Статическое поле сохраняет объект коллекции, которая, в свою очередь, сохраняет все свои элементы. Поэтому статических полей следует по возможности избегать

	JIT-компилятор является оптимизирующим, а приравнивание локальной переменной или переменной-параметра к null равнозначно отсутствию ссылки на эту переменную

##### Поколения (англ. generations)

*Cборщик мусора с поддержкой поколений* (generational garbage collector), который также называют *эфемерным уборщиком мусора* (ephemeral garbage collector), работает на основе следующих предположений:
+ чем младше объект, тем короче его время жизни;
+ чем старше объект, тем длиннее его время жизни;
+ уборка мусора в части кучи выполняется быстрее, чем во всей куче.
Сразу после инициализации в управляемой куче нет объектов. К поколению 0 относятся только что созданные объекты, которых не касался сборщик мусора. При инициализации CLR выбирает пороговый размер для всех поколений.

>Если в результате выделения памяти для нового объекта размер поколения 0 превышает пороговое значение, должна начаться сборка мусора.

В поколении 2 находятся объекты, проверенные сборщиком мусора **не меньше 2** раз. Операций сборки мусора может быть много, но объекты поколения 1 проверяются только тогда, когда их суммарный размер достигает порогового значения — до этого обычно проходит несколько операций сборки мусора в поколении 0.
Управляемая куча поддерживает **только** три поколения: 0, 1 и 2. Поколения 3 не существует. При инициализации в CLR устанавливается пороговое значение для всех трех поколений. 

Если сборщик видит, что после сборки мусора в поколении 0 остается очень мало выживших объектов, он может снизить порог для поколения 0. В этом случае сборка мусора будет выполняться чаще, но это меньше загрузит сборщик, поэтому рабочий набор процесса останется небольшим. В сущности, если все объекты поколения 0 станут мусором, сборщику не придется даже дефрагментировать память — достаточно будет вернуть указатель `NextObjPtr` в начало поколения 0, чтобы посчитать сборку мусора законченной.
В то же время, если после обработки поколения 0 сборщик мусора обнаруживает множество выживших объектов, значит, удается освободить мало памяти. В этом случае сборщик мусора может поднять порог для поколения 0. В результате сборка мусора выполняется реже, но каждый раз будет освобождаться значительный объем памяти. Кстати, если сборщик освобождает недостаточно памяти, перед генерированием исключения `OutOfMemoryException` он выполняет полную сборку мусора.

> Пороговые значения применяются аналогичным образом и для поколений 1 и 2

	Класс `GCNotification` позволяет проанализировать код приложения, чтобы лучше понять каким образом оно использует память

##### Запуск сборки мусора

Помимо ситуации, когда объем поколения 0 превысил свое значение, сборка мусора запускается в следующих случаях:
- вызов статического метода `System.GC.Collect()` 
- Windows сообщает о нехватке памяти
- выгрузка домена приложения
- завершение работы CLR

##### Большие объекты (LargeObjectsHeap)

- память для них выделяется в отдельной части адресного пространства
- к  большим объектам не применяется сжатие (англ. *compaction*), так как на их перемещение в памяти потребуется слишком много процессорного времени
- большие объекты **всегда** считаются частью поколения 2. Размещение в памяти короткоживущих больших объектов приведет к необходимости частой уборки мусора в поколении 2, что снижает производительность.

> Обычно в больших объектах хранятся большие строки (например, XML или JSON) или массивы байтов, используемые в операциях ввода/вывода — например, при чтении данных из файла или сети в буфер для последующей обработки


**Стек** работает по принципу LIFO (last in first out). Взять данные из можно только из его "головы", но ни из какой-либо другой части. На стеке можно разместить типы, унаследованные от `System.ValueType` (напр., bool, byte, char, float, short, uint, **enum, struct**, etc), указатели на объекты, служебная информация

Куча может хранить следующие типы данных: ссылочные типы; типы значения. Существует 3 типа кучи: **SOH** (small objects (до 85кбайт) heap), **LOH** (large objects (свыше 85кбайт) heap), **POH** (pinned objects heap - появился с выходом .net5 в ноябре 2020)