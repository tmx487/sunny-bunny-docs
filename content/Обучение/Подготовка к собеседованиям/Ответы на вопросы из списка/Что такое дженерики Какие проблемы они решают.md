---
уровень: "[[junior]]"
секция: типы, структуры и коллекции данных
пройдено: 
теги: 
дата: 02-05-2024
время: 19:52
---
- когда мы используем разные типы данных, .NET каждый раз генерирует новый метод для работы с новым типом данных

Дженерики (Generics) в C# — это мощный инструмент, позволяющий создавать классы, методы, интерфейсы и делегаты, которые могут работать с любыми типами данных без необходимости конкретизировать типы данных при написании кода. Дженерики обеспечивают типобезопасность и повышают повторное использование кода, избегая дублирования кода и необходимости приведения типов.

### Основные концепции дженериков:

1. **Параметры типа**:
    
    - При создании дженерика вы можете использовать параметры типа, которые обозначаются как `<T>` (где `T` — это имя параметра типа). Имя `T` традиционно используется, но вы можете использовать любые имена, которые имеют смысл в вашем контексте.
    
    csharp
    
    Copy code
    
    `public class GenericClass<T> {     public T Value { get; set; }      public GenericClass(T value)     {         Value = value;     } }`
    
2. **Типобезопасность**:
    
    - Дженерики позволяют избежать ошибок времени выполнения, связанных с неверным приведением типов. Код проверяется на этапе компиляции, что снижает вероятность ошибок.
    
    csharp
    
    Copy code
    
    `List<int> numbers = new List<int>(); numbers.Add(1);        // Компилируется успешно numbers.Add("string"); // Ошибка компиляции`
    
3. **Повторное использование кода**:
    
    - Дженерики позволяют использовать один и тот же код для работы с различными типами данных, что значительно снижает дублирование кода и делает его более поддерживаемым.
    
    csharp
    
    Copy code
    
    `public T Add<T>(T a, T b) {     return a + b; // Пример для чисел, оператор "+" должен быть определен для типа T }`
    
4. **Ограничения (Constraints)**:
    
    - Вы можете задавать ограничения для параметров типа, чтобы указать, какие операции могут выполняться с типами, переданными в дженерики. Например, вы можете указать, что тип должен реализовывать интерфейс или наследоваться от определенного класса.
    
    csharp
    
    Copy code
    
    `public class Repository<T> where T : IEntity {     public void Save(T entity)     {         // Код для сохранения объекта, реализующего интерфейс IEntity     } }`
    

### Примеры использования дженериков:

1. **Коллекции**:
    
    - Одним из самых распространенных применений дженериков является работа с коллекциями. Например, `List<T>`, `Dictionary<TKey, TValue>`, `Queue<T>` и т.д.
    
    csharp
    
    Copy code
    
    `List<string> names = new List`

### Так говорил ChatGPT

Дженерики (Generics) в C# — это мощная особенность языка, которая позволяет вам создавать типобезопасные и многократно используемые компоненты, такие как классы, интерфейсы, методы и делегаты. Дженерики позволяют параметризовать тип данных, что делает ваш код более гибким, снижает дублирование и улучшает безопасность типов во время компиляции.

### Проблемы, которые решают дженерики:

1. **Повторное использование кода**:
   - Без дженериков приходилось бы создавать разные реализации для различных типов данных. Например, до введения дженериков коллекции (такие как `ArrayList`) могли хранить объекты любого типа, что требовало приведения типов и создавало риск ошибок выполнения.
   - С дженериками можно создать одну реализацию класса или метода, которая будет работать с любым типом данных, заданным в параметре.

   **Пример:**
   ```csharp
   public class GenericList<T>
   {
       private T[] elements;
       private int count;

       public void Add(T element)
       {
           // Добавление элемента в список
       }

       public T Get(int index)
       {
           return elements[index];
       }
   }
   ```

   В этом примере класс `GenericList<T>` может быть использован для работы с любым типом данных, который будет указан при создании экземпляра: `GenericList<int>`, `GenericList<string>` и т.д.

2. **Безопасность типов**:
   - Дженерики помогают избежать ошибок, связанных с некорректными преобразованиями типов (type-casting), так как типы проверяются на этапе компиляции.
   - Без дженериков, например, в коллекциях данных, приходилось бы использовать тип `object`, что требовало приведения типов (cast) при извлечении данных и могло приводить к ошибкам времени выполнения.

   **Пример:**
   ```csharp
   var intList = new List<int>();  // Лист, который может содержать только int
   intList.Add(10);
   int value = intList[0];  // Безопасно, не нужно приведение типов
   ```

3. **Производительность**:
   - Дженерики устраняют необходимость в боксе (boxing) и анбоксе (unboxing) для типов значений (value types). **Боксинг и анбоксинг** — это операции преобразования значимых типов в тип `object` и обратно, которые могут быть дорогими с точки зрения производительности.
   - С дженериками такие операции не требуются, что делает код более эффективным.

   **Пример:**
   ```csharp
   List<int> intList = new List<int>();  // Нет боксинга
   ```

4. **Поддержка типов, заданных пользователем**:
   - Дженерики позволяют создавать коллекции и методы, которые могут работать с пользовательскими типами данных, не зная их заранее. Это значительно упрощает код и делает его более универсальным.

   **Пример:**
   ```csharp
   public T FindMax<T>(T a, T b) where T : IComparable<T>
   {
       return a.CompareTo(b) > 0 ? a : b;
   }
   ```

   В этом примере метод `FindMax` может сравнивать объекты любых типов, которые реализуют интерфейс `IComparable<T>`.

### Основные элементы дженериков:

1. **Generic классы**:
   - Классы, где тип данных параметризован.
   - Пример: `List<T>`, `Dictionary<TKey, TValue>`.

2. **Generic методы**:
   - Методы, в которых тип данных параметризован.
   - Пример: `public T GenericMethod<T>(T param)`.

3. **Generic интерфейсы**:
   - Интерфейсы, где тип данных параметризован.
   - Пример: `IEnumerable<T>`, `IComparable<T>`.

4. **Generic делегаты**:
   - Делегаты, в которых тип данных параметризован.
   - Пример: `Func<T, TResult>`, `Action<T>`.

### Пример использования дженериков:

```csharp
public class Pair<T1, T2>
{
    public T1 First { get; set; }
    public T2 Second { get; set; }

    public Pair(T1 first, T2 second)
    {
        First = first;
        Second = second;
    }
}

// Использование
var pair = new Pair<int, string>(1, "one");
Console.WriteLine($"First: {pair.First}, Second: {pair.Second}");
```

В этом примере класс `Pair<T1, T2>` может быть использован с любыми двумя типами данных.

### Заключение
Дженерики в C# обеспечивают мощный способ создания типобезопасного и повторно используемого кода. Они решают проблемы безопасности типов, повышают производительность и делают код более гибким и универсальным, позволяя легко адаптироваться к различным типам данных без необходимости дублирования кода.