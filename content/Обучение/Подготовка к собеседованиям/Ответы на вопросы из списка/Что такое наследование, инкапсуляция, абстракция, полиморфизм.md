---
уровень: "[[junior]]"
секция: общее
пройдено: true
теги: 
дата: 02-05-2024
время: 18:53
---
**Абстракция**
```csharp
using TeacherResource.Domain.UserAggregate;

namespace TeacherResource.Application.Persistence
{
    public interface IUserRepository
    {
        User? GetUserByEmail(string email);
        void Add(User user);
    }
}
```

**Инкапсуляция**
```csharp
 public sealed class User : AggregateRoot<UserId, Guid>
    {
        public string Login { get; private set; }
        public string Password { get; private set; }
        public string Role { get; private set; }
	// ...
}
```

Бывает трех видов:
- сокрытие типов данных (неявно типизированные локальные переменных, динамическая типизация)
- сокрытие реализации (модификаторы доступа, приведение к базовому типу)
- инкапсуляция вариаций (сокрытие частей программных систем, когда создаем класс, который ссылается на объекты других классов)

**Наследование**
```csharp
public abstract class Entity<TId>
{
	// ...
}

public abstract class AggregateRoot<TId, TIdType> : Entity<TId>
	where TId : AggregateRootId<TIdType>
{
	// ...
}
```

**Полиморфизм** — это один из ключевых принципов объектно-ориентированного программирования (ООП), который позволяет использовать объекты разных типов через один и тот же интерфейс. Он достигается чаще всего с использованием наследования и интерфейсов. *Полиморфизм позволяет вам вызывать методы **производного** класса через ссылку на **базовый** класс, при этом вызывается именно версия метода производного класса*.

### Зачем нужен полиморфизм?

1. **Гибкость и расширяемость**: Позволяет легко добавлять новые классы и изменять существующие, не изменяя код, который использует базовый интерфейс.
2. **Упрощение кода**: Помогает избежать дублирования кода, так как общий интерфейс может быть использован для работы с разными классами.

```csharp
using System;
using System.Collections.Generic;

// Интерфейс для обработки платежей
public interface IPayment
{
    void Pay(decimal amount);
}

// Класс для обработки платежа с помощью кредитной карты
public class CreditCardPayment : IPayment
{
    public string CardNumber { get; set; }

    public CreditCardPayment(string cardNumber)
    {
        CardNumber = cardNumber;
    }

    public void Pay(decimal amount)
    {
        Console.WriteLine($"Платеж {amount:C} выполнен с помощью кредитной карты: {CardNumber}");
    }
}

// Класс для обработки платежа через PayPal
public class PayPalPayment : IPayment
{
    public string Email { get; set; }

    public PayPalPayment(string email)
    {
        Email = email;
    }

    public void Pay(decimal amount)
    {
        Console.WriteLine($"Платеж {amount:C} выполнен через PayPal для: {Email}");
    }
}

// Класс для обработки наличных платежей
public class CashPayment : IPayment
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Платеж {amount:C} выполнен наличными.");
    }
}

// Класс для управления платежами
public class PaymentProcessor
{
    private readonly List<IPayment> _payments = new List<IPayment>();

    public void AddPayment(IPayment payment)
    {
        _payments.Add(payment);
    }

    public void ProcessPayments(decimal amount)
    {
        foreach (var payment in _payments)
        {
            payment.Pay(amount); // Полиморфный вызов метода Pay()
        }
    }
}

// Основная программа
public class Program
{
    public static void Main(string[] args)
    {
        PaymentProcessor paymentProcessor = new PaymentProcessor();

        // Добавляем разные способы оплаты
        paymentProcessor.AddPayment(new CreditCardPayment("1234-5678-9876-5432"));
        paymentProcessor.AddPayment(new PayPalPayment("user@example.com"));
        paymentProcessor.AddPayment(new CashPayment());

        // Обработка платежей
        decimal amountToPay = 150.00m;
        paymentProcessor.ProcessPayments(amountToPay);
    }
}
```

1. **Интерфейс IPayment**: Определяет метод `Pay`, который будет реализован всеми классами для различных способов оплаты.
    
2. **Класс CreditCardPayment**: Реализует `IPayment` и определяет, как выполняется платеж с помощью кредитной карты.
    
3. **Класс PayPalPayment**: Реализует `IPayment` и обрабатывает платежи через PayPal.
    
4. **Класс CashPayment**: Реализует `IPayment` для наличных платежей.
    
5. **Класс PaymentProcessor**: Управляет списком платежей и обрабатывает их. Здесь используется полиморфизм, так как метод `ProcessPayments` работает с разными реализациями `IPayment` через общий интерфейс.

>*Полиморфизм может быть реализован как через наследование, так и через композицию*

```csharp
// Полиморфизм через наследование

public class Animal
{
    public virtual void Speak() { Console.WriteLine("Animal makes a sound."); }
}

public class Dog : Animal
{
    public override void Speak() { Console.WriteLine("Woof!"); }
}

public class Cat : Animal
{
    public override void Speak() { Console.WriteLine("Meow!"); }
}

// Это позволяет сделать следующее:
List<Animal> animals = new List<Animal> { new Dog(), new Cat() };
foreach (var animal in animals)
{ 
		animal.Speak();
}
```

```csharp
// Полиморфизм через композицию

public interface IPayment
{
    void Pay(decimal amount);
}

public class CreditCardPayment : IPayment { /* Реализация */ }
public class PayPalPayment : IPayment { /* Реализация */ }

public class PaymentProcessor
{
    private IPayment _payment;

    public PaymentProcessor(IPayment payment)
    {
        _payment = payment;
    }

    public void ProcessPayment(decimal amount)
    {
        _payment.Pay(amount);
    }
}

// Использование
PaymentProcessor processor = new PaymentProcessor(new CreditCardPayment());
processor.ProcessPayment(100.00m);
```

### Когда использовать наследование или композицию?

- **Используйте наследование, когда:** существует логическая связь "is-a" (является) между классами. Например, собака — это животное, поэтому можно использовать наследование.
- **Используйте композицию, когда:** существует связь "has-a" (имеет) или когда вы хотите создать гибкую и повторно используемую структуру. Например, автомобиль имеет двигатель, поэтому композиция здесь подходит лучше.

**==Виды полиморфизма==**

> Все то, что ***во время компиляции или исполнения программы может содержать или обрабатывать значения различных типов — является полиморфным***, например:
> - переменные, меняющие свое значение на значение другого типа;
> - объекты, обладающие свойствами, которые могут менять значение текущего типа на значение другого типа;
> - функции, принимающие аргументы различных типов.

\- [Полиморфизм простыми словами](#https://medium.com/devschacht/polymorphism-207d9f9cd78)

Полиморфизм — это одна из ключевых концепций объектно-ориентированного программирования (ООП), позволяющая объектам разных классов обрабатывать данные с одинаковым интерфейсом. Существуют несколько типов полиморфизма, каждый из которых играет свою роль в контексте программирования. Основные типы полиморфизма следующие:

### **1. Динамический полиморфизм (или полиморфизм времени выполнения)**

Динамический полиморфизм основан на наследовании и интерфейсах, позволяя объектам использовать методы, определенные в базовых или интерфейсных классах, но с реализацией, специфичной для их собственного класса. Это достигается через переопределение методов.

Пример на языке C#:

```csharp
public class Animal
{
    public virtual void Speak() { Console.WriteLine("Animal speaks"); }
}

public class Dog : Animal
{
    public override void Speak() { Console.WriteLine("Woof!"); }
}

public class Cat : Animal
{
    public override void Speak() { Console.WriteLine("Meow!"); }
}

// Использование
Animal myAnimal = new Dog();
myAnimal.Speak(); // Выведет "Woof!"
```

### **2. Статический полиморфизм (или полиморфизм времени компиляции, ad-hoc)**

Статический полиморфизм достигается через перегрузку методов и операторов. Это значит, что можно определить несколько методов с одним именем, но с различными параметрами (различие может быть в количестве параметров, их типах или порядке).

Пример перегрузки методов:

```csharp
public class MathOperations
{
    public int Add(int a, int b) { return a + b; }
    public double Add(double a, double b) { return a + b; }
    public int Add(int a, int b, int c) { return a + b + c; }
}

// Использование
MathOperations math = new MathOperations();
int result1 = math.Add(2, 3); // Вызов метода с двумя int
double result2 = math.Add(2.5, 3.5); // Вызов метода с двумя double
int result3 = math.Add(1, 2, 3); // Вызов метода с тремя int
```

### **3. Полиморфизм через интерфейсы**

Полиморфизм также может быть реализован через интерфейсы. Несколько разных классов могут реализовывать один и тот же интерфейс, обеспечивая однородное взаимодействие. Это позволяет вызывать методы у объектов различных классов, не зная их конкретного типа.

Пример:

```csharp
public interface IShape
{
    void Draw();
}

public class Circle : IShape
{
    public void Draw() { Console.WriteLine("Drawing a Circle"); }
}

public class Square : IShape
{
    public void Draw() { Console.WriteLine("Drawing a Square"); }
}

// Использование
IShape shape1 = new Circle();
shape1.Draw(); // Выведет "Drawing a Circle"

IShape shape2 = new Square();
shape2.Draw(); // Выведет "Drawing a Square"
```

### **4. Полиморфизм через коллекции базового класса**

Этот тип полиморфизма также основывается на динамическом полиморфизме, когда коллекции объектов базового класса могут содержать объекты всех унаследованных классов. Это позволяет применять методы базового класса к объектам производных классов.

Пример:

```csharp
List<Animal> animals = new List<Animal> { new Dog(), new Cat() };
foreach (var animal in animals)
{
    animal.Speak(); // Вызывает соответствующий метод Speak для каждого типа Animal
}
```

**Самое лучшее определение полиморфизма в книге банды четырех:**

**==Полиморфизм - возможность во время выполнения подставить вместо одного объекта другой с таким же интерфейсом.==**

>*Динамическое связывание* означает, что **отправка некоторого запроса не определяет никакой конкретной реализации до момента выполнения**. Следовательно, возможно написать программу, рассчитанную на объект с конкретным интерфейсом, точно зная, что любой объект с подходящим интерфейсом сможет принять этот запрос. Более того, **динамическое связывание позволяет во время выполнения подставить вместо одного объекта другой, если он имеет идентичный интерфейс**. **Такая взаимозаменяемость называется полиморфизмом** и является важнейшей особенностью объектно-ориентированных систем. Она позволяет клиенту ограничиваться минимальными предположениями об объектах — а именно поддержкой этими объектами определенного интерфейса. Полиморфизм упрощает определение клиентов, позволяет отделить объекты друг от друга и дает объектам возможность изменять отношения между ними во время выполнения.

\- Паттерны проектирования банды четырех, гл.1.6, стр. 33

==Классический (принудительный)== полиморфизм имеет два вида:
- использование виртуальных членов (в базовом есть виртуальные методы, которые мы реализуем в производном) - данная форма доминирует над следующей
- приведение типов (экземпляр производного приводим к базовому - upcast)

>Техника **замещения** (когда в базовом классе нет virtual, а в дочернем - override) не является полиморфной

==Ad-hoc== полиморфизм (полиморфизм для конкретного случая) 

см. паттерн Шаблонный метод (см. стр.373), на данной паттерне построен другой - NVI (non-virtual interface) не виртуальный интерфейс

### Практика
```csharp
// NVI - (Non-Virtual Interface) невиртуальный интерфейс

namespace NVI
{
	public class Base 
	{
		public void DoWork() // шаблонный метод
		{
			PreDoWork();
			CoreDoWork();
		}
	protected virtual void PreDoWork() {Console.WriteLine("0");}
	protected virtual void CoreDoWork() {Console.WriteLine("1");}
	}

	public class Derived : Base
	{
		protected override void CoreDoWork() {Console.WriteLine("2");}
	}
}

// Перекрытие

namespace
{
	public class BaseClass
	{
		public virtual void SomeMethod1() => Console.WriteLine("1");
		public virtual void SomeMethod2() => Console.WriteLine("2");
	}

	public class DerivedClass : BaseClass
	{
		public new void SomeMethod1() => Console.WriteLine("3");
		public sealed override void SomeMethod2() => Console.WriteLine("4");
	}
}

BaseClass inst = new DerivedClass();
inst.SomeMethod1();
inst.SomeMethod2();


// Замещение

namespace
{
	public class BaseClass
	{
		public void SomeMethod1() => Console.WriteLine("1");
		public void SomeMethod2() => Console.WriteLine("2");
	}

	public class DerivedClass : BaseClass
	{
		public new void SomeMethod1() => Console.WriteLine("3");
		public void SomeMethod2() => Console.WriteLine("4");
	}
}

BaseClass inst = new DerivedClass();
inst.SomeMethod1(); //1
inst.SomeMethod2(); //2

DerivedClass inst2 = inst as DerivedClass; // downcast, т.к. inst имеет тип базового класса
inst2.SomeMethod1(); //3
inst2.SomeMethod2(); //4
```

>Замещение полиморфного (виртуального) метода называется **перекрытием**
### Ad-hoc

```csharp
namespace AdHocPolimorphism
{
	public class Class1 { public void Method() => Console.WriteLine("1");}
	public class Class1 { public void Method() => Console.WriteLine("2");}
	public class Class1 { public void Method() => Console.WriteLine("3");}

	class Program
	{
		static void Main()
		{
			dynamic[] array = {new Class1(), new Class2(), new Class3()};

			foreach (var item in array)
				item.Method();
			Console.ReadKey();
		}
	}
}

namespace AdHocPolimorphism
{
	public class Class1 { public void Method() => Console.WriteLine("1");}
	public class Class1 { public void Method() => Console.WriteLine("2");}
	public class Class1 { public void Method() => Console.WriteLine("3");}


	interface IInterface { void Method(); }

	class MyClass1 : Class1, IInterface { }
	class Program
	{
		static void Main()
		{
			dynamic[] array = {new Class1(), new Class2(), new Class3()};

			foreach (var item in array)
				item.Method();
			Console.ReadKey();
		}
	}
}
```

>Перегрузка - это не полиморфизм, это всего лишь выбор способа выполнения действия, конфигурирование запроса  (см. паттерн ?)

