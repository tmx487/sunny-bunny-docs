---
уровень: "[[junior]]"
секция: общее
пройдено: 
теги: 
дата: 2024-05-02
время: 19:15
---

Параллельное программирование, также известное как многопоточность, — это техника разработки программного обеспечения, при которой задачи разделяются на несколько потоков, выполняющихся одновременно. Это позволяет улучшить производительность и эффективность приложений, особенно на системах с несколькими ядрами процессора.

### Назначение параллельного программирования

1. **Повышение производительности**: Использование всех доступных ядер процессора для выполнения задач.
2. **Улучшение отзывчивости**: Асинхронное выполнение операций, чтобы пользовательский интерфейс оставался отзывчивым.
3. **Повышение пропускной способности**: Одновременное выполнение множества операций ввода-вывода или запросов к базе данных.

### Основные классы и пространства имен для параллельного программирования в .NET

#### Пространства имен

- **System.Threading**: Основное пространство имен для работы с потоками и синхронизацией.
- **System.Threading.Tasks**: Пространство имен для работы с задачами и асинхронными операциями.
- **System.Collections.Concurrent**: Пространство имен для коллекций, безопасных для многопоточности.

#### Классы и структуры

1. **Thread** (из `System.Threading`)
    
    - Класс для создания и управления потоками.
    - Позволяет явно создавать и контролировать потоки.

```csharp
using System.Threading;

class Program
{
    static void Main()
    {
        Thread thread = new Thread(new ThreadStart(DoWork));
        thread.Start();
    }

    static void DoWork()
    {
        // Код, выполняемый в потоке
    }
}
```

2. **Task** (из `System.Threading.Tasks`)

- Класс для представления асинхронных операций.
- Упрощает управление параллельными задачами по сравнению с `Thread`.

```csharp
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task task = Task.Run(() => DoWork());
        task.Wait();
    }

    static void DoWork()
    {
        // Код, выполняемый в задаче
    }
}
```

3. **Task\<TResult>** (из `System.Threading.Tasks`)

- Обобщенный класс для задач, возвращающих результат

```csharp
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task<int> task = Task.Run(() => Calculate());
        int result = task.Result;
    }

    static int Calculate()
    {
        // Код, выполняющий вычисления и возвращающий результат
        return 42;
    }
}
```

4. **Parallel** (из `System.Threading.Tasks`)

- Класс для выполнения параллельных операций, таких как циклы `for` и `foreach`.

```csharp
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Parallel.For(0, 10, i =>
        {
            // Код, выполняемый параллельно для каждого значения i
        });
    }
}
```

5. **CancellationToken** и **CancellationTokenSource** (из `System.Threading`)

- Классы для управления отменой асинхронных операций.

```csharp
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        CancellationTokenSource cts = new CancellationTokenSource();
        Task task = Task.Run(() => DoWork(cts.Token), cts.Token);

        // Отменить задачу через 2 секунды
        cts.CancelAfter(2000);

        try
        {
            task.Wait();
        }
        catch (AggregateException ex)
        {
            if (ex.InnerExceptions[0] is TaskCanceledException)
            {
                Console.WriteLine("Task was canceled.");
            }
        }
    }

    static void DoWork(CancellationToken token)
    {
        for (int i = 0; i < 10; i++)
        {
            if (token.IsCancellationRequested)
            {
                Console.WriteLine("Cancellation requested.");
                token.ThrowIfCancellationRequested();
            }
            Console.WriteLine(i);
            Thread.Sleep(500);
        }
    }
}
```

6. **BlockingCollection\<T>** (из `System.Collections.Concurrent`)

- Класс для создания коллекций, безопасных для многопоточного доступа, с поддержкой блокировки.

```csharp
using System.Collections.Concurrent;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        BlockingCollection<int> collection = new BlockingCollection<int>();

        Task producer = Task.Run(() =>
        {
            for (int i = 0; i < 10; i++)
            {
                collection.Add(i);
                Thread.Sleep(100);
            }
            collection.CompleteAdding();
        });

        Task consumer = Task.Run(() =>
        {
            foreach (var item in collection.GetConsumingEnumerable())
            {
                Console.WriteLine(item);
            }
        });

        Task.WaitAll(producer, consumer);
    }
}
```