---
уровень: "[[junior]]"
секция: общее
пройдено: 
теги: 
дата: 02-05-2024
время: 19:21
---

Unit-тесты и интеграционные тесты имеют разные цели, методы и уровни проверки кода в процессе разработки программного обеспечения. Вот основные различия между ними:

### Цель

- **Unit-тесты**: Цель unit-тестов — проверка функциональности отдельных модулей или компонентов приложения изолированно. Они тестируют мелкие, атомарные части кода, такие как функции, методы или классы, чтобы убедиться, что они работают как ожидается.
    
- **Интеграционные тесты**: Цель интеграционных тестов — проверка взаимодействия между несколькими модулями или компонентами. Они тестируют, как различные части системы работают вместе, обеспечивая правильную интеграцию и взаимодействие компонентов.
    

### Уровень проверки

- **Unit-тесты**: Проверяют небольшие, изолированные участки кода, обычно без внешних зависимостей.
    
- **Интеграционные тесты**: Проверяют группы модулей или компонентов, которые взаимодействуют друг с другом, часто с участием внешних зависимостей, таких как базы данных, внешние сервисы или API.
    

### Изоляция

- **Unit-тесты**: Используют заглушки (stubs), моки (mocks) или фейки (fakes) для изоляции тестируемого кода от внешних зависимостей. Это позволяет сосредоточиться на функциональности конкретного модуля.
    
- **Интеграционные тесты**: Включают реальные компоненты и их взаимодействия. Они меньше полагаются на заглушки и больше на реальную инфраструктуру, такую как базы данных и сервисы.
    

### Время выполнения

- **Unit-тесты**: Обычно выполняются быстро, поскольку они тестируют маленькие кусочки кода в изоляции и не требуют запуска больших частей системы или внешних ресурсов.
    
- **Интеграционные тесты**: Могут быть медленнее, так как они включают взаимодействие между компонентами и могут требовать настройки и использования реальных баз данных, сетей и других ресурсов.
    

### Ошибки и отладка

- **Unit-тесты**: Легче отлаживать и локализовать ошибки, так как они фокусируются на небольших и изолированных частях кода.
    
- **Интеграционные тесты**: Могут быть сложнее в отладке, поскольку ошибка может возникать из-за взаимодействия нескольких компонентов или внешних зависимостей.
    

### Примеры кода

**Unit-тест на C# с использованием xUnit и Moq**:

```c#
public class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }
}

public class CalculatorTests
{
    [Fact]
    public void Add_ShouldReturnSumOfTwoNumbers()
    {
        // Arrange
        var calculator = new Calculator();
        
        // Act
        var result = calculator.Add(2, 3);
        
        // Assert
        Assert.Equal(5, result);
    }
}

```

**Интеграционный тест на C# с использованием xUnit и Entity Framework**:

```c#
public class OrderServiceTests
{
    private readonly DbContextOptions<AppDbContext> _options;

    public OrderServiceTests()
    {
        _options = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase(databaseName: "TestDatabase")
            .Options;
    }

    [Fact]
    public async Task PlaceOrder_ShouldSaveOrderInDatabase()
    {
        // Arrange
        using var context = new AppDbContext(_options);
        var orderService = new OrderService(context);

        var order = new Order { Id = 1, ProductName = "Test Product", Quantity = 1 };

        // Act
        await orderService.PlaceOrderAsync(order);

        // Assert
        var savedOrder = await context.Orders.FindAsync(1);
        Assert.NotNull(savedOrder);
        Assert.Equal("Test Product", savedOrder.ProductName);
    }
}
```

### Заключение

- **Unit-тесты**: Быстрые, изолированные, легко отлаживаемые, проверяют отдельные модули или функции.
- **Интеграционные тесты**: Более медленные, сложнее отлаживать, проверяют взаимодействие между модулями или компонентами, часто включают реальную инфраструктуру.

Оба типа тестов важны и дополняют друг друга, обеспечивая комплексное тестирование приложения и повышение его надежности.